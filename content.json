{"meta":{"title":"Float's blog","subtitle":"float's blog","description":"float's blog | 浮躁哥的技术博客","author":"float","url":"http://zexiplus.github.io"},"pages":[],"posts":[{"title":"常用面试问题记录与分析","slug":"Interview","date":"2018-12-04T03:46:17.636Z","updated":"2018-12-04T03:46:17.636Z","comments":true,"path":"2018/12/04/Interview/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/Interview/","excerpt":"","text":"interview 收录了经典前端面试题和解答 目录[TOC] 简历 基本信息, 姓名-年龄-收集-邮箱-籍贯-博客-github 学历 工作经历, 时间-公司-岗位-职责-技术栈-业绩 开源项目, github和说明 兴趣, 和技术相近的兴趣 自我介绍 把握面试的沟通方向 豁达自信适度发挥 面试技巧面试要素 知识 能力 项目把控能力, 业务分析能力, 抽象设计能力 经验 面试流程 一面 基础知识, html, js, css 二面 基础知识延伸, 实现原理, 简历问的比较多 三面 一般不问技术, 职业生涯特色业务, 你推动了什么, 你改变了什么 终面 潜力, 沟通, 性格 面试准备 职位分析 业务分析, 实战模拟 技术栈准备 自我介绍 一面基础知识html 语意化标签: section章节, article容器, nav导航, aside附加栏, header页头, main主题内容, footer页脚 替换元素： input, select, img, 这类根据标签属性的元素 非替换元素： div, span 这类根据内容显示的元素 meta标签都有哪些作用 Web app 这个meta的作用是让普通移动网页被添加到主屏幕后，拥有一些类native的功能, 就是类似隐藏ios的上下状态栏，实现全屏，禁止弹性拖拽，全屏，修改顶部颜色等 1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; 指定渲染引擎 1&lt;meta name=\"renderer\" content=\"webkit\"&gt; 关键字 1&lt;meta name=\"keywords\" content=\"\"&gt; 内容, 用于搜索引擎优化 1&lt;meta name=\"description\" content=\"\"&gt; 指定视窗大小 1&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; link标签除了引用css外, 还有什么作用 link标签 dns 预解析 1&lt;link rel=\"dns-prefetch\" href=\"//static.123.com\"&gt; 阻塞js的下载和执行会阻塞之后所有资源的下载 当css外部样式表后面跟着js资源之前时会阻塞 页面布局 实现一个左右宽度300,高度已知, 中间自适应的布局, 各有什么优点, 缺点, 兼容性 变形题: 实现一个上下高度固定, 中间高度自适应的页面 浮动, 缺点: 脱离文档流 ,带来混乱. 优点: 兼容性好 绝对定位, 缺点: 脱离文档流 ,带来之后元素混乱. 优点: 兼容性好 flex布局 , 优点: 其中某个单元格高度增加, 其他单元格高度也增加. 缺点: 新特性兼容性不好 12.container &#123; display: flex; &#125; .center &#123;flex: 1&#125; table 布局, 优点: 兼容性极好, 其中某个单元格高度增加, 其他单元格高度也增加 12.container &#123;display: table;&#125; .left, .right, .center &#123;display: table-cell&#125; 网格布局, 优点: 先进的 123456.container &#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px;&#125; css计算属性 12.left, .right &#123;width: 300px;&#125;.center &#123;width: calc(100vw - 600px)&#125; css盒模型 标准盒模型, ie盒模型. 包括margin, border, padding, content 两者差别:计算宽度不同, css如何设置box-sizing: border-box/content-box; js如何获取和设置不同盒模型的宽高 12345678// 只能获取内联样式的宽高el.style.width/height// ie获取元素宽高el.currentStyle.width/height// 通用获取元素的宽和高window.getComputedStyle(el).width/heightel.getBoundingClientReact().width/height/left/right BFC 块级格式化上下文 bfc渲染规则: 垂直方向不发生重叠 bfc区域不会与浮动元素重叠 bfc在页面上是一个容器, 之外的元素不会影响内部元素, 内部也不影响外部元素. bfc创建: float值不为none, position值不为static或relative display: table, table-cell overflow值不为visible bfc使用场景 消除边距重叠 解决浮动子元素无法撑开父元素高度 dom事件 dom事件的级别 dom0 1el.onclick = function () &#123;&#125; dom2 1el.addEventListener('click', function () &#123;&#125;, false) // 不使用事件捕获 dom3 , 增加了多种事件类型, 鼠标, 键盘等 1el.addEventListener('keyup', function () &#123;&#125;, false) dom事件模型 捕获, 冒泡 dom事件流 捕获阶段, 处于目标阶段, 冒泡阶段 dom事件捕获的具体流程 window , document, html(document.documentElement), body, target event对象常见应用 阻止默认行为 event.preventDefault() 阻止冒泡 event.stopPropagation() 组织同一元素多个事件绑定其他事件的发生 event.stopImmediatePropagation() event.currentTarget 事件绑定的dom对象 event.target 事件触发时的具体元素 自定义事件 123var ev = new Event('custom') // var ev = new CustomEvent('custom', &#123;name: 'a'&#125;)el.addEventListener('custom', function () &#123;&#125;)el.dispatchEvent(ev) http协议 http协议的主要特点 简单快速, 灵活, 无连接, 无状态 https和http的主要区别 介绍 http默认端口80，https默认端口443 https在http基础上增加了网络安全层ssl协议, 分为对称加密和非对称加密, 比较多使用rsa算法为主的公钥加密技术 https的web服务器启用ssl需要获得一个公钥证书，并将该证书与要使用ssl的服务器绑定, 证书的目的是为了让客户端区分公钥是否伪造和属于谁的问题 http报文的组成成分 请求报文: 请求行: http方法, 请求地址,http协议和版本 请求头 一些key, value值 空行 请求体 响应报文: 状态行 相应头 空行 响应体 常用请求头 Accept, accept-encoding, host, referer, cookie, connection 常用响应头 Allow, Content-Length, Set-Cookie,Etag, content-type http方法 get 获取资源 post 传输资源 put 更新资源 delete 删除资源 head 获得报文首部 post和get区别 get产生的url地址可被收藏, 而post不可以 get请求会被浏览器主动缓存, post不会 get只能url编码, 而post支持多种编码 get请求的url长度有限(过长截断), 而post没有 get比post更不安全, 参数通过url传递, post放在requestbody中 http状态码 1xx: 表示请求已接收, 继续处理 2xx: 成功-请求已成功被接收 200 请求成功 206 部分请求成功(视频, 音频类的流文件) 3xx: 重定向, 要完成请求需进一步操作 301请求的页面已经永久转移到新的url 302 临时转移 304 资源未改动, 请求缓存 4xx: 客户端错误 400 请求的语法错误 401 请求未授权 403: 禁止访问 404 资源不存在 5xx: 服务器错误 500 服务器内部错误 503 服务器宕机或过载 什么是持久连接 1.1版本支持持久连接,非 keep-alive 模式时, 没请求一次都要断开重新连接, 当使用connection: keep-alive时, 可持续连接,必须基于 http1.1 的持久连接, 只有get和head才可以进行管线化 什么是管线化 管线化：请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应 2…. 非管线化： 请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 - 面向对象 类的声明, 生成实例 * 构造函数方式 1function Animal(name) &#123;this.name = name&#125; * class关键字 12345class Animal &#123; constructor (name) &#123; this.name = name &#125;&#125; 实例化 1new Animal() 如何实现继承, 继承的几种方式 借助构造函数实现继承 缺点: 不能继承原型对象上的属性和方法 12345678910111213function Parent1() &#123; this.name = 'parent'&#125;// 不会继承原型链上的属性Parent1.prototype.say = function () &#123; return this.name&#125;function Child1() &#123; // 关键: 借助构造函数 Parent1.call(this); this.type = 'child'&#125;new Child1().say() // 没有此方法,报错 error 借助原型链实现的继承 缺点: 共享原型对象属性, 导致不同实例上对原型对象上属性的修改,对互相产生影响 1234567891011121314151617function Parent2() &#123; this.name = 'parent' this.arr = [1,2,3,4]&#125;function Child2() &#123; this.type = 'child'&#125;// 关键: 借助原型链Child2.prototype = new Parent2var child = new Child()var child2 = new Child()console.log(child.constructor) // Parent2child.arr.push(5)console.log(child2.arr) // 共享原型属性 [1,2,3,4,5] 组合式继承 缺点: 父类调用两次 1234567891011121314151617function Parent3() &#123; this.name = 'parent'&#125;function Child3() &#123; Parent3.call(this) this.type = 'child'&#125;Child3.prototype = new Parent3()// 优化1: 组合继承(父类只调用一次), 缺点: constructor无法正确指向Child3.prototype = Parent3.prototype// 优化2: 组合继承(父类只调用一次), constructor也能正确指向Child3.prototype = Object.create(Parent3.prototype)Child3.prototype.constructor = Child3 寄生式继承 缺点: 子类原型对象无法继承 123456789function Parent4() &#123; this.name = 'parent4'&#125;function Child() &#123; var obj = new Parent4 obj.type = 'child' return obj&#125; 原型链 创建对象的几种方法 对象字面亮 12var obj = &#123;a: 1&#125;var obj2 = new Object(&#123;a: 1&#125;) 构造函数 12function Car() &#123;&#125;var obj = new Car() Object.create 12var proto = &#123;a: 1&#125;var instance = Object.create(proto) 原型, 构造函数, 实例, 原型链 instanceof原理, constructor new 运算符 会创建一个object 然后把此object的原型链链接到构造函数的prototype对象上 执行构造函数, 把this绑定到此对象上 如果此函数没有反回对象, 那么new运算符的结果就是此对象 通信 什么是同源策略即限制 源: 协议, 域名(包括子域名不一致), 端口不一致 例子: a.interview.com 访问interview.com属于跨域, interview.com访问a.interview.com也是跨域 同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互.这是一个隔离潜在恶意文件的安全机制. 具体限制: cookie, localStorage 和 indexDB 无法读取, dom无法获得, ajax无法发送(或成功发送浏览器并不响应) 前后端如何通讯 ajax (fetch) websocket 支持跨域 cors 如何创建ajax(兼容性) XMLHttpRequest, ActiveXObject 123456789var xhr = new XMLHttpRequest()xhr.open('post', url, ture) // 参数3: 是否为异步请求xhr.onload = function() &#123; if ([200, 304, 206].includes(xhr.status)) &#123; &#125;&#125;// or onreadystatechange(0未打开,1未发送,2已获取相应头,3正在下载响应体,4请求完成)xhr.send(data) 跨域通讯的几种方式 浏览器会自动拦截跨域ajax请求, 并添加origin发送跨域通信 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件. 这段描述不准确，并不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。 cors(跨域的ajax) 跨域资源共享CORS 是一种机制，它使用额外的 HTTP头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST请求，浏览器必须首先使用 OPTIONS方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies和 HTTP 认证相关数据） cors的请求头 这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨域请求时，它们已经被设置就绪 origin 1Origin: &lt;origin&gt; Access-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器 Access-Control-Request-Headers 其作用是，将实际请求所携带的首部字段告诉服务器 cors响应头 Access-Control-Allow-Origin: * origin 参数的值指定了允许访问该资源的外域 URI, * 表示所有 Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法 Access-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容 Access-Control-Allow-Headers 用于预检请求的响应。其指明了实际请求中允许携带的首部字段 Access-Control-Expose-Headers 在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头 jsonp 利用script标签的跨域加载 123456&lt;script src=\"https://abc.com/js/?data=123&amp;callback=jsonp\"&gt;&lt;/script&gt;&lt;script&gt; jsonp(&#123; data: &#123;&#125; &#125;)&lt;/script&gt; js发送jsonp 12345var script = docuement.createElement('script')script.insertBefore(document.body)script.onload = function () &#123; callback()&#125; hash 利用window.onhashchange 1234567var iframe = document.createElement('iframe')iframe.src = 'http://123.com#6778'// 123.comwindow.onhashchange = function () &#123; var data = window.location.hash&#125; postMessage 1234567var win = window.open('a.com')win.postMessage('data')// a.comwindow.addEventListener('message', function (event) &#123; console.log(event.origin, event.source, event.data)&#125;) webSocket 1234var ws = new WebSocket('wss://echo.websocket.org')ws.onopen = function () &#123;&#125;ws.onmessage = function (event) &#123;console.log(event.data)&#125;ws.onclose = function () &#123;&#125; 安全 csrf (跨站请求伪造) 在用户注册过的网站A登录过, 并下发cookie 在恶意网站诱导用户点击网站A的链接(接口存在漏洞) 防御: token验证 referer验证, 请求是否从可信站点发起 xss(跨域脚本攻击) 向页面注入脚本 防御: 过滤用户输入 算法 排序 快速排序 选择排序 希尔排序 冒泡排序 堆栈, 队列, 链表 递归 波兰式和逆波兰式 二面渲染机制 doctype及作用 DTD文档类型定义, 浏览器使用它来判断文档类型, 决定使用何种协议来解析和切换浏览器模式 doctype是用来声明文档类型和dtd规范的 文档类型 html5, html4.01strict模式, 包含所有html元素属性,不包含展示性和弃用的元素(比如front) html4.01传统模式（怪异模式） 包含所有html元素属性, 也包含弃用元素 浏览器的渲染过程 html - html parse 解析- dom tree style - css parse 规则解析 - style-rules style rules 和 dom tree 整合, 变为 render tree(渲染树), 浏览器layout决定元素的位置和大小, 绘制页面(painting) 重排reflow dom 中每个元素都有自己的盒子, 这些都需要浏览器计算放到他们应有的位置, 此过程重排reflow 触发reflow 增加, 删除, 修改dom节点时 移动dom的位置 修改css样式的时候(宽高,display) resize窗口的时候 修改网页默认字体 重绘repaint dom位置, 大小确定后, 展现在屏幕上的过程称为repaint 触发repaint dom改动 css改动 减少repaint次数方法 使用 createDocumentFregment创建节点, 一次性加入页面 浏览器在输入url敲回车后发生了什么? DNS域名解析； 建立TCP连接； 发送HTTP请求； 服务器处理请求； 返回响应结果； 关闭TCP连接； 浏览器解析HTML； 浏览器布局渲染； 步骤详解 建立tcp连接 发送http请求 关闭tcp连接 js运行机制 什么是单线程? javascript同一时间只能做一件事情 什么是任务队列? js分为同步任务和异步任务, 同步任务在主线程(执行栈)执行, 当主线程没有任务可以执行时, 异步任务从异步队列中取出执行 同步任务 console, if, while, 异步任务 setTimeout, setInterval,dom事件, promise 什么是event loop(事件循环)? Event Loop 是一个很重要的概念，指的是计算机系统的一种运行机制, Event Loop是一个程序结构，用于等待和发送消息和响应事件 每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务 宏任务和微任务的定义和优先级? setInterval, setTimeout是宏任务, 比promise, process.nextTick这种微任务慢 12345678910setTimeout(() =&gt; console.log(0), 0)new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then(res =&gt; &#123; console.log(2)&#125;)console.log(3)// 1, 3, 2, 0 页面性能 提升页面性能的方法? 资源压缩合并, 减少http请求 非核心代码异步加载 – 异步加载的方式 – 异步加载的区别 异步加载的方式 动态创建脚本 createElement(‘script’) defer 是在html解析完之后(domContentLoaded事件)才会执行, 如果多个, 按照顺序依次执行 async 是在加载完之后立即执行, 如果是多个, 和声明顺序无关 利用浏览器缓存 – 缓存的分类 – 缓存的原理 分类 强缓存(优先级较高): 请求浏览器直接使用已有的缓存， 两者都有以cache-control为准 Expires Expires: Thu 21 Jan 2018 ..(以服务器的绝对时间为准) Cache-Control Catch-Control: max-age=3600(以客户端拿到文件3600秒为止) 协商缓存: 不确定是否使用, 先和服务器沟通再决定是否使用， 服务器接收请求会对比以下字段 在 第二次 请求 的 时候， 浏览器 会把 这个 Last- Modified 带上， 变成 If- Modified- Since 字段， 如果已有直接返回304 Last-Modified Etag if-None-matchd 使用cdn dns预解析 12&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//host_name_to_prefetch.com\"&gt; 动画性能 实现动画的方式: 1.js控制dom动画, 2.svg动画(path), 3. canvas + css3 动画 使用硬件加速优化页面性能， 默认transform， transition 不使用3d加速， 但transform3d使用3d加速 错误监控 前端错误分类 及时运行错误(代码错误) try … catch window.onerror(只能捕获及时运行错误, 不能捕获资源错误) 资源加载错误(不会冒泡, 但会捕获) object.onerror performance.getEntries(), 返回一个数组, 内含有成功加载的资源. Error事件捕获 12345window.addEventListener('error', function (e) &#123; console.log(e)&#125;, true)throw new Error 错误的捕获方式(如何保证产品质量) 跨域js文件错误处理 客户端script增加crossorigin属性 服务端资源响应增加Access-Control-Allow-Origin: * 如果没有上述两个设置， 跨域js不会报错 上报错误的基本原理 采用Ajax通信的方式上报 利用Image对象上报 1new Image().src = 'http://error.com/test?error=123' 三面专业素养 业务能力 团队协作能力 事物推动能力 带人能力 其它能力 业务能力 我做过什么? 负责的业务有什么业绩 使用了什么技术方案 突破了什么技术难点 遇到了什么问题 最大的收获是什么 DEMO 独立负责360彩票走势图开发 历时三周完成所有采种开发, 用户量上涨15% 区别常规canvas方案, 使用vml + svg方案 解决了走势图高级绘图板的开发 橡皮擦的问题, 动态连线计算等 对业务的理解更加深入, 对技术图表更有把握 团队协作能力事物推动能力 对历史算法更新换代 推动专题的cms架构 主导客服系统建设 完成多项专利申请 带人能力代码规范, code review 组织能力, 学习能力, 行业能力 项目分析大数据营收系统项目任务： 整体项目框架搭建，包括文件结构组织，以来模块的引入，webpack配置，vue-router路由全局钩子，axios全局拦截器设置， 代码规范检查设置 （组长做的比较多， 其他每个组员都有分工） highChart 各种图表初始化参数的配置（每个人员根据自身分配的路由页面， 来进行配置， 如果有和他人重叠的地方，互相沟通） element-ui主题定制， 特色开发（这个由我来做， 主要修改了element-variables.scss文件的配置， 和不同组件对应的css文件修改） 公共组件的开发（对于页面中出现频率较高的组件， 例如日期筛选栏， 数字表盘， 排行榜等）协同开发 个人分配的路由页面开发 项目业绩 ： 公司通过分析用户喜好和营收数据，2018年调整战略， 营业额持续提升 整体方案: 难点 第一次协同开发， 对git的合并， 提交比较生疏， 对gitflow流程不太熟悉 克服： 参看网上教程， 对git命令多使用， 不懂的问组长 对于设计图给出但highchart无法实现的需要通过dom动画的方式来模拟， 并封装成公共组件进行调用， 这其中还需要考虑数据极差比较大的情况下对小数据的良好显示，动画的平滑过渡 收获 代码规范提高， 协同开发能力提升 对Vue的使用， hightChartjs的配置熟悉， 公共组件的抽象能力提高 对业务理解力， 业务处理能力都有显著提高 wall.e 开源硬件机器人项目技术方案： 页面Vue, 服务端采用express搭建服务器接受请求, johnny-five开源库操纵各个传感器和硬件io 功能： 局域网/公网下远程遥控前后左右 视频实时传输 温度采集与持久保存 加速度测量 gps定位（因为硬件端口冲突未实现） 思路&amp;亮点 采用分布式思想, 服务器, 页面, 数据分别存在不同位置 客户端与智能硬件之间采用动态连接 通信协议采用websocket 保证实时传输的延迟较低 可以使用公网/局域网模式 难点 nodejs调试和硬件调试比较困难, 错误难以定位,日志难以分析 克服: 上网查找nodejs的调试方法,学会使用node-inspector 服务器文件运行在开发板上, 文件同步比较困难, 每次更改需要手动ftp传到开发板上,或者直接在开发板上编辑并运行代码, 但这样比较卡 客服: 用nodejs的fs.watch api 监听开发目录变化, 当文件变动自动执行process.exec 内传入的ftp命令, 开发板使用forever或者pm2守护进程, 当代码更改自动重启服务器 页面温度计能根据传感器的输入改变颜色和长度, 其中使用canvasapi 绘制温度计, 写了一个函数把温度作为输入, 颜色和长度作为输出, 调整温度计的变化 Colorful.css根据用户选择主题色, 生成可定制的css, 有网页版本和命令行版本 使用的技术: 动态创建样式技术, node命令行 收获 熟悉了node怎样编写一个命令行软件, 怎么创建并发布一个npm包 四面关键点 乐观积极自信 主动沟通 逻辑顺畅 上进有责任心 有主张, 做事果断 职业竞争力 业务能力 思考能力 学习能力 无上限的付出, 责任 职业规划 目标是什么 在业务上称为专家, 在技术上称为行业大牛 近阶段的目标 不断的学习积累个方面的经验, 以学习为主 长期目标 做几件很有价值的事情, 比如开源作品, 技术框架等 方式方法 先完成业务上的主要问题, 做到极致, 然后逐步向目标靠拢 补充补充前面章节缺少的知识点 Promise 基本用法 12345678910111213141516171819202122232425262728// 定时promisefunction timeout(m, message) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, m, message) &#125;)&#125;timeout(1000, 'message').then(function (m) &#123; console.log(m)&#125;)// 图片加载promisefunction imgPromise(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = new Image() img.timeBegin = new Date() img.onload = function () &#123; resolve(img) &#125; img.onerror = function (err) &#123; console.error('can not load img' + url) &#125; img.src = url &#125;)&#125;imgPromise('//cdn2.jianshu.io/assets/web/web-note-ad-side-banner-22096669b4c4b91c3b9266894e951aef.png').then((img) =&gt; &#123; img.timeEnd = new Date() console.log('spend time', img.timeEnd - img.timeBegin)&#125;) Promise.resolve（param） 将现有对象转化为promise对象 123Promise.resolve(123)// 相当于new Promise(resolve =&gt; resolve(123)) 参数： 空： 直接返回一个resolved状态的promise对象 promise对象， 直接返回原对象， 不做处理 不具有then方法的对象， 或不是对象： 返回新promise对象， 状态为resolved 12const p = Promise.resolve(666)p.then(() =&gt; &#123;console.log(666)&#125;) // 666 具有then方法的对象， 先转换为promise对象， 然后立即执行thenable的then方法 12345678let thenable = &#123; then: function (resolve, reject) &#123;resolve('7878')&#125;&#125;let p = Promise.resolve(thenable)p.then(function(value) &#123; console.log(value)&#125;) Promise.reject(param) 返回一个promise实例， 状态为rejected 123456const p = Promise.reject('666')// 相当于const m = new Promise((resolve, reject) =&gt; reject('666'))m.then(null, function (s) &#123; console.log(s)&#125;) Promise.all Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例 Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数 1234const p = Promise.all([p1, p2, p3])p.then(function ([p1val, p2val, p3val]) &#123; console.log(p1val, p2val, p3val)&#125;) Promise.race(竞赛) 将多个 Promise 实例，包装成一个新的 Promise 实例 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数 12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); Promise.prototype.then(resolveCallback, rejectCallback) then期望接受一个函数， 若不是函数， 将会发生值穿透， then方法返回的是一个新的promise， 不是之前的promise对象， 可以采用链式调用 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数 1234567getMember(id).then(function (member) &#123; return getComment(comment.id)&#125;).then(function (comment) &#123; console.log(comment)&#125;, fucntion (err) &#123; console.error(err) &#125;) Promise.prototype.catch(rejectCallback) catch是then(null, rejectCallback)的语法糖 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); Promise.prototype.finally finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作 Promise题目 分析打印结果 12345678910111213let p = Promise.resolve(1)p.then(function (value) &#123; console.log(value) return 3&#125;).then(function (value) &#123; console.log(value)&#125;)setTimeout(function () &#123; console.log(4)&#125;, 0)console.log(2)// 2, 1, 3, 4 123456789101112131415let p = Promise.resolve(1)p.then(function (value) &#123; console.log(value) return new Promise((resolve, reject) =&gt; &#123; resolve(3) &#125;)&#125;).then(function (value) &#123; console.log(value)&#125;)setTimeout(function () &#123; console.log(4)&#125;, 0)console.log(2)// 2, 1, 3, 4 状态只能改变一次 123456789101112131415const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success1') reject('error') resolve('success2')&#125;) promise .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;)// then: success1 值穿透 .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透 12345Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log)// 1 错误捕获 12345678910Promise.resolve() .then(function success (res) &#123; throw new Error('error') &#125;, function fail1 (e) &#123; console.error('fail1: ', e) &#125;) .catch(function fail2 (e) &#123; console.error('fail2: ', e) &#125;)// fail2: ... 深入响应式原理与MVVM思想什么是AST？AST（abstruct syntax tree）抽象语法树， 是源代码的抽象结构的树状表现。 Vue在mount过程中， template会被编译为AST，经过generate（AST转化为render函数）得到render， render函数返回Vnode， Vnode是Vue的虚拟dom节点， 保存着标签名， 子节点， 属性， 文本信息等 Vue 的 VNode渲染为真实dom（diff算法）的实现 ? vue源码在src/core/vdom/patch.js实现 createPatchFunction 接受一个参数， 返回一个 patch 函数 patch 接受参数 oldVnode， vnode, hydrating, removeOnly, parentElm, refElm, 用于对比新旧Vnode变化，执行相应操作 oldVnode: 旧的虚拟节点或旧的真实dom节点 vnode: 新的虚拟节点 hydrating: 是否要跟真是dom混合 removeOnly: 特殊flag，用于组件 parentElm:父节点 refElm: 新节点将插入到refElm之前 patch 函数 实现 若 oldVnode 存在， vnode不存在， 则调用 invokeDestroyHook(oldVnode) 销毁oldVnode 若vnode存在， oldVnode不存在， 则使用createElm新建vnode 若vnode和oldVnode是相同的VirtualNode， 则调用 patchVnode 比较两个节点的差异 当vnode和oldVnode不是同一个节点时， 创建Vnode插入到oldVnode.elm的父节点上 patchVnode 实现 如果oldVnode === Vnode 直接返回， 无操作 如果vnode和oldVnode具有相同的key， 则把oldVnode.elm和oldVnode.child都复制到vnode上，也不用再有其他操作 如果vnode是text节点， 就设置文本内容 如果vnode不是text节点 如果oldVnode与vnode都有子节点，并且子节点不相等，就调用updateChildren执行更新子节点操作 oldVnode没有子节点，vnode有子节点，则创建节点 oldVnode有子节点，vnode没有子节点，就移除旧的节点 如果oldVnode为text节点，就移除文本节点 Vnode的分类都有哪些？ EmptyVnode TextVnode ComponentVnode ElementVnode CloneVnode react 的 diff算法实现过程? 介绍 Web 界面由 DOM 树来构成，当其中某一部分发生变化时，其实就是对应的某个 DOM 节点发生了变化. 给定任意两棵树, 寻找差异, 找到最少转换步骤.标准的diff算法复杂度是O(n^3), react优化后的diff算法复杂度降为O(n). diff算法思想(优化假设) 两个相同组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构 对于同一层次的一组子节点，它们可以通过唯一的 id 进行区分 节点比较 节点类型不同的比较 在同一位置前后输出了不同类型的节点, 则直接替换 12span ---&gt; divremoveNode span , insertNode div 逐层进行节点比较, 两棵树只会对同一层次的节点进行比较.及不在同一层的节点, 即使他们完全一样, 也会销毁并重建. 如图. React 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较 相同类型节点比较 对于相同类型的节点, react会对属性进行重设从而实现节点转换 123renderA: &lt;div id=\"before\" /&gt;renderB: &lt;div id=\"after\" /&gt;=&gt; [replaceAttribute id \"after\"] 列表节点的比较, React 会逐个对节点进行更新，转换到目标节点 vue 实现vue的几个关键类有哪些， 作用是什么类: Compile，对指令进行解析，初始化视图，并且订阅数据的变更，绑定好更新函数 Observer，对数据进行劫持，通知数据的变化 Watcher，将其作为以上两者的一个中介点，在接收数据变更的同时，让Dep添加当前Watcher，并及时通知视图进行update Dep 发布订阅事件相关 MVVM，整合以上三者，作为一个入口函数 步骤： 第一步：创建MVVM、Compile类，并且利用createDocumentFragment将&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;下的标签放到JS文档碎片中去。 第二步：Compiler对 标签 进行编译，将带有 v- 指令的标签和{}的标签解析出来 第三步：创建Observer类进行数据劫持、深度递归劫持和代理，当data中设置值或者修改值的时候，利用Object.defineProperty对值进行监控。 第四步：创建Watch类观察者，用新值和老值进行比对，如果发生变化，就调用更新方法，进行视图更新。 第五步：将输入框v-model和视图绑定起来，输入框的值变化，同时页面中通过{}绑定的值也变化，实现双向数据绑定。 第六步：在MVVM类中，设置proxyData代理，将vm.$data的值代理到vm上，即可以直接通过 vm vue是什么？ 有哪些特性？ vuejs是一套基于mvvm思想的， 构建用户界面的框架。vue在设计上着重关心视图层， 特点有双向数据绑定， vue后缀的单文件组件， 低耦合， 可复用性强， 独立开发， 可测试性， 2.0支持virtualdom. 特性： 数据驱动， 单文件组件系统 vue如何优化首屏加载速度？ 大文件定位， 使用webpack bundle analyzer， 运行npm run build --report 查看工程js大小，， 优化大文件 路由视图懒加载 1const page = () =&gt; require('page.vue') 将js文件放入body的最后， 使用html-webpack-plugin插件， 将inject的值改为body 12345plugins: [ new htmlWebpackPlugin(&#123; inject: &apos;body&apos; &#125;) ] 将其他js库使用cdn方式引入 UI库按需引用 开启gzip压缩 在config/index.js 123build: &#123; productionGzip: true&#125; Vue打包后会生成哪些文件 index.html 单页文件入口 app.[hash].css 所有组件中的css app.[hash].js 包含所有组件中的js代码 vendor.[hash].js 包含vue及其他node_modules代码 mainifest.[hash].js 包含了webpack运行环境和模块化所需的js 0~n.[hash].js vue-router按需加载生成的js key的作用? 用于管理可复用的元素, vue保证高效的渲染元素, 通常会复用已有元素而不是从头开始. keep-alive 的作用? 主要用于保留组件状态和避免重新渲染, 属性: include(保存组件状态)和exclude(不缓存组件的状态) 怎么实现缓存个别组件？ 使用keep-alive组件， 在需要缓存的router配置中加入meta 123&lt;keep-alive&gt; &lt;router-view v-if=\"$router.meta.keepAlive\"&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 123456789101112new Router(&#123; routes: [ &#123; path: '/page1', component: page1, name: 'page1', meta: &#123; keepAlive: true // 控制是否缓存此组件 &#125; &#125; ]&#125;) 实现页面切换动画效果？ 1234567891011121314151617&lt;transiton name=\"slide-left\"&gt; &lt;component :is=\"componentName\"&gt;&lt;/component&gt;&lt;/transiton&gt;&lt;style&gt; .slide-left-enter-active &#123; animation: slideLeft 0.3s; &#125; @keyframes slideLeft &#123; from &#123; transform: translate3d(100%, 0, 0);/*横坐标,纵坐标,z坐标*/ visibility: visible; &#125; to &#123; transform: translate3d(0, 0, 0); &#125; &#125;&lt;/style&gt; vue的生命周期? vue的实例从新建到销毁的过程, 具体包括: 开始创建–初始化数据–编译模版–挂载dom渲染–更新渲染—卸载 vue生命周期的钩子函数有哪些， 做了什么？ beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 created 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)， 属性和方法的运算，watch/event 事件回调, 此时$el属性未赋值，ajax调用建议在此阶段执行 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子 activated keep-alive 组件激活时调用 deactivated keep-alive 组件停用时调用 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用 destoryed Vue 实例销毁后调用 errorCaptured 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及错误信息字符串 vue-router 当路由从/page?id=1变为/page?id=2时怎么通知视图更新 使用watch 监控 $route 对象 12345watch: &#123; '$route': function (to, from) &#123; ... &#125;&#125; 使用路由守卫beforeRouteUpdate 1234beforeRouteUpdate(to, from, next) &#123; ... next()&#125; vue-router的钩子函数有哪些？ 全局守卫： router.beforeEach 全局解析守卫： router.beforeResolve 全局后置钩子： router.afterEach 路由独享的守卫： beforeEnter 组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave vue-router 导航解析流程？ 1、导航被触发。 2、在失活的组件里调用离开守卫。 3、调用全局的 beforeEach 守卫。 4、在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 5、在路由配置里调用 beforeEnter。 6、解析异步路由组件。 7、在被激活的组件里调用 beforeRouteEnter。 8、调用全局的 beforeResole 守卫 (2.5+)。 9、导航被确认。 10、调用全局的 afterEach 钩子。 11、触发 DOM 更新。 12、用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 Vuex 什么是vuex？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理器，采用 集中式存储 管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 vuex的核心对象？ state - Vuex store实例的根状态对象，用于定义共享的状态变量。 Action -动作，向store发出调用通知，执行本地或者远端的某一个操作（可以理解为store的methods） Mutations -修改器，它只用于修改state中定义的状态变量。 getter -读取器，外部程序通过它获取变量的具体值，或者在取值前做一些计算（可以认为是store的计算属性） 实际开发过程中遇到过哪些问题? v-show 的上传文件后页面缓存问题， 使用v-if 解决 因为对父子组件生命周期顺序不了解产生的数据拿不到，和页面视图不更新的问题 1父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 使用vue-router的路由守卫beforeEach和meta字段实现权限控制和伪登录检测， 不再每个页面中单独实现 浏览器无法记录用户历史浏览的位置， 本来是用store记录位置， 后来使用scrollBehavior来做 数据更新而页面却没更新， 响应式没有理解到位， 使用Vue.set()更新数据 style标签不添加scope属性影响其他页面内容， 增加scope属性 页面白屏问题， 在已定义了标签后又在里面写了空的template 首屏加载速度太慢， 采用异步加载机制 watch 属性的监控改变使页面卡死， watch不能修改自身 v-for没有增加key属性导致页面的效率变低 vuex 包含哪些？ state， 包含应用的所有状态, 分别有getters， setters用于获取，设置状态 1var s = this.$store.state.a mutations 更改state的唯一方式， 同步的 1this.$store.commit('mutationName', params) action 提交mutations , 可包含异步操作 1this.$store.dispatch('actionName') vue和react的区别 react是基于virtualDOM的， 一种在内存中描述dom的数据结构。react的数据通常被看作不可变的， 而dom更新则是通过virtual dom的diff算法来计算的。 vue的数据默认是可变的， 通过Object.defineProperty()监控数据， 数据变更会触发dom更新， vue作用于实际dom， 并对真实节点的引用实现双向数据绑定。 使用什么处理ajax？ 什么是fetch？ axios 或 fetch 12fetch(url).then(res =&gt; res.data).then(...)let data = await fetch(url) 什么是骨架屏？ 骨架屏可以理解为是当数据还未加载进来前，页面的一个空白版本，一个简单的关键渲染路径 生成骨架屏的方法： 手写html， css， 维护成本高， 页面改动骨架屏也需要改动 使用base64图片作为骨架屏 借助插件自动生成并插入骨架屏 vue-skeleton-webpack-plugin， page-skeleton-webpack-plugin 什么是ssr， prerendering？ ssr serverside render 服务端渲染 Nuxt.js 框架可以实现服务端渲染 优势： 利于seo， 更快的内容到达时间（无需等待js下载完成） 缺点： 需要借助nodejs server， 服务器资源开销大， 受开发条件限定， 某些异步数据无法ssr。 prerendering 预渲染 webpack插件 prerender-spa-plugin 可以达到预渲染 在构建时(build time)简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点 123456789101112const path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')module.exports = &#123; plugins: [ new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, 'dist'), // Required - Routes to render. routes: [ '/', '/about', '/some/deep/nested/route' ], &#125;) ]&#125; 什么是PWA? Progress Web App, 提升web app的一种新方法, 能给用户原生应用的体验. pwa的特点: 可靠- 即使在不稳定的网络环境下, 也能瞬间加载并展现 体验- 快速响应, 有平滑的动画响应用户操作 粘性- 有沉浸式的用户体验 什么是serviceWorker? 先决条件: 浏览器支持, https 服务工作线程, 服务工作线程是浏览器在后台独立于网页运行的脚本, 包含推送通知, 和 后台同步等, 拦截和处理网络请求, 通过程序来管理缓存中的响应. 它是一种javascript工作线程, 无法访问dom, 服务工作线程通过响应, postMessage 接口来通信. 服务工作线程是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式 它在不用时会被中止，并在下次有需要时重启, 可以访问indexDB API 服务工作线程广泛的使用promise 服务工作线程的生命周期 完全独立于网页 步骤: 注册, 安装, 激活, 实施控制, 终止 使用 1234567if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function () &#123; navigator.serviceWorker.register('/one.js').then(function () &#123; &#125;) &#125;)&#125; 什么是mainifest? web应用程序清单在一个json文件中提供程序的信息, 目的是为了使web应用安装到设备屏幕上. 1&lt;link rel=\"manifest\" href=\"/manifest.json\" /&gt; Manifest.json 12345678910111213141516171819&#123; \"name\": \"HackerWeb\", \"short_name\": \"HackerWeb\", \"start_url\": \".\", \"display\": \"standalone\", \"background_color\": \"#fff\", \"description\": \"A simply readable Hacker News app.\", \"icons\": [&#123; \"src\": \"images/touch/homescreen48.png\", \"sizes\": \"48x48\", \"type\": \"image/png\" &#125;], \"related_applications\": [&#123; \"platform\": \"web\" &#125;, &#123; \"platform\": \"play\", \"url\": \"https://play.google.com/store/apps/details?id=cheeaun.hackerweb\" &#125;]&#125; 什么是 workbox? google提出的web app 静态资源本地存储方案, 该解决方案, 包含一些js库和构建工具.","categories":[],"tags":[]},{"title":"算法学习与协议原理","slug":"algorithm","date":"2018-12-04T03:46:17.628Z","updated":"2018-12-04T03:46:17.629Z","comments":true,"path":"2018/12/04/algorithm/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/algorithm/","excerpt":"","text":"algorithm &amp; protocol此篇讲解了一些算法的js描述， 网络协议的应用原理， 主流框架的实现思路 目录[TOC] 术语算法术语解读 运算类Coprime（互质）互质是公约数只有1的两个整数，叫做互质整数。公约数只有1的两个自然数，叫做互质自然数，后者是前者的特殊情形， 简言之， A与B互质， 则A与B的最大公约数是1. 延伸 c与m互质，写作（c，m）= 1 1不是质数也不是合数 相邻的两个奇数是互质数 两个数较大的数为质数的两个数互质 MOD(取余/模运算)取余运算, 7 mod 3 = 1 同余 n = a (mod 10) ——–&gt; n mod 10 = a mod 10 ——–&gt; n除以10的余数与a除以10的余数等同 POW（次方）Math.pow(2, 3) === 8 协议类httpsHTTPS 就是在 HTTP 下加入了 SSL 层，从而保护了交换数据隐私和完整性，提供对网站服务器身份认证的功能，简单来说它就是安全版的 HTTP 过程 ①服务器把自己的公钥登录至数字证书认证机构。②数字证书机构把自己的私有密钥向服务器的公开密码部署数字签名并颁发公钥证书。③客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名。以确认服务器公钥的真实性。④使用服务器的公开密钥对报文加密后发送。⑤服务器用私有密钥对报文解密。 加密 对称加密 对称加密是指加密与解密的使用同一个密钥的加密算法。 目前常见的加密算法有：DES、AES、IDEA 等 非对称加密 非对称加密使用的是两个密钥，公钥与私钥，我们会使用公钥对网站账号密码等数据进行加密，再用私钥对数据进行解密。这个公钥会发给查看网站的所有人，而私钥是只有网站服务器自己拥有的。 目前常见非对称加密算法：RSA，DSA，DH等 算法类RSA假设A想要通过一个不可靠的媒体接收B的一条私人讯息。她可以用以下的方式来产生一个公钥和一个私钥： 随意选择两个大的质数p和q，p不等于q，计算N=pq。 1N = 3 * 5 = 15 根据欧拉函数，求得 r = (p-1)(q-1) 1r = 2 * 4 = 8 选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质） 12345678e * d = 1 (mod r)e * d = 1 (mod 8)e * d = 8n + 1令 n = 4e = 3d = 11publicKey = (15, 3)privateKey = (15, 11) 将 p 和 q 的记录销毁, (N,e)是公钥，(N,d)是私钥 A将公钥(N,e)传给B，而将私钥(N,d)藏起来 加密数据 原始数据 m = 17， 加密数据 m ^ e = c (mod N) 还原数据 m = c ^ d % N = 52 ^ 43 % 77 = 17","categories":[],"tags":[]},{"title":"nodejs 实用库收录","slug":"node-library","date":"2018-12-04T03:46:17.627Z","updated":"2018-12-04T03:46:17.628Z","comments":true,"path":"2018/12/04/node-library/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/node-library/","excerpt":"","text":"node package librarynodejs 实用仓库收录, 下载/使用方法总结 https://github.com/zexiplus/awesome-nodejs Table of contents[TOC] package.json scripts12345678910&#123; \"scripts\": &#123; \"prebuild\":…., // npm run build 前执行 \"build\":…., \"postbuild\":…. // npm run build 后执行 &#125;, \"bin\": &#123; \"command\": \"./bin/script.js\" &#125;&#125; package structor Folder Use bin 命令行脚本 docs 文档 example 例子 lib 程序的核心功能 test 测试脚本及相关资源 npm script 初始化仓库 1npm init 登录 npm 账号 1npm login 发布包 123npm publish# 发布共有包npm publish --access=public 全局链接 可以让包在机器上全局使用 bin 命令 123sudo npm linksudo npm unlink bin 文件 12#!/usr/bin/env nodeconsole.log('hello world') 自定义参数 自定义参数 – 会把之后的所有参数存入process.argv 12345npm run command -- --someArg npm run -- --test# index.jsprocess.argv.includes('--test') // true 锁定版本 1npm shrinkwrap 设置镜像 1npm config set registry http://registry.npmjs.org node packagespuppeteer Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protoco example.js 12345678910const puppeteer = require('puppeteer');(async () =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://example.com'); await page.screenshot(&#123;path: 'example.png'&#125;); await browser.close();&#125;)(); node example.js moment 时间格式化库 https://github.com/moment/moment 1npm i moment 12345678910//es6 import引入import moment from 'moment' //nodejs 引入var moment = require('moment')//把时间对象格式化为文本 2018-01-09 12:14:27moment(new Date).format('YYYY-MM-DD hh:mm:ss')//把文本解析为date对象 moment('2018-01-09 12:14:27') rollup 整合多个js文件到一个js文件 https://github.com/rollup/rollup#quick-start-guide 1npm i rollup 1234567891011121314const path = require('path')const rollup = require('rollup').rolluprollup(&#123; input: path.resolve(__dirname, '../src/vue.js')&#125;).then((bundle) =&gt; &#123; bundle.write(&#123; file: path.resolve(__dirname, '../dist/vue.js'), format: 'umd', name: 'Vue' &#125;)&#125;).catch((e) =&gt; &#123; console.error(e)&#125;) busboy 文件上传 https://github.com/mscdex/busboy 1npm i busboy 123456789101112131415161718const Busboy = require('busboy')const http = require('http')http.createServer((req, res) =&gt; &#123; var busboy = new Busboy(&#123; headers: req.headers &#125;); busboy.on('file', function(fieldname, file, filename, encoding, mimetype) &#123; var saveTo = path.join(os.tmpDir(), path.basename(fieldname)); file.pipe(fs.createWriteStream(saveTo)); &#125;); busboy.on('finish', function() &#123; res.writeHead(200, &#123; 'Connection': 'close' &#125;); res.end(\"That's all folks!\"); &#125;); return req.pipe(busboy); &#125; res.writeHead(404); res.end();&#125;).listen(3000) opn 预览文件插件 浏览器/图片 https://github.com/sindresorhus/opn 1npm i opn 12345678var opn = require('opn') open('http://localhost:8080')opn('unicorn.png').then(() =&gt; &#123; // 预览图片&#125;);opn('http://sindresorhus.com', &#123;app: 'firefox'&#125;); supervisor 检测node.js代码变化， 自动重启脚本 https://github.com/petruisfan/node-supervisor 12345# download$ sudo npm i -g supervisor# use supervisor test.js mocha 用于node测试代码 https://mochajs.org/ 12345# download$ sudo npm i -g mocha# usemocha test.js test.js 12345678var assert = require('assert');describe('Array', function() &#123; describe('#indexOf()', function() &#123; it('should return -1 when the value is not present', function() &#123; assert.equal([1,2,3].indexOf(4), -1); &#125;); &#125;);&#125;); should.js BDD 风格（behavior driven development) 测试库，是assert模块的扩展 https://github.com/shouldjs/should.js 1npm i should -D 1234567891011121314151617181920212223var should = require('should')var user = &#123; name: 'tj' , pets: ['tobi', 'loki', 'jane', 'bandit']&#125;;user.should.have.property('name', 'tj');user.should.have.property('pets').with.lengthOf(4);// If the object was created with Object.create(null)// then it doesn't inherit `Object.prototype`, so it will not have `.should` getter// so you can do:should(user).have.property('name', 'tj');// also you can test in that way for null'sshould(null).not.be.ok();someAsyncTask(foo, function(err, result)&#123; should.not.exist(err); should.exist(result); result.bar.should.equal(foo);&#125;); uglifyjs 压缩混淆代码工具 node-notifier 跨平台的系统通知插件 https://github.com/mikaelbr/node-notifier 1npm install node-notifier 123456const notifier = require('node-notifier')notifier.notify('message')notifier.nogiry(&#123; title: 'My title', message: 'hello world'&#125;) ora 界面友好的交互式输出工具 spinner https://github.com/sindresorhus/ora 1234567npm i oraconst spinner = ora('Loading unicorns').start();setTimeout(() =&gt; &#123; spinner.color = 'yellow'; spinner.text = 'Loading rainbows';&#125;, 1000); ansi.js 彩色化命令行 文字, 前景色, 背景色 https://github.com/TooTallNate/ansi.js 1npm install ansi 1234567891011const ansi = require('ansi'), cursor = ansi(process.stdout)// You can chain your calls forever:cursor .red() // Set font color to red .bg.grey() // Set background color to grey .write('Hello World!') // Write 'Hello World!' to stdout .bg.reset() // Reset the bgcolor before writing the trailing \\n,// to avoid Terminal glitches .write('\\n') // And a final \\n to wrap things up chalk 彩色化输出 https://github.com/chalk/chalk 1npm i chalk 12345678const chalk = require('chalk')console.log(chalk.red('hello'))// 自定义const error = chalk.bold.redconst info = chalk.keyword('origin')console.log(error('error occured'))console.log(info('be careful origin')) commander.js 创建命令行工具的库 https://github.com/tj/commander.js 1npm install commander --save 基本用法 12345678910111213141516#!/usr/bin/env nodeconst programe = require('commander')programe.version(require('../package.json').version)programe .command('init [env]') // 命令名称 .alias('i') // 简称 .description('init a project') // 描述 .option('-s --setup_mode [mode]', 'which setup mode to use') .action((env, options) =&gt; &#123; // 执行命令的回调函数 let mode = options.setup_mode env = env || 'dev' &#125;)programe.parse(process.argv) API version 版本 1programe.version('1.2.3', '-v --version') 123programe --versionprograme -v# returns 1.2.3 option 选项 与参数不同的是 option 不区分顺序 12345programe .option('-p --peppers', 'Add peppers') .parse(process.argv)console.log(programe.peppers) // true 12programe -p# true command 命令 12345678programe .command('list &lt;num&gt;') .action((num) =&gt; &#123; conosle.log(num) &#125;)/** 一定要加这一句传递参数 **/programe.parse(process.argv) 12programe list 10# log 10 命令必选参数 \\ 1234567programe .command('rm &lt;dir&gt;') .option('-r --recursive') .action((dir, cmd) =&gt; &#123; console.log(dir) console.log(cmd.recursive) &#125;) 123programe rm /bin# /bin# false 命令可选参数 [param] 12345678programe .command('rm &lt;dir&gt; [otherdirs...]') .action((dir, otherdirs) =&gt; &#123; console.log(dir) if (otherdirs) &#123; othersdirs.forEach((item) =&gt; &#123; console.log(item) &#125;) &#125; &#125;) arguments 声明参数 12345programe .arguments('&lt;dir&gt; [env]') .action((dir, env) =&gt; &#123; &#125;) 正则参数 12345programe .option('-s --size &lt;size&gt;', 'dick size', /^(large|medium|small)$/i, 'medium') .action(cmd =&gt; &#123; console.log(`dick size is $&#123;cmd.size&#125;`) &#125;) 12programe -s 18# log medium usage 使用提示 1programe.usage('command [option] &lt;param&gt;') 12programe# returns Usage: programe command [option] &lt;param&gt; 参数列表 1programe 生成命令 package.json 123\"bin\": &#123; \"runname\": \"./bin/script.js\"&#125; 1sudo npm link chromix-too, chromix 控制浏览器刷新, 关闭, 重启, 不支持windows系统 npm https://www.npmjs.com/package/chromix-too chrome插件 chromix-too 1234567891011121314151617181920212223# 下载npm i -g chromix-too# 启动服务chromix-too-server# 查看浏览器列表chromix-too ls# 输出如下17 https://blog.zfanw.com/webpack-tutorial/ webpack 4 教程373 https://www.npmjs.com/package/chromix-too chromix-too - npm# focus a tabchromix focus https://blog.zfanw.com/webpack-tutorial# 刷新某页面chromix reload https://blog.zfanw.com/webpack-tutorial# 打开新的页面chromix open https://blog.zfanw.com/webpack-tutorial# 通过id 关闭页面chromix rm 17 12// module useconst chromix = require('chromix-too')().chromix shields git repository 图标生成工具 https://github.com/badges/shields 12npm install -g gh-badgesbadge build passed :green .png &gt; mybadge.png Inquirer.js 命令行用户交互界面库 https://github.com/sboudrias/Inquirer.js 1npm i inquirer 单个询问 1234567891011const inquirer = require('inquirer')let prompt = inquirer.createPromptModule()let options = &#123; type: 'list | rawlist | expand | checkbox | confirm | input | password | editor', name: 'question name', choices: ['1', '2', '3 hello']&#125;prompt(options).then(cb) 多个询问 12345678910const inquirer = require('inquirer')inquirer .prompt([ option1, option2, option3, ]) .then(anwser =&gt; &#123; &#125;) prerender.io 服务端渲染 https://prerender.io/ js-cookie 操作cookie https://github.com/js-cookie/js-cookie Install 1npm i js-cookie usage 1Cookies.set('name', 'value', &#123; expires: 7 &#125;) // 七天过期时间 http-server http静态服务器 https://github.com/indexzero/http-server install 1npm i -g http-server usage 123456789http-server [path] [optionis]# demo# 指定8080端口http-server -p 8080# 指定ip地址http-server -a 0.0.0.0 hexo博客搭建生成器 https://github.com/hexojs/hexo install 1npm install hexo-cli -g usage 12345hexo init blogcd blog# 启动静态页面服务器hexo server highlightjs页面语法高亮插件 https://github.com/highlightjs/highlight.js import 123&lt;link rel=\"stylesheet\" href=\"/path/to/styles/default.css\"&gt;&lt;script src=\"/path/to/highlight.pack.js\"&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; usage 1&lt;pre&gt;&lt;code class=\"html\"&gt;...&lt;/code&gt;&lt;/pre&gt;","categories":[],"tags":[]},{"title":"","slug":"vue-code-learn","date":"2018-12-04T03:46:17.614Z","updated":"2018-12-04T03:46:17.614Z","comments":true,"path":"2018/12/04/vue-code-learn/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/vue-code-learn/","excerpt":"","text":"vue源码解读学习笔记学习vue源码解读课程的一些笔记 目录[TOC] vue项目准备类型检查vue使用flow做静态类型检查, 包括 类型推断 12345/*@flow*/function add(x: number, y: number): number &#123; return x + y&#125;add('123', 123) 类型注释 构建 Runtime only 在构建时编译, 也叫离线编译,通过webpack,vue-loader等工具编译出能直接使用的js代码. 编译比较耗费性能, 推荐使用构建时编译, 在使用render函数时可使用此选项, 例如 12345new Vue(&#123; render(h) &#123; return h('div', this.data) &#125;&#125;) runtime + complier 运行时编译, 使用包含构建功能的vuejs, 在使用template时需要使用运行时编译选项, 例如: 123new Vue(&#123; template: '&lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;'&#125;) 数据驱动vue init 初始化 new Vue(options) 发生了什么? 对options进行合并 执行了一系例初始化方法, initLifecycle, initEvents, initRender, initState等 将data代理到this对象上(proxy) 对数据进行响应式处理 mount挂载 调试技巧 在vue.esm.js中_init方法增加debugger, 查看vue初始化时的变量 vue mount 挂载问答什么是AST？AST（abstruct syntax tree）抽象语法树， 是源代码的抽象结构的树状表现。 Vue在mount过程中， template会被编译为AST，经过generate（AST转化为render函数）得到render， render函数返回Vnode， Vnode是Vue的虚拟dom节点， 保存着标签名， 子节点， 属性， 文本信息等 章节2-1 数据驱动vuejs核心思想之一就是数据驱动. 是指视图是由数据驱动, 对视图的修改不会直接操作dom, 而是修改数据. 1&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 2-2 new Vue发生了什么 调试vue, 可以在项目的node_modules/vue/dist/vue.esm.js, 中Vue.prototype._init里增加debugger 发生了什么? Vue.prototype._init —&gt; initState–&gt; initData &amp;&amp; observe —&gt; proxy proxy: 把data代理到vm对象上 observe : 数据监察 2-3 vue实例挂载实现 $mount vue会把template, 或空template, 或用户手写render函数最终都转化为render函数运行输出 2-4 render render生成一个Vnode 12345678910111213new Vue(&#123; el: '#app', render(createElement) &#123; return createElement('div', &#123; attrs: &#123; id: 'app1' &#125; &#125;, this.message) &#125;, data() &#123; message: 'hello, world' &#125;&#125;) 2-5 virtual DOM virtual dom指的是用一个原生的javascript描述dom节点 vue使用snabbdom开源库改造实现virtual dom 2-6 createElement Vue 使用createElemtent 生成 Vnode 2-7 update _update 是vue实例的私有方法, 它调用的时机有两个, 一个是首次渲染, 一个是数据更新的时候. _update的作用是把VNode渲染成真实的DOM, 它定义在src/core/instance/lifesycle.js中:","categories":[],"tags":[]},{"title":"rollup 构建工具总结","slug":"rollup","date":"2018-12-04T03:46:17.612Z","updated":"2018-12-04T03:46:17.612Z","comments":true,"path":"2018/12/04/rollup/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/rollup/","excerpt":"","text":"Rolluprollup知识点记录 Table of Content[TOC] Command命令 使用命令行参数打包, -o 指定输出文件名,-f 输出文件格式 1rollup src/main.js -o bundle.js -f cjs 命令行使用配置文件打包 12345# 默认使用 rollup.config.js 作为配置文件rollup -c# 指定配置文件rollup --config rollup.config.dev.js 参数 文件格式 -f amd – AMD规范模块，suitable for RequireJS cjs – CommonJS, suitable for Node and Browserify/Webpack esm – ES6/7 module file iife – 浏览器使用文件 suitable for &lt;script&gt; umd – 通用模块 works as amd, cjs and iife 都可以使用 system – Native format of the SystemJS loader config files 单文件打包配置 1234567module.exports = &#123; input: 'src/main.js', output: &#123; file: 'bundle.js', format: 'cjs' &#125;&#125;; 多文件打包配置 12345678910111213141516171819export default [&#123; input: 'main-a.js', output: &#123; file: 'dist/bundle-a.js', format: 'cjs' &#125;&#125;, &#123; input: 'main-b.js', output: [ &#123; file: 'dist/bundle-b1.js', format: 'cjs' &#125;, &#123; file: 'dist/bundle-b2.js', format: 'esm' &#125; ]&#125;]; 使用插件 123456789import json from 'rollup-plugin-json'export default &#123; input: 'main.js', output: &#123; file: 'dist/bundle.js', format: 'cjs' &#125;, plugins: [json()]&#125; API rollup 生成bundle 12345const inputOptions = &#123; input: 'src/main.js', plugins: []&#125;const bundle = await rollup.rollup(inputOptions) generate 生成结果对象 12345const outputOptions = &#123; file: 'dist/output.js', format: 'umd'&#125;const &#123; code, map &#125; = await bundle.generate(outputOptions) write 把生成结果写入硬盘 1await bundle.write(outputOptions) watch 检测文件变化并打包 12const watchOptions = &#123;&#125;const watcher = PluginsRollup pluginsrollup-plugin-babel转译ES6/7代码至 ES5 12345678const babel = require('rollup-plugin-babel')const options = &#123; entry: 'main.js', ... plugins: [babel(&#123; exclude: 'node_modules/**' &#125;)]&#125; .babelrc 最终确定转译ES6至ES5需要再src文件夹下有一个.babelrc配置文件 12345678&#123; \"presets\": [ [\"env\", &#123; \"modules\": false &#125;] ], \"plugins\": [\"external-helpers\"]&#125; rollup-plugin-node-resolve, rollup-plugin-commonjs处理nodepackages中的 Commonjs模块 12345678import resolve from 'rollup-plugin-node-resolve';import commonjs from 'rollup-plugin-commonjs';const options = &#123; plugins: [ resolve(), commonjs() ]&#125; Other pluginsbannerjs banner.onebanner() 单行信息注释 banner.multibanner() 多行信息注释 在生成的文件中插入作者信息， 版本版权等注释信息 1234567const banner = require('bannerjs')const bundle = await rollup.rollup(options)const umd = bundle.generate(&#123; format: 'umd', name: 'output', banner: banner.multibanner()&#125;)","categories":[],"tags":[]},{"title":"插件收录","slug":"plugins","date":"2018-12-04T03:46:17.611Z","updated":"2018-12-04T03:46:17.611Z","comments":true,"path":"2018/12/04/plugins/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/plugins/","excerpt":"","text":"Plugins收集了各种开发工具, 浏览器, 系统插件, 提高生产效率 Vscode Live-server 自动刷新浏览器的插件","categories":[],"tags":[]},{"title":"常用js技巧片段","slug":"js-tips","date":"2018-12-04T03:46:17.610Z","updated":"2018-12-04T03:46:17.610Z","comments":true,"path":"2018/12/04/js-tips/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/js-tips/","excerpt":"","text":"JS-TIPS 解析字符串为表达式的方法 eval(“” + expr + “”) new Function() 12let fn = new Function('item', 'return item + 1')fn(5)","categories":[],"tags":[]},{"title":"nodejs tips总结","slug":"node-tips","date":"2018-12-04T03:46:17.610Z","updated":"2018-12-04T03:46:17.610Z","comments":true,"path":"2018/12/04/node-tips/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/node-tips/","excerpt":"","text":"Node Tipsnode 常用语句记录 File Operator 给定文件路径dest, 判断文件夹是否存在 12const dest = 'dist/index.js'fs.existsSync(path.dirname(dest)) 给定路径dest， 创建文件夹 1fs.mkdirSync(path.dirname(dest)) 返回已A为基准的B的相对路径 123const A = '/data/orandea/test/aaa'const B = '/data/orandea/impl/bbb'path.relative(A, B) // return '../../impl/bbb'","categories":[],"tags":[]},{"title":"面试实战总结","slug":"interview-in-actural","date":"2018-12-04T03:46:17.609Z","updated":"2018-12-04T03:46:17.609Z","comments":true,"path":"2018/12/04/interview-in-actural/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/interview-in-actural/","excerpt":"","text":"实战面试记录实际前端面试过程中遇到的问题 2018.10.13 （14×13 get） 浏览器小于12px像素字体显示 1234span &#123; font-size: 12px; transform: scale(0.8)&#125; html doctype的意义 (标准模式和兼容模式) 标准模式的排版和js以浏览器支持的最高标准运行, 兼容模式浏览器以向后兼容的方式模拟老旧浏览器的行为防止站点无法工作 实现ie6, 7 , 8不同字体颜色 12345span &#123; color: #ccc\\9; /*ie 6,7,8 */ +color: #000; /* ie 6,7 only */ _color: #777; /* ie6 only */&#125; Webpack是什么 webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源 Webpack热刷新原理 使用webpack-hot-middleware插件, 使用SSE(server sent events)服务器事件 123456789101112131415161718192021// clientvar listener = new EventSource('/message')listener.onmessage = function (e) &#123; console.log(e.data)&#125;// serverhttp.createServer(function (req, res) &#123; if (req.url == '/message') &#123; res.writeHead(200, &#123; 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' &#125;) var i = 0 setInterval(function() &#123; i ++ res.write('update') &#125;, 1000) &#125;&#125;).listen(3000) css 实现等边三角形(原理：利用两个正方形旋转底边) 123456789101112131415161718.box &#123; border-bottom: 1px solid #fff; width: 100px; height: 100px; position: relative;&#125;.box:after, box:before &#123; position: absolute;&#125;.box:before &#123; transform: rotate(30deg); transform-origin: left bottom;&#125;.box:after &#123; transform: rotate(60deg); transform-origin: right bottom;&#125; react组件的生命周期 实例化(渲染期) getDefaultProps getInitialState (此时可以访问this.props) componentWillMount render componentDidMount 存在期 componentWillReceiveProps shouldComponentUpdate (首次渲染不会调用) componentWillUpdate componentDidUpdate 销毁&amp;清理期 componentWillUnmount 什么是受控组件和非受控组件？ 2018.10.17 防止JS对象被修改 不可扩展对象Object.preventExtensions(obj) [不能添加新成员] 密封对象 Object.seal(obj) [不能删除, 但属性可修改] 冻结对象 Object.freeze(obj) [不能删不能增不能改] 设置属性 Object.defineProperty, Object.defineProperties 123456Object.defineProperty(obj, 'name', &#123; configurable: boolean, // 是否可删除 enumerable: boolean, // 是否可枚举 writable: boolean, // 是否可修改 value: val // 属性值&#125;) CSS选择符有哪些？哪些属性可以继承？ 可继承 字体, 颜色, 字大小, 缩进 前端存储方式有哪些？ Cookie, localStorage, sessionStorage, indexDB 什么是面向对象？面向对象有哪些基本特征？ 面向对象是一种思想. 面向对象是指, 把复杂过程封装在对象中,细节交给对象实现, 只暴露出简单的接口,让对象去实现具体的细节. 这种思想将数据作为第一位, 方法其次, 这是对数据的优化, 简化了过程. 通过继承机制, 实现对象之间的属性,方法共用. 封装性: 隐藏具体细节, 隔离变化, 仅提供外部访问的接口 继承性: 子类继承父类的一些方法, 可以提高代码复用性 多态性: 同一方法可以在子类和父类有不同实现 千位符 1234567891011121314151617181920function format(num)&#123; if(!num) return var numString = num.toString() var trailIndex = numString.indexOf('.') var headString if (trailIndex &gt;= 0) &#123; var trail = numString.slice(trailIndex) headString = numString.slice(0, trailIndex) return numString.replace(/(\\d&#123;3&#125;\\B)/g, function($1) &#123; return $1 + ',' &#125;).concat(trail) &#125; else &#123; headString = numString return numString.replace(/(\\d&#123;3&#125;\\B)/g, function($1) &#123; return $1 + ',' &#125;) &#125;&#125;console.log(format(1231423423.22)) //1,231,423,423.22 快排算法 12345678910111213141516171819202122var quicksort = function (arr) &#123; // 递归函数, 终止情况为数组的长度为1 if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); // 选取一半位置为基准点 var pivot = arr.splice(pivotIndex, 1)[0]; // 挑选出基准值 var left = []; var right = []; // 建立左右两个数组, 左边存放小于基准的数值, 右边存放大于基准的数值 for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; // 调用自身并进行连接 返回排序后的数组 return quicksort(left).concat([pivot], quicksort(right));&#125;;var array = [8, 7, 0, 7, 5, 2, 5, 3, 1];quicksort(array); // [0,1,2,3,5,5,7,7,8] 链表与数组的区别 数组是在内存中连续存放的 插入存储效率低 查找效率高 不利于扩展, 数组定义的空间不够要重新定义数组 链表在内存中存放不是连续的 每一个数据都保存着下一个数据的地址 插入增加数据效率高 查找数据效率低 不指定大小, 扩容方便 性能优化 合并文件 , 使用 css精灵图以 减少http请求 使用合适的缓存策略 响应头增加 expire, max-age字段 增加E-tag 选择适当的图片格式, 压缩图片质量 使用cdn 选择合理的 web component更新方式和周期 压缩组件, js,css 减少重定向 不要使用css表达式 减少dns查询次数 合理使用预加载和懒加载 进程间通信(ipc)方式有哪些 匿名管道(pipe) 半双工, 数据单向流动, 只能在亲缘(父子)进程间使用 具名管道(named pipe) 允许非亲缘管道间使用 高级管道(popen) 将另一个进程在当前程序中启动 消息队列(message queue) 消息队列是存放消息的链表, 克服了管道只能传递无格式字节流, 和缓冲区大小受限的情况 信号(sinal) 共享内存通信(shared memory) 由一个进程创建, 多个进程共享的内存, 是最快的进程间通讯方式 套接字(socket) 可用于不同主机之间通讯 步骤 命名, 绑定, 监听, 连接, 发送信息, 解绑 10.18 （12 × 14 get） 简单与复杂请求 简单请求: 两者必须都满足 仅包含GET, HEAD or POST(如果是post, content-type必须是 application/x-www-form-urlencoded, multipart/form-data, or text/plain 其中一种) 没设置自定义头信息的请求 复杂请求 不满足简单请求的请求类型 获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。 用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。 http2 首部压缩 如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表” 共享同一个tcp连接 “资源合并减少请求”的优化手段对于HTTP2.0来说是没有效果的，只会增大无用的工作量而已 http1一个域名限制打开6个tcp连接， 所以使用cdn1， cdn2 ， cdn3 …分发不同资源， http2不需要 并行双向字节流的请求和回应 同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收者服务器的响应，而服务器那端同理 请求分有优先级 每个HTTP2.0流里面有个优先值，这个优先值确定着客户端和服务器处理不同的流采取不同的优先级策略，高优先级的流都应该优先发送，但又不会绝对的 服务端推送 除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求 下次请求时直接从缓存中读取 diff算法 xss, csrf防范 cookie设置 10.19 讲讲对mvvm模式的理解 model（模型层）， view（视图层）， viewmodel（展示模型) 展示模型将模型层中的数据与复杂的业务逻辑封装成属性与简单的数据暴露给视图，让视图和展示模型中的属性进行同步, 同时用户改变视图, 视图通过视图模型, 修改数据同步至模型上. 讲讲 vue store 讲讲至今遇到的最大困难 what，how，why, done，right，better 说一下Event loop Event Loop是一个程序结构，用于等待和发送消息和事件. 简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”） Node采用的是单线程的处理机制(所有的I/O请求都采用非阻塞的工作方式)，至少从Node.js开发者的角度是这样的。而在底层，Node.js借助libuv来作为抽象封装层，从而屏蔽不同操作系统的差异，Node可以借助livuv来实现线程。 Libuv库负责将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎。 每一个I/O都需要一个回调函数——一旦执行完便堆到事件循环上用于执行 vue-router 的 跳转实现原理 我们都知道，单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面;vue-rouetr在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。 那为什么这两种方式能够实现试图更新不跳转，其原因在于： Hash模式：​ hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，使用”后退”按钮，就可以回到上一个位置； 1 $router.push() //显式调用方法 2 HashHistory.push() //（window.location.hash= XXX） 3 History.transitionTo() //开始更新 4 History.updateRoute() //更新路由 5 {app._route= route} 6 vm.render() //更新视图 7监听hash变化(window.onhashchange) History模式：​ HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面； history.replaceState 仅仅替换浏览器的地址栏, 并不发出请求, 退后按钮无作用 history.replaceState(null, null, &#39;hello&#39;); history.pushState 1history.pushState([data], [title], [url]); 点击浏览器的后退按钮，你会发现它和你预想的效果一样。因为pushState方法将我们传给它的URL添加到浏览器的history中，从而改变了浏览器的history,在HTML5History的构造函数中监听popState（window.onpopstate） 10.20 最近在研究哪些技术,仓库? rx.js tars.js nuxt.js serviceWorker 10.30 自我介绍 https://www.zhihu.com/question/21387153/answer/264462043 我最突出的技能是什么 我在哪方面的知识掌握是最全面的 我性格上最大的优势是什么 我最擅长的事情是什么 我有哪些成就和贡献 ​ 我是施泽西,河南郑州人, 今年24岁, 毕业于中南林业科技大学2017届本科, 至今有一年半的工作经验. 毕业后在深圳市茁壮网络股份有限公司就职, 担任web前端开发工程师一职, . ​ 我负责的工作主要是pc端页面的构建, 维护和开发. 当然也曾开发过一些手机端和电视端的页面. 在我就职期间我参与开发过pc端运营数据大数据可视化系统, 党员建设管理系统, 独立负责智慧教育后台管系统, 路由器设置系统. 还有公司内部homed后台管理系统的维护.除了公司的业务, 自己也喜欢做一些比较有趣的开源项目, ​ 2.因为所在公司技术选型的原因, 我最擅长的技术栈是 vue + elementUi + webpack, 除此之外也钻研和使用react作为主要使用和学习的技术框架.我认为自己有一定js语言基础, 注重实践, 善于实现复杂的业务逻辑和用户交互可与优化应用性能, 我专注于研究javascript的运行机制, css 的复杂表现, html的语意化. ​ 3.再说说我的性格, 我认为自己是一个积极进取的人, 对自身自律. 喜欢在一定的时间内钻研一件事情. 对互联网技术有着浓厚的兴趣. 我还有一个特质就是不服输, 不怕失败. 我喜欢在失败中分析失败的原因, 避免下次失败. 我在工作生活中也是这样, 如果一件事情让我犹豫不决, 我会去尝试, 哪怕失败. 再来一遍很多情况下就会有好的结果. ​ 4.我最擅长做有挑战性的事情, 无论是时间上还是技术上的挑战. 我善于在闲暇之余分析项目, 找出此项目存在的问题, 还有哪些需要改善, 哪些比较浪费时间和精力去管理, 然后去做优化. 我乐于用自己所学的知识运用在实际的项目上, ​ 5.最后说说我的贡献, 我能高效准时的完成开发任务, 在极端情况下无法按时完成任务, 也会去和leader沟通, 实时汇报工作进度.也乐于帮助同事去分析一些bug.这些是我在工作中的主要贡献. 闭包的使用场景 缓存数据, 事件处理函数缓存数据 1button.onclick = (function(num) &#123; return function () &#123;console.log(num ++&#125;)(1) 面向对象编程对象的私有方法创建 http 和 https的区别是什么, 用到了哪些算法, 是怎样实现的? https在http上增加了ssl/tls层协议， 使得信息传输不再是明文， 更安全。 ssl层加密技术分为对称加密，和非对称加密， 常用的非对称加密有RSA算法， RSA算法采用分解大质数原理 服务器会提供公钥和证书给客户端， 公钥用于客户端加密， 证书解决了公钥防伪造认证问题。 此外， http默认端口 80， https默认端口 443 用js实现一个散列类 margin: 5px 20px 30px; 上下左右的margin分别是多少? 上5px， 左右20px， 下30px js的简单类型和复杂类型存储在哪些地方， 有什么区别？ 复杂类型存放在堆区， 存放比较快， 但查找较慢， 变量赋值复制的是内存地址（索引） 简单类型存储在栈区， 存放慢， 查找快， 变量赋值复制的是值为非索引 11.11 为什么使用hightChart.js , 它使用的svg对比canvas有什么优势 hightChart.js采用svg， svg 是基于xml的， 部分采用 canvas保证了良好的兼容性， 可在不支持svg的浏览器上使用canvas保证向下兼容 因为svg基于xml， 操作xml也是操作dom， 一些事件绑定可以实现， 也可以自定义操作dom vue是怎么实现v-model双向数据绑定的, diff算法的实现原理 http://toutiao.com 往 http://mp.toutiao.com发送一个ajax请求，请问跨域了么？mp.toutiao.com 的服务器可以收到是怎样的请求？解决跨域的方法 跨域了, 跨域的要求是: 协议, 端口, 域名中有一项不同都属于跨域, 子域名和父域名也属于域名不同 服务器会收到跨域的ajax请求(cors), 如果是简单请求会直接收到请求, 如果是复杂请求, 浏览器会先发送请求预检(options). 服务器会对比请求头的origin字段与响应头设置的access-control-allow-origin对比, 如果通过检验, 则发送cors响应 解决办法, 服务端的响应头增加access-control-allow-origin 包含请求的域 Promise的 all方法和race方法 Promise.all Promise.all, 接受一个数组作为参数, 其中p1, p2, p3 都是promise实例, 如果不是, 会分别调用Pmoise.resolve 方法转化为promise, p的状态受p1, p2, p3决定 若p1, p2, p3都变为fulfilled时, p才变为fulfilled, 此时p1, p2, p3返回值组成一个数组, 传递给p的callback 若p1, p2, p3其中一个变为rejected状态, p就转变为rejected, 此时第一个被reject实例的返回值, 会被传递给p的callback 1const p = Promise.all([p1, p2, p3]) Promise.race Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调Promise.resolve方法，将参数转为 Promise 实例，再进一步处理. 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数 1const p = Promise.race([p1, p2, p3]) HTTP缓存介绍？ 强缓存 协商缓存 实现一个长宽比为4：3的div 使用子元素margin撑开父元 , margin是以父元素的宽度计算的 1234567.container &#123; width: 200px;&#125;.container:after &#123; content: ''; margin-top: 75%;&#125; 利用自身padding, padding是用自身宽度计算的 1234.container &#123; width: 200px; padding-bottom: 75%;&#125; 算法求：数组A，取M个数，和为N 例如: A 2000个数的数组 , M 50, N 1000 最近关注的新技术 服务端： egg.js, ssr(nuxt.js) 移动端： weex， 小程序， react-native, PWA(渐进式web应用于离线应用)， android快应用 其他 electron， rx.js","categories":[],"tags":[]},{"title":"CSS","slug":"css","date":"2018-12-04T03:46:17.608Z","updated":"2018-12-04T03:46:17.608Z","comments":true,"path":"2018/12/04/css/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/css/","excerpt":"","text":"cssLearn css and make pages pretty Table of contents[TOC] Design principle 移动优先原则，及默认的css样式为移动样式，然后通过媒体查询 用 桌面样式覆盖 整体字体在 14px 到 20px 之间 保持适当行距（1.5倍） 段落采用缩进或隔行，不能两者同时用，首段不用隔行或缩进 Font-face 定义字体 123456789101112131415161718192021222324@font-face &#123; font-family: 'myfont'; /* 自定义名 */ src: url('myfont.woff') format('woff') /* 路径，格式 */&#125;@font-face &#123; font-family: 'Roboto'; src: url('Roboto-Light-webfont.woff') format('woff'); font-style: normal; font-weight: 300;&#125;@font-face &#123; font-family: 'Roboto'; src: url('Roboto-LightItalic-webfont.woff') format('woff'); font-style: italic; font-weight: 300;&#125;@font-face &#123; font-family: 'Roboto'; src: url('Roboto-Bold-webfont.woff') format('woff'); font-style: normal; font-weight: 700;&#125; 使用字体 123.line &#123; font-family: 'Robot';&#125; Responsive img 根据不同dpi显示不同图片srcset 123&lt;img src=\"images/standard.png\" srcset=\"images/standard.png 1x, images/standard-big.png 2x\" style=\"width: 100%\"/&gt; 根据不同像素宽度设置不同图片 123&lt;img src=\"images/photo-small.jpg\" srcset=\"images/photo-big.jpg 2000w, images/photo-small.jpg 1000w\" sizes=\"(min-width: 960px) 960px, 100vw\"/&gt; 媒体查询 1234567&lt;picture&gt; &lt;source media='(min-width: 401px)' srcset='images/photo-big.jpg'/&gt; &lt;source media='(max-width: 400px)' srcset='images/photo-tall.jpg'/&gt; &lt;img src='images/photo-small.jpg'/&gt;&lt;/picture&gt; Css Selector 后兄弟节点选择器(选取h1后紧邻的p元素) 123h1 + p &#123; color: green;&#125; 毗邻~(选取h1后相邻的所有p元素) 123h1 ~ p &#123; color: red;&#125; 属性选择器 1234/*选择类名已foundicon 开头的元素*/[class*=\"foundicon-\"] &#123; &#125; 起始/结束类型选择器 12345678/* 选择.container 的第一个p元素 */.container p:first-of-type &#123; &#125;/* 选择.container 的最后一个p元素 */.container p:last-of-type &#123; &#125; 伪类选择器 123input:focus &#123; border: 2px solid #fff;&#125; 父元素选择器(草案) 123!li &gt; p &#123; border: 1px solid #fff;&#125; BFC (block formating context)123456789/* 创建bfc float: 值不为none; position: 值不为static或relative; overflow: 值不为visible; display: 值为 table-cell, table-caption, inline-block, flex, inline-flex*//* 最常用方法 */overflow: hidden; BFC的应用 解决margin重叠（为每个带有margin的块包裹一个新的bfc） 解决浮动元素无法撑开父元素的高度（给包父元素设置为bfc） 解决文字环绕浮动元素（给包含文字的元素设置bfc） Media Queries12345@media only screen and (min-width: 401px) and (max-width: 960px) &#123; #main &#123; ... &#125;&#125; FLOAT layout clear: left; 排除 当前元素之前 float: left;元素对此元素的影响， 但之前元素的float: left仍对自身有效； 如果一个父元素中有浮动元素，若让子元素撑开父元素的高度，方法一：在父元素末尾添加clear: both;的元素。方法二：在父元素增加 overflow: hidden;属性。 FLEX layout demo1 demo2 容器属性 设置容器为flex布局 容器设置为flex后，子元素自动成为容器成员， 子元素的float, clear, vertical-align 都将失效 12345.box &#123; display: flex; display: inline-flex; display: -webkit-flex; /* Safari */&#125; 子元素排列方向 当flex-direction 从 row 变为 column 时，justify-content 的意义变为 align-items 1flex-direction: row | row-reverse | column | column-reverse; 子元素换行规则 nowrap ： 不换行，所有item排列成一排，width ： 100% 被忽略 1flex-wrap: nowrap | wrap | wrap-reverse; 水平对齐规则 justify-content: flex-start | flex-end | center | space-between | space-around; 1justify-content: flex-start | flex-end | center | space-between | space-around; 垂直对齐规则 stretch: flex-item 被纵向拉伸至flex-contanier 一样的高度 1align-items: flex-start | flex-end | center | baseline | stretch; 多轴对其规则 1align-content: flex-start | flex-end | center | space-between | space-around | stretch; 子属性 单位宽度 flex https://segmentfault.com/q/1010000004080910/a-1020000004121373 123flex: initial; /* 原始宽度 */flex: 1; /* 单位宽度（若其他item没设置，则被拉伸填满）*/flex: 2; /* 单位宽度的两倍 */ flex 是 flex-grow、flex-shrink、flex-basis的缩写 1234567891011121314151617.parent &#123; display: flex;&#125;.item1 &#123; width: 140px; flex: 2 1 0%; background: blue;&#125;.item2 &#123; width: 100px; flex: 2 1 auto; background: darkblue;&#125;.item3 &#123; flex: 1 1 200px; background: lightblue;&#125; 父容器宽度 600px， 子元素 宽度 0% + 100px + 200px = 300px ， 剩余宽度 300px， 每个分配n/m的剩余空间， 如item1 增加 2/（2+2+1）× 300 的像素宽度 0% + 120 = 120px， 最后 123item-1 = 0% + 120px = 120pxitem-2 = auto + 120px = 220pxitem-3 = 200px + 60px = 260px ​ 排列顺序 order 1order: &lt;integer&gt;; 放大的倍数 如果存在剩余空间， 放大的倍数 1flex-grow: &lt;number&gt;; /* default 0 */ 缩小 1flex-shrink: &lt;number&gt;; /* default 1 */ 自身对齐(垂直方向) align-self 1align-self: auto | flex-start | flex-end | center | baseline | stretch; 自身对齐（水平方向） margin 12margin-left: auto; /* 右对齐 */margin-right: auto; /* 左对齐 */ others 把元素撑到右侧 1margin-left: auto; /* 会把item撑到右侧 */ 主轴空间 此属性定义了在分配多余空间之前，项目占据的主轴空间（main size） 1flex-basis: &lt;length&gt; | auto; /* default auto */ Grid layout css 栅格布局， IE不支持， chrome 57， ff52， opera44 支持 12 Transition1234/* transition */.trans &#123; transition: all 1s ease-out;&#125; Css-3D demo-cube 123456789101112131415/* 父元素设置之后，其后代元素便会有3d效果 */.container &#123; trnasform-style: preserve-3d; &#125;.container &#123; perspective: 300px; // 景深 perspective-origin: 0px 0px; // 视角起始点&#125;.trans &#123; transform: translate3d(10px, 10px, 10px) | translateX(30px) | translateY(30px) | translateZ(30px); transform: rotateX(90deg) | rotateY(90deg) | rotateZ(90deg); transform: scale3d(1, 1, 1) | scaleX(1.2) | scaleY(1.2) | scaleZ(1.2);&#125; Css-filter 灰度 123.grayscale &#123; filter: grayscale(1) /* 0~1 代表灰度 */&#125; 褐色 123.sepia &#123; filter: sepia(.5)&#125; 饱和度 123.saturate &#123; filter: saturate(5)&#125; 色相旋转 123.hue-rotate &#123; filter: hue-rotate(90deg)&#125; 反色 123.invert &#123; filter: invert(1)&#125; 透明度 123.opacity &#123; filter: opacity(.5)&#125; 亮度 123.brightness &#123; filter: brightness(2)&#125; 对比度 123.contrast &#123; filter: contrast(.4)&#125; 模糊 123.blur &#123; filter: blur(10px)&#125; 阴影 123.drop-shadow &#123; filter: drop-shadow(5px 5px 10px #ccc)&#125; Less &amp; 指代自身 12345p &#123; &amp;:hover &#123; ... &#125;&#125; 定义/使用变量 12345@apple: #fff;span &#123; color: @apple;&#125; Tips 垂直居中 table-cell 1234.container &#123; display: tabble-cell; vertical-align: middle;&#125; transform 123456.container &#123; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%)&#125; flex 12345.container &#123; display: flex; justify-content: center; align-items: center;&#125; 自定义input[type=“checkbox”]样式 123456&lt;section&gt; &lt;div class=\"checkbox-box\"&gt; &lt;input type=\"checkbox\" id=\"one\" value=\"1\" /&gt; &lt;label for=\"one\"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/section&gt; 1234567891011121314151617181920212223242526272829input[type=\"checkbox\"] &#123; visibility: hidden;&#125;.checkbox-box &#123; width: 40px; height: 10px; background: #555; margin: 20px 80px; position: relative; border-radius: 3px;&#125;.checkboxOne label &#123; display: block; width: 16px; height: 16px; border-radius: 50%; transition: all .5s ease; cursor: pointer; position: absolute; top: -3px; left: -3px; background: #ccc;&#125;.checkboxOne input[type=checkbox]:checked + label &#123; left: 27px;&#125; 单行图片和文字垂直居中对齐 vertical-align: middle; 1234&lt;h1&gt; &lt;img src=\"...\" id=\"logo\" style=\"vertical-align: middle;\" /&gt; &lt;span id=\"logo-desc\"&gt;web-title&lt;/span&gt;&lt;/h1&gt; css背景渐变色 12345#grad &#123; background: linear-gradient(red, blue) // 默认从上到下 background: linear-gradient(to right, red, blue) // 从左到右 background: linear-gradient(to bottom right, red, blue) // 从左上到右下&#125; 单行超出显示省略号 12345.line &#123; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125; 多行文本超出显示省略号 1234567.points &#123; display:-webkit-box; -webkit-line-cap:3; -webkit-box-orient: vertical; overflow:hidden; text-overflow:ellipsis;&#125; 单行文字均匀对齐 1text-align-last: justify; 不定宽元素居中 1234.box &#123; display: table; margin: 0 auto;&#125; 只允许在空格处换行 123.line &#123; word-wrap:break-word;&#125; css 实现长宽比例一致div容器 原理：父容器设置一个bfc（overflow：hidden），让子元素能撑开父元素，站位dummy div设置margen-top为100%，把父元素的高度撑到和其宽一样，.content div用来放真正的内容 1234&lt;div class=”container”&gt; &lt;div class=”dummy”&gt;&lt;/div&gt; &lt;div class=”content”&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.container &#123; position:relative; overflow: hidden; border: 1px solid red; &#125;.dummy &#123; margin-top: 100%; /* 指代父容器宽度的 100% 撑开父元素 */&#125;.content &#123; position: absolute; top:0; left:0; right:0; bottom:0;&#125; 计算属性 123.box &#123; width: calc(~\"100% - 40px\");&#125; 滚动条样式 123456789.scroll-bar &#123; 1. ::-weskit-scrollbar 滚动条整体部分 2. ::-webkit-scrollbar-button 滚动条两端的按钮 3. ::-webkit-scrollbar-track 外层轨道 4. ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去） 5. ::-webkit-scrollbar-thumb （滚动条里面可以拖动的那个） 6. ::-webkit-scrollbar-corner 边角 7. ::-webkit-resizer 定义右下角拖动块的样式&#125; 缩放元素 1transform: scale(0.6); :before , :after 伪类 1234.redStar:before &#123; content: '*'; color: red;&#125; 倍数行距 1line-height: 1.3; 背景图片大小自适应元素宽度高度 123img &#123; background-size: 100% 100%;&#125; 控制文字内容用户可选择 123.line &#123; user-select: none | text | all | element;&#125;","categories":[],"tags":[]},{"title":"微信小程序学习总结","slug":"Mini-programe","date":"2018-12-04T03:46:17.607Z","updated":"2018-12-04T03:46:17.607Z","comments":true,"path":"2018/12/04/Mini-programe/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/Mini-programe/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git 操作大全","slug":"Git","date":"2018-12-04T03:46:17.606Z","updated":"2018-12-04T03:46:17.607Z","comments":true,"path":"2018/12/04/Git/","link":"","permalink":"http://zexiplus.github.io/2018/12/04/Git/","excerpt":"","text":"Git git 配置, 命令 Table of contents[TOC] ##git config 新建ssh key 1ssh-keygen -t rsa -C 'zexiplus@outlook.com' 新增远程仓库 1git remote add origin git@github.com:zexiplus/oo.git 显示秘钥 1cat /c/Users/username/.ssh/id_rsa.pub 配置用户名密码 12git config --global user.name 'username'git config --global user.email 'username@tt.com' git command git 常用命令, [中括号内]代表可省略 添加文件修改 1git add . 删除文件夹 1git rm ./foldername -r -f 显示所有仓库列表 1git branch -a 显示所有仓库列表 1git branch -r 显示本地仓库列表 1git branch 新建本地仓库分支 123git branch A# orgit checkout -b A 从远程拉取分支到本地分支(新建) 1git checkout -b R origin/A 为当前仓库设置对应的远程仓库 1git branch --set-upstream-to=origin/master master 切换分支 1git checkout A 切换回上次分支 1git checkout - 删除分支 1git branch -d A 把A分支合并到当前分支并作记录 1git merge -no-off A 修改上一条commit记录 1git commit --amend 图形化查看记录 1git log --graph 回滚到记录 1git reset --hard #hash 查看回滚记录 1git reflog 查看工作区和暂存区差别 1git diff 查看工作区和最新提交的差别 1git diff HEAD 推送至远程仓库 1git push -u [origin master] 从远程仓库拉取到本地仓库并合并到当前分支 123git pull [origin master]# or 强制拉取git pull --allow-unrelated-histories 从远程仓库拉取到本地仓库不自动合并 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 git pull [origin master] # 从远程仓库拉取到本地仓库不自动合并git fetch [origin master] # 比较本地仓库master和拉取到的远程仓库master区别git diff master origin/master # 合并已拉取到的远程仓库git merge origin/master # 备份当前的工作区的内容，从最近的一次提交中读取相关内容(被强行commit可跳过)git stash # 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容git stash pop # 更改仓库地址信息,之后添加git config -e [user] name = shizx email = shizx@balabala.com# 存储提交人信息, 之后不用输入账户密码[credential] helper = store # 把所有文件修改，删除，增加添加到暂存区git add . # 把某个文件从暂存区移除（工作区该文件还存在，会影响之后的本地仓库提交）git rm --cached filePath # 把某个文件中从暂存区移除(本地还存在)git rm -r --cached node_modules# 把所有文件修改，删除，增加添加到暂存区git add . # 把某个文件从暂存区的修改移除git reset filePath # 只恢复某个文件至某个历史版本git checkout $&#123;commit&#125; filePath git 四个阶段的撤销 概念 工作区: 文件在硬盘上的操作记录, git add 之前的状态 暂存区: 文件的暂存操作记录, git add 之后 git commit 之前 本地版本库: 已经提交的文件记录, git commit 之后, git push 之前, 会有对应的hash版本号 远程版本库: 已经推送到远程仓库的文件记录 , git push 之后 查看/撤销工作区文件变更 (只修改了没有git add ) 123456# 查看差别git diffgit checkout . # orgit reset –-hard 查看/撤销暂存区和本地仓库差异（已经git add 没有 git commit） 12345678910# 查看差别git diff –-cached# 还原暂存区(git add 反向操作)git reset# 还原工作区和暂存区git checkout .# orgit reset --hard 查看/撤销本地仓库和远程仓库差异（已提交未推送, git commit后还没有git push） 12345# 查看差异git diff master origin/master# 撤销修改至远程版本库git reset --hard origin/master 已经推送到远程仓库撤回(git push) 123# 恢复至上次提交 并推送重新覆盖git reset --hard HEAD^git push -f","categories":[],"tags":[]},{"title":"系统/软件快捷键和配置定义","slug":"shortCuts","date":"2018-11-19T03:47:16.341Z","updated":"2018-11-19T03:47:16.341Z","comments":true,"path":"2018/11/19/shortCuts/","link":"","permalink":"http://zexiplus.github.io/2018/11/19/shortCuts/","excerpt":"","text":"shortcuts 保存了系统/软件快捷键和配置定义,以便查看使用 ←↑→↓ windows windows系统快捷键说明 快捷键 在当前文件夹下打开cmd窗口 shift + rightMouse mac mac 快捷键说明 快捷键 锁屏 ctrl + command + q 搜索文件 command + 空格 工作区缩略图 Ctrl + Tab 打开App菜单 option + A 打开launchpad option + D 更改文件默认启动软件 鼠标右键 / getinfo / open with 系统截全屏 command + shift + 3 截部分屏幕 command + shift + 4 连接远程文件夹 command+ k 预览图片 选中图片 + space vsCode 插件介绍 https://zhuanlan.zhihu.com/p/27905838 修改编辑器快捷键 code/ 首选项/ 键盘快捷方式 vsCode 快捷键说明 按键 开启命令面板 command + shift + p 转到定义 command + option + ↓ 开启/切换终端面板 ctrl + ` 格式化代码 option + shift + f 把文件夹在 finder 中显示 command + option + R 向上移动行 option + ↓ 预览markdown文件 command + K V 启用调试 F5 启用多行编辑 option + 鼠标选择 在文件夹中查找 command + shift + F 启用quokka command + K Q 停用quokka command + K S 使用markdonw toc 插件生成文档目录 markdown 中右键 , markdown toc insert 使用expand-region 选中括号内内容 command + shift + M 注册code 系统命令 command + shift + P &gt; shell code 在命令行中使用vscode code main.js 插入假数据 命令面板 输入 faker js debug 配置说明 | 参数 | 说明 || ————————– | ——————————————————– || ${workspaceRoot} | VSCode中打开文件夹的路径 || ${workspaceRootFolderName} | (VSCode中打开文件夹的路径, 但不包含”/“ || ${file} | (当前打开的文件 || ${relativeFile} | 当前打开的文件,相对于workspaceRoot || ${fileBasename} | 当前打开文件的文件名, 不含扩展名 || ${fileDirname} | 当前打开文件的目录名 || ${fileExtname} | 当前打开文件的扩展名 || ${cwd} | the task runner’s current working directory on startup() | 配置示例 123456789101112131415161718&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"$&#123;workspaceFolder&#125;/$&#123;relativeFile&#125;\" &#125;, &#123; \"type\": \"chrome\", \"request\": \"launch\", \"name\": \"Launch Chrome against localhost\", \"url\": \"http://localhost:8080\", \"webRoot\": \"$&#123;workspaceFolder&#125;\" &#125; ]&#125; sublime sublime快捷键说明 快捷键 编译执行代码 ctrl + B 复制当前行到下一行 ctrl + shift + d 移动当前行 ctrl + shift + 上下左右箭头 选中花括号里面的全部内容 Ctrl+Shift+M 可快速选中一行中的某一部分 shift + ctrl然后按←或→ chrome chrome 快捷键说明 快捷键 重新打开刚关闭的页面 Shift + Ctrl + T (mac) 打开开发者工具 option + commond + I (mac) 清除系统缓存 command + shift + back (mac) 后退 command + [","categories":[],"tags":[]},{"title":"vue 使用备考指南","slug":"Vue","date":"2018-11-05T14:02:02.946Z","updated":"2018-11-05T14:02:02.946Z","comments":true,"path":"2018/11/05/Vue/","link":"","permalink":"http://zexiplus.github.io/2018/11/05/Vue/","excerpt":"","text":"vuevue 使用,备考指南 目录[TOC] vue 构建命令 初始化项目 12npm listnpm init webpack 开发环境运行 1npm run dev 编译并生成报告 1npm run build --report 工程目录结构 build 文件夹：用于存放 webpack 相关配置和脚本。其中webpack.base.conf.js 用于配置 less、sass等css预编译库 config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 其中index.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。 dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。 static 文件夹, 存放不通过打包的静态资源例如js， 图片等 node_modules：存放npm命令下载的开发环境和生产环境的依赖包。 src: 存放项目源码及需要引用的资源文件。 src下assets：存放项目中需要用到的资源文件，css、js、images等。 src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。 src下emit：自己配置的vue集中式事件管理机制。 src下的 const目录： 存放开发环境下的全局常量 src下的 filter 目录： 存放自定义过滤器 src下router：vue-router vue路由的配置文件。 src下service：自己配置的vue请求后台接口方法。 src下page：存在vue页面组件的文件夹。 src下util：存放vue开发过程中一些公共的.js方法。 src下vuex：存放 vuex 为vue专门开发的状态管理器。 src下app.vue：使用标签&lt;route-view&gt;&lt;/router-view&gt;渲染整个工程的.vue组件。 src下main.js：vue-cli工程的入口文件。 index.html：设置项目的一些meta头信息和提供&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;用于挂载 vue 节点。 package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。 核心问题解读vue 相关知识 vue核心是什么? 双向数据绑定和组件系统 怎么理解vue是一套构建用户界面的渐进式web框架? vue是非侵入式的, 没有多做职责之外的事, vue只提供了双向数据绑定和组件系统, 其他功能由vue插件提供 体现在: 在原有系统上中某个页面使用vue, 也可以从0开发整个项目 vue常见的指令? v-if, v-show, v-model, v-bind, v-for, v-once v-pre 跳过这个元素和其子元素的编译过程, 用于没有使用vue指令的节点, 加速编译过程 vue常见的修饰符? v-on事件常用修饰符 .stop停止冒泡, .prevent阻止默认行为, .capture使用捕获模式, .once只触发一次 .self只在绑定元素上使用 .native 监听组件根元素的原生事件 例如在第三方UI组件上绑定事件不起作用, 则使用此修饰符 1&lt;el-input @keyup.enter.native=\"submit\"&gt;&lt;/el-input&gt; .[keyCode] 只在指定键值码触发 .left, .right, .middle 在鼠标左键, 右键, 中键触发 v-model常用修饰符 .number将输入字符串转化为数字 .trim去掉首位空格 1&lt;input v-model.number=\"age\" /&gt; v-bind常用修饰符 .sync 会扩展成一个更新父组件绑定值的 v-on 侦听器 .prop - 被用于绑定 DOM 属性 1&lt;text-document :title.prop=\"title\" &gt;&lt;/text-document&gt; v-on可以监听多个方法吗? 可以, 但是同一种监听器只能响应一个函数, click只能响应一个 1&lt;button @focus=\"handleFocus\" @click=\"handleFocus1\" @click=\"handleFocus2\"&gt;&lt;/button&gt; key的作用? 用于管理可复用的元素, vue保证高效的渲染元素, 通常会复用已有元素而不是从头开始. keep-alive 的作用? 主要用于保留组件状态和避免重新渲染, 属性: include(保存组件状态)和exclude(不缓存组件的状态) 1234&lt;keep-alive :include=\"/a|b/\" :exclude=\"['c', 'd']\"&gt; &lt;component :is=\"viewname\"&gt; &lt;/component&gt;&lt;/keep-alive&gt; 如何编写可复用组件? Props, 事件, slot props 允许外部环境传递变量到内部 事件 允许内部触发外部的行为 slot 允许外部环境将内容插入到内部的视图结构 vue的生命周期? vue的实例从新建到销毁的过程, 具体包括: 开始创建–初始化数据–编译模版–挂载dom渲染–更新渲染—卸载 vue生命周期的钩子函数有哪些， 做了什么？ beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 created 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)， 属性和方法的运算，watch/event 事件回调, 此时$el属性未赋值，ajax调用建议在此阶段执行 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子 activated keep-alive 组件激活时调用 deactivated keep-alive 组件停用时调用 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用 destoryed Vue 实例销毁后调用 errorCaptured 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及错误信息字符串","categories":[],"tags":[]},{"title":"","slug":"Vue-use","date":"2018-11-05T14:02:02.945Z","updated":"2018-11-05T14:02:02.945Z","comments":true,"path":"2018/11/05/Vue-use/","link":"","permalink":"http://zexiplus.github.io/2018/11/05/Vue-use/","excerpt":"","text":"vue remind 使用html字符串 12345678910111213&lt;script&gt; new Vue(&#123; el: '#app', data() &#123; return &#123; htmlTemplate: '&lt;p&gt;这里是一段html&lt;/p&gt;' &#125; &#125; &#125;)&lt;/script&gt;&lt;div v-html=\"htmlTemplate\"&gt; &lt;/div&gt; vue cli 12vue list // 列出所有可用脚手架vue init webpack demo // 创建以webpack为脚手架名为demo的项目 main.js 123456789101112131415161718/* ----------- main.js ------------------ */import App from './App'new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;)// 与上面写法等效 (使用render函数)new Vue(&#123; el: '#app', router, store, render: h =&gt; h(App)&#125;) Vue config 1234# 在vue中使用less于编译器npm i less less-loader -S# webpack.base.config.jsmodules.exports.module.rules: [&#123;test: /\\.less$/, loader: 'style-loader!css-loader!less-loader'&#125;] vue plugins Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; vue directives 注册指令 123456789101112131415161718//全局注册Vue.directive('directiveName',&#123; bind: function (el, binding) &#123; //binding.value 指绑定的值 &#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;);//组件内注册export default &#123; directives: &#123; directiveName: &#123; bind() &#123;&#125; .....//一系列钩子函数 &#125; &#125;&#125; vue style 12345678&lt;!-- 样式引入--&gt;&lt;style lang=\"less\" scoped&gt; @import './demo.less'&lt;/style&gt;&lt;div :class=\"&#123;classOne: true, classTwo: true&#125;\" :style=\"&#123;color: 'red', fontSize: '12px', 'background-color': 'red'&#125;\"&gt;&lt;/div&gt; 12345678910111213141516171819/* --------------header 高度为100,动态设置main容器高度 --------- */let timer;export default &#123; data() &#123; return &#123; mainHeight: 0 &#125; &#125;, created() &#123; window.addEventListener('resize', () =&gt; &#123; if (timer) &#123; cleartTimeout(timer) &#125; else &#123; timer = setTimeout(() =&gt; &#123; this.mainHeight = window.innerHeight - 100; &#125;) &#125; &#125;) &#125;,&#125; vue load on demand 123456/* ---------------异步引入模块 ------------ */// 写法一const component = () =&gt; import('componentName') // 写法二const component = resolve =&gt; require(['componentName'],resolve) vue render（createElement function h） 1234567891011&lt;custom-component&gt; &lt;p slot=\"header\"&gt; 这里是头部内容 &lt;/p&gt; &lt;p&gt; 这里是默认slot内容 &lt;/p&gt; &lt;p slot=\"footer\"&gt; 这里是底部内容 &lt;/p&gt;&lt;/custom-component&gt; 12345678910111213// render 函数Vue.component('customComponent', &#123; render(h) &#123; let hearder = this.$slot.header; let main = this.$slot.default; let footer = this.$slot.footer; return h('div', [ h('header', header), h('main', main), h('footer', footer), ]) &#125;&#125;) vue render（with jsx） {value} 单花括号变量名 1234567891011121314151617181920new Vue(&#123; el: '#demo', props: ['name','imgSrc'], methods: &#123; handleImgClick() &#123; console.log('awesome picture') &#125; &#125;, render(h) &#123; return ( &lt;div level=&#123;1&#125; name=&#123;this.name&#125; class=&#123;&#123; foo: true, bar: false &#125;&#125; style=&#123;&#123; color: 'red', fontSize: '14px' &#125;&#125;&gt; &lt;img src=&#123;this.imgSrc&#125; onClick=&#123;this.handleImgClick&#125;/&gt; &lt;/div&gt; ) &#125;&#125;) Vue options 1234567// watch 深度观察, *注: 观察数组时不需要deep，但是arr[1] = 1,赋值操作不会触发观察,方法操作才会触发例如arr.splice(0, 1, 1)watch: &#123; c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;&#125; service 分离请求(太多ajax太丑陋，封装成单个js暴露出去，每个方法均返回promise实例) 123456789101112131415161718192021// index.jsimport Vue from 'vue'import VueResource from 'vue-resource'Vue.use(VueResource)// 小 service模块import login from './login' import cart from '.cart'export default &#123; login, cart,&#125;// cart.jsimport Vue from 'vue'export default &#123; getProductsById(id) &#123; return Vue.http.get('url', &#123;params: &#123;id&#125;&#125;) &#125;&#125; vue others 123456789101112131415161718192021222324252627// Vue.extend(component) 创建并返回一个子类，可用于构造新组件用于测试import app from './app'const App = Vue.extend(app)new App().$mount('#id') // 创建并挂载组件const vm = new App().$mount() // 创建组件并挂载（也可以不挂载）expect(vm.$el.querySelector('h1').textContent).toEqual('title') // 判断组件内部选择器h1内容// 路由跳转this.$router.push(&#123;name: 'pathName'&#125;)/* --------------------返回当前route路径 ------------------ */computed() &#123; return this.$route.path&#125;/* ----------单独引用element 组件使用方法------- */import &#123; MessageBox &#125; from 'element-ui'//单独调用MessageBox.alert(msg, title, &#123;type:'error'&#125;);//挂载后调用this.$alert(msg, title, &#123;type:'error'&#125;);/*---------------动态组建 (可用于一个页面有多个弹窗)----------------------*/v-bind:is=”componentName”&lt;component :is=”currentView”&gt;&lt;/component&gt;","categories":[],"tags":[]},{"title":"React 学习总结","slug":"React","date":"2018-10-29T18:13:57.370Z","updated":"2018-10-29T18:13:57.370Z","comments":true,"path":"2018/10/30/React/","link":"","permalink":"http://zexiplus.github.io/2018/10/30/React/","excerpt":"","text":"react 参考Table of content[TOC] react重点 关注点分离: 为每个关注点创建一个组件 子节点: 所有开始标签和结束标签的子节点保存在this.props.children属性 变量,属性:使用花括号 {var} 展现变量和属性 事件 &lt;Divider onClick={this.handleClick} /&gt; ref.myinput.getDOMNode() 拿到真实dom节点 class属性要写为className 生命周期&amp;钩子 生命周期: 实例化, 存在期, 销毁&amp;清理期 实例化 getDefaultProps getInitialState (此时可以访问this.props) componentWillMount render componentDidMount 存在期 componentWillReceiveProps shouldComponentUpdate (首次渲染不会调用) componentWillUpdate componentDidUpdate 销毁&amp;清理期 componentWillUnmount 数据&amp;属性 在react中,数据(props)是单向流动的， 从父节点传递到子节点， 禁止一个组件修改自己的props props,用于管理从外部传入的数据。 &lt;MyComponent list={list} /&gt; 钩子getDefaultProps (() =&gt; {showOpt: true}) state , 用于管理组件自身的数据。 钩子 getInitialState(() =&gt; {showOpt: true}) 修改(合并)state： this.setState({value: 1}) , 替换 state this.replaceState({value: 1}) 只要setState调用， render就会被调用, 不要直接赋值给 state 把props当作只读， state尽量存放简单数据 例如表单控件的隐藏和显示 属性检查 { propTypes: {id: React.PropType.string.isRequired}} 事件 手动开启触控事件 React.initialzeTouchEvents(true) 绑定事件 &lt;Component onClick=&quot;this.handleClick&quot; /&gt; 事件的值 event.target.value 父子组件通讯 父组件通过单向props传递给子组件， 子组件通过传递的事件进行通信 123456789101112131415161718class Sup extends React.Component &#123; constructor(props) &#123; super(props) this.handleChange = this.handleChange.bind(this) &#125; handleChange(e) &#123;&#125; render() &#123; return (&lt;Sub onChange=&#123;this.handleChange&#125; /&gt;) &#125;&#125;class Sub extends React.Component &#123; constructor(props) &#123; supper(props) &#125; render() &#123; return (&lt;select onChange=&#123;this.props.onChange&#125;&gt;&lt;/select&gt;) &#125;&#125; 组件 受控组件 ， 组件内部状态由用户管理， 最简单的实现就是一个 自定义表单输入框 非受控组件 ， 组件内部状态不可控 ,用在不做任何校验的场景 ref.id.getDOMNode() 获取真正的dom节点， 此方法在componentDidMount可访问 整合非react类库 , 在componentDidMount函数中访问dom节点， 写逻辑 12345678910111213class AnimateBox extends React.Component &#123; constructor(props) &#123; super(props) &#125; render() &#123; return ( &lt;div ref=\"box\" id=\"animateBox\" &gt;0&lt;/div&gt; ) &#125; componentDidMount() &#123; animate(&#123;el: this.ref.box.getDOMNode(), type: 'rotate'&#125;) &#125;&#125; 性能优化 使用shouldComponentUpdate 来判断组件是否需要重新渲染， 返回 true 代表需要重新渲染 12345&#123; shouldComponentUpdate(nextProps, nextState) &#123; return nextProps.id !== this.props.id // 只有id更新才更新组件 &#125;&#125; 使用React.addons.PureRenderMixin插件 123&#123; mixin: [React.addons.PureRenderMixin]&#125; 监控性能变化插件 React.addons.Perf 123456// 控制台运行React.addons.Perf.start()// 操作应用， 记录耗时的操作React.addons.Perf.stop()// 打印时间表单React.addons.Perf.printWaster() 为列表添加key属性， 避免重复渲染。 服务端渲染 var comp = React.renderToString() 只有一个参数, 且为同步函数 会渲染出带有data前缀属性的dom节点字符串, 用于客户端和服务端追踪 React.renderToStaticMarkup() 区别在于生成的没有data属性, 用于不打算在客户端渲染component的情况 生命周期 , 服务端渲染会调用包括render函数之前的钩子, compoentDidMount和componentWillUnmount不会调用 服务端渲染异步状态, 在异步函数返回时调用renderToString 插件 jest 测试工具 Immutable.js 不可变数据结构 Flux 状态管理 三个重要概念: dispatcher, store, view Redux Store 存储数据的地方， 一个应用只有一个store 12import &#123; createStore &#125; from 'redux'const store = createStore(fn) State , store包含所有数据， 如果想得到某个时点的数据，就要生成快照 state 1const state = store.getState() Action, state的变化会导致view的变化 , 但是用户接触不到state， 所以state变化是view导致的， Action就是view发出的通知， 标识state要发生变化. store.dispatch是view发出action的唯一办法 1store.dispatch(&#123;type: 'addToDo', payload: 'some message'&#125;) store.subscribe() 设置监听函数， 一旦state发生变化， 就自动执行这个函数 Reducer store收到action后， 必须给出一个新state， 这样view才会发生变化。这种state计算过程就叫reducer， Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State 123const reducer = function (state, action) &#123; return newState&#125; 架构图 react 组件结构12345678910111213141516171819202122232425262728293031class MarkdownEditor extends React.Component &#123; constructor(props) &#123; super(props) this.handleChange = this.handleChange.bind(this) this.state = &#123; value: 'Type your markdown'&#125; &#125; handleChange(e) &#123; this.setState(&#123; value: e.target.value &#125;) &#125; generateMarkdown() &#123; const md = new Remarkable(); return &#123; __html: md.render(this.state.value) &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;textarea onChange=&#123;this.handleChange&#125; defaultValue=&#123;this.state.value&#125; /&gt; &lt;h1&gt;output markdown&lt;/h1&gt; &lt;div className=\"output\" dangerouslySetInnerHTML=&#123;this.generateMarkdown()&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 脚手架 Create-react-app(官方) https://github.com/facebook/create-react-app 下载 1npm i -g create-react-app 使用 123456# by using create-react-app# 会创建全新的文件夹作为顶级目录create-react-app my-app# by using yarnyarn create react-app my-app Assets Import img 1234import logo from './logo.png'function Photo() &#123; return &lt;img src=&#123;logo&#125; alt=\"logo\" /&gt;&#125; import css 1import './css/app.css' API ReactDOM.render 在指定dom元素上渲染react元素 123const element = &lt;img src=&#123;img.url&#125; /&gt;const dom = document.querySelector('.pic')ReactDOM.render(element, dom) JSX 普通表达式 1const element = &lt;div&gt;hello world&lt;/div&gt; 嵌入表达式 使用单层括号使用变量, 函数 { variable } 12345678const name = 'float'const userinfo = (person) =&gt; &#123; return `person's name is $&#123;person.name&#125; age is $&#123;person.age&#125;`&#125;const element = &lt;div&gt;hello, &#123;name&#125;&lt;/div&gt;const element2 = &lt;div&gt;hello, &#123;userinfo(&#123;name: 'float'&#125;)&#125;&lt;/div&gt;ReactDOM.render(element, document.querySelector('body')) Components and props Functional components 函数组件 1234567function Welcome (props) &#123; return &lt;div&gt;hello &#123;props.name&#125;&lt;/div&gt;&#125;const welcome = &lt;Welcome name=\"float\"&gt;&lt;/Welcome&gt; ReactDOM.render(welcome, document.querySelector('body')) class components 类组件 12345678class Tittle extends React.Component &#123; render() &#123; return &lt;h1&gt;this is a tittle &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;// 渲染类组件const tittle = &lt;Tittle name=\"float\" /&gt; composing components 嵌套组件 1234567891011function Parent(props) &#123; return &lt;div id=&#123;props.id&#125;&gt; &lt;Sub index=\"1\"&gt;&lt;/Sub&gt; &lt;Sub index=\"2\"&gt;&lt;/Sub&gt; &lt;/div&gt;;&#125;function Sub(props) &#123; return &lt;p&gt;&#123;props.index&#125;&lt;/p&gt;&#125; Read-only props 组件的属性是只读的 12345// do not use like thisfunction Title(props) &#123; props.name += 'tail' return &lt;h1&gt;name is &#123;&#125;&lt;/h1&gt;&#125; Life circle 组件生命周期钩子函数 State init state 使用constructor 初始化state 1234567891011class Num extends React.Component &#123; constructor(props) &#123; super(props) // state只可以在constructor中可以直接赋值 this.state = &#123;num: 1&#125; &#125; render() &#123; return &lt;div&gt;num is &#123;this.state.num&#125;&lt;/div&gt; &#125;&#125; hooks 钩子函数改变state 1234567891011class Clock extends React.Component &#123; refreshClock() &#123; this.setState(&#123;time: new Date()&#125;) &#125; componentDidMount() &#123; this.clockId = setInterval(() =&gt; this.refreshClock(), 1000) &#125; componentWillUnmount() &#123; this.clearInterval(this.clockId) &#125;&#125; setState 改变state 12345678910// 对象作为参数this.setState(&#123; name: 'float', age: 24&#125;)// 函数作为参数, 用于引用state, propsthis.setState((state, props) =&gt; (&#123; num: props.num + 1&#125;) share state 当两个组件需要共享state时, 提升state 12345678910111213141516171819202122232425262728293031323334353637383940class ParentState extends React.Component &#123; constructor(props) &#123; super(props) this.saveNum = this.saveNum.bind(this) this.state = &#123; num: 0 &#125; &#125; saveNum(e) &#123; this.setState(&#123; num: e.target.value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;SubState num=&#123;this.state.num&#125; tag='small' onHandleChange=&#123;this.saveNum&#125; /&gt; &lt;SubState num=&#123;this.state.num&#125; tag='big' onHandleChange=&#123;this.saveNum&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class SubState extends React.Component &#123; constructor(props) &#123; super(props) &#125; render() &#123; let num = this.props.num if (this.props.tag === 'big') &#123; num = Number(num) + 5 &#125; let changeHandler = this.props.onHandleChange return ( &lt;div&gt; &lt;input value=&#123;num&#125; onChange=&#123;changeHandler&#125; /&gt; &lt;/div&gt; ); &#125;&#125; Event event binding 事件绑定 1&lt;button onClick=&#123;postData&#125;&gt;&lt;/button&gt; preventDefault 阻止事件默认行为 1234567891011function Submit(props) &#123; function postData(e) &#123; e.preventDefault() // do some thing &#125; return ( &lt;div&gt; &lt;a href=\"#\" onClick=&#123;postData&#125;&gt;&lt;/a&gt; &lt;/div&gt; )&#125; params 事件传参 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; Conditional render state conditional using if 123456789101112131415161718192021222324252627282930313233343536373839404142class LoginControl extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; isLogin: false &#125; &#125; login() &#123; this.setState(&#123; isLogin: true , username: 'float'&#125;) &#125; logout() &#123; this.setState(&#123; isLogin: false &#125;) &#125; render() &#123; const isLoginFlag = this.state.isLogin let template if (isLoginFlag) &#123; template = ( &lt;div&gt; &lt;p&gt;welcome &#123;this.state.username&#125;&lt;/p&gt; &lt;button onClick=&#123;this.logout&#125;&gt;&lt;/button&gt; &lt;/div&gt; ); &#125; else &#123; template = ( &lt;div&gt; &lt;p&gt;please login&lt;/p&gt; &lt;button onClick=&#123;this.logout&#125;&gt;&lt;/button&gt; &lt;/div&gt; ); &#125; return ( &lt;div&gt; &lt;p&gt;this is login component&lt;/p&gt; &#123;template&#125; &lt;/div&gt; ) &#125;&#125; List render list 列表的渲染, 必须有全局唯一 key 属性 123456789function List(props) &#123; return ( &lt;ul&gt; &#123; props.numbers.map( item =&gt; &lt;li key=&#123;item.value.toString()&#125;&gt;&#123;item.value&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; )&#125; Form 表单的渲染与事件绑定 12345678910111213141516171819class Form extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: '' &#125; this.handleValueChange = this.handleValueChange.bind(this) &#125; handleValueChange(e) &#123; this.setState(&#123;name: e.target.value&#125;) &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt;type your name&lt;/label&gt; &lt;input value=&#123;this.state.name&#125; onChange=&#123;this.handleValueChange&#125; /&gt; &lt;span&gt;&#123;this.state.name&#125;&lt;/span&gt; &lt;/form&gt; ); &#125;&#125; Children props.children 非命名子属性, 使用props.children 属性组合其他组件的内容 12345678910111213141516171819202122232425262728293031323334class Mavic extends React.Component &#123; constructor(props) &#123; super(props) &#125; fly() &#123; console.log('I can fly') &#125; render() &#123; return ( &lt;div className=&#123;'colorful' + this.props.color&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125; &#125;class MavicPro extends React.Component &#123; constructor(props) &#123; super(props) &#125; fly() &#123; console.log(' I can fly 60km/h') &#125; render() &#123; &lt;div&gt; &lt;Mavic&gt; &lt;span&gt;hi I am mavic pro&lt;/span&gt; &lt;button&gt;click to buy me&lt;/button&gt; &lt;/Mavic&gt; &lt;/div&gt; &#125;&#125; props.left … 命名子属性 12345678910111213141516171819202122232425function TableContent(props) &#123; return ( &lt;div&gt; &lt;div className=\"left\"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=\"right\"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function RandL() &#123; let left = &lt;div&gt;hello left&lt;/div&gt; let right = &lt;div&gt;hello right&lt;/div&gt; return ( &lt;div&gt; &lt;TableContent left=&#123;left&#125; right=&#123;right&#125; /&gt; &lt;/div&gt; );&#125; react router路由 初始化 install 1npm install react-router-dom using router 1234567891011121314// app.jsimport &#123; Route, Link, BrowserRouter as Router &#125; from 'react-router-dom'const routing = ( &lt;Router&gt; &lt;div&gt; &lt;Route exact path=\"/\" component=&#123;App&#125; /&gt; &lt;Route path=\"/users\" component=&#123;User&#125; /&gt; &lt;Route path=\"/contract\" component=&#123;Contract&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;)ReactDOM.render(routing, document.querySelector('#root')) exact 属性: 精确匹配, 若不加此属性, /users 和 /contract会匹配到 / Tag link 1234567891011121314const routing = ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/users\"&gt;users&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/contract\"&gt;contract&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/\" component=&#123;App&#125; /&gt; &lt;Route path=\"/users\" component=&#123;Users&#125; /&gt; &lt;Route path=\"/contract\" component=&#123;Contract&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;) Switch Switch 标签用于匹配notfound page 1234567&lt;Router&gt; &lt;Link to=\"/\"&gt;home&lt;/Link&gt; &lt;Switch&gt; &lt;Route path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt; BrowserRouter &amp;&amp; HashRouter 两种路由, 浏览器路由和静态哈希路由(浏览器地址栏带有#) 123456789import &#123; BrowserRouter, HashRouter &#125; from 'react-router-dom'function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;link&gt;&lt;/link&gt; &lt;Router /&gt; &lt;/BrowserRouter&gt; )&#125;","categories":[],"tags":[]},{"title":"Today learnt","slug":"TodayLearn","date":"2018-10-16T15:22:04.812Z","updated":"2018-10-16T15:22:04.812Z","comments":true,"path":"2018/10/16/TodayLearn/","link":"","permalink":"http://zexiplus.github.io/2018/10/16/TodayLearn/","excerpt":"","text":"Today learnt按时间线整理知识点, 利于复习和记忆 201810.9 document.activeElement 访问正在聚焦、高亮的元素 el.focus() el.blur() 元素获得失去焦点 使普通元素能获得焦点 &lt;div tabindex=&quot;1&quot;&gt;enable focus&lt;/div&gt; 使表单元素失去焦点 &lt;input tabindex=&quot;-1&quot; /&gt;","categories":[],"tags":[]},{"title":"工作踩坑总结记录","slug":"experience","date":"2018-09-08T07:02:19.061Z","updated":"2018-10-01T14:58:02.399Z","comments":true,"path":"2018/09/08/experience/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/experience/","excerpt":"","text":"experience工作踩坑总结 vue 的 router-link 绑定click事件绑定不上，需要在原生元素上绑定. **@click.native** 1&lt;router-link @click.native=\"handleClick\" &gt;&lt;/router-link&gt; 在vue中绑定html 字符串, 使用 v-html 指令 1&lt;div v-html=\"htmlTemplate\"&gt;&lt;/div&gt; a 链接 控制 iframe跳转 1234&lt;a href=\"target.html\" target=\"iframepage\"&gt;&lt;/a&gt;&lt;iframe id=\"iframepage\"&gt; &lt;/iframe&gt; 通过a标签访问javascript函数 1&lt;a href=\"javascript:dosomething();\"&gt;&lt;/a&gt;","categories":[],"tags":[]},{"title":"Vue插件使用技巧","slug":"vue-plugins","date":"2018-09-08T06:57:48.423Z","updated":"2018-09-29T16:38:38.679Z","comments":true,"path":"2018/09/08/vue-plugins/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/vue-plugins/","excerpt":"","text":"Vue Pluginsvue 插件收录, 用法 Table of content[TOC] prerender-spa-plugin 预渲染插件， 提升首屏徐然速度， seo优化 https://github.com/chrisvfritz/prerender-spa-plugin vue-server-renderer 服务端渲染插件 Vue-axios 客户端ajax 请求插件 git repo 创建ajax实例对象 axios.create(options) 123456axios.create(&#123; baseURL: 'http://localhost:3000', timeout: 1000, headers: &#123;'X-Custom-Header': 'football'&#125;, withCredentials: true,&#125;) 全局ajax请求拦截 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//挂载请求拦截器var interceptor = axios.interceptors.request.use(function (config) &#123; // 对请求进行设置（格式。。。）返回config if (config.method === 'post') &#123; config.headers['Content-Type'] = 'application/x-www-form-urlencoded'; &#125; return config;&#125;, function (error) &#123; // 失败操作 alert('操作失败') return Promise.reject(error);&#125;);//取消拦截器axios.interceptors.request.eject(interceptor)/* -------------------响应拦截器，可处理失败响应等等 --------------------- */axios.interceptors.response.use(function (response) &#123; //根据响应状态吗判断 if (response.status !== 200) &#123; alert('服务器异常'); return Promise.reject(response); &#125; //根据响应返回信息判断 else if (response.data.ret !== 0) &#123; alert(ERR_CODE[response.data.ret] || '操作失败'); //返回失败态promise return Promise.reject(response.data.ret_msg); &#125; return response;&#125;, function (error) &#123; // 错误处理 return Promise.reject(error);&#125;);/* ------------------ Promise.all应用(多项操作，但接口不支持多个) --------------------- */&#123; arr: [1,2,4,5] getById(id) &#123; // service接口请求，返回promise实例 return this.service.getById(id) &#125; getByIds() &#123; new Promise.all(this.arr.map(item =&gt; this.getById(item))).then(results =&gt; &#123; this.getList() &#125;).catch((err) =&gt; &#123; alert('请求出错') &#125;) &#125;&#125; 分离服务 service 123456789101112131415161718192021222324252627```jsimport api from &apos;./api&apos;import axios from &apos;axios&apos;const ajax = axios.create(&#123; timeout: 3000&#125;)const service = &#123; device: &#123; getList(params) &#123; return ajax.get(api.device.getList, params) &#125; &#125;, user: &#123; saveInfo(params) &#123; return ajax.post(api.user.saveInfo, params) &#125; &#125;&#125;export default &#123; install(V, options) &#123; V.prototype.$service = service &#125;&#125; 1234```jsimport service from &apos;./service&apos;Vue.use(service) 1234567891011```jsexport default &#123; methods: &#123; getList() &#123; this.$service.getList().then(res =&gt; &#123; // to do something &#125;) &#125; &#125;&#125; vue router vue 路由 参考链接 this.\\$route 代表当前页面的url封装对象,url不同对应不同的route对象 1234567891011121314&#123;name: \"mainFrame\", meta: &#123;…&#125;, path: \"/mainFrame\", hash: \"\", query: &#123;…&#125;, …&#125;// this.$route.matched 表示vue-router 实例 匹配的模式&#123; name: 'page2', path: 'page2', // 对应的浏览器url为 localhost:8080/mainFrame/page2 component: page2&#125;, // this.$route.query /path?name=xiaoxiix&amp;id=123&#123; name: 'xiaoxixi', id: '123'&#125; this.$router router 代表vue-router全局对象，全局唯一 123456789101112131415&#123;app: Vue, apps: Array(1), options: &#123;…&#125;, beforeHooks: Array(0), resolveHooks: Array(0), …&#125;// 浏览器会生成一条历史记录，后退键可用this.$router.push('home') // 浏览器地址变为 localhost/dynamicCom/123this.$router.push(&#123;name: 'dynamicCom', &#123; params: &#123; id: '123' &#125; &#125; &#125;)this.$router.push(&#123;name: 'dynamicCom', &#123;query: &#123;name: 'xiaoxixi'&#125;&#125;&#125;)// router.replace() 浏览器不会生成历史记录，用法和push一致this.$router.replace()// router.go(n)this.$router.go(-1) // 浏览器后退一步this.$router.go(2) // 前进两步 using 123456789101112```html&lt;template&gt; &lt;div&gt; &lt;router-view/&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;!-- 命名路由视图 --&gt; &lt;router-link to=&quot;/user&quot;&gt;user&lt;/router-link&gt; &lt;router-link :to=&quot;&#123; name: &apos;setting&apos; &#125;&quot;&gt;main&lt;/router-link&gt; &lt;router-link :to=&quot;&#123; name: &apos;page1&apos; &#125;&quot;&gt;link1&lt;/router-link&gt; &lt;router-link :to=&quot;&#123; name: &apos;page2&apos; &#125;&quot;&gt;link2&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 1234567```jsimport router from &apos;./router&apos;new Vue(&#123; el: &apos;#app&apos;, router,&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111```jsimport Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;// 引入组件import mainFrame from &apos;@/components/mainFrame&apos;import dynamicCom from &apos;@/components/dynamicCom&apos;const page1 = () =&gt; import(&apos;@/components/page1&apos;)const page2 = () =&gt; import(&apos;@/components/page2&apos;)Vue.use(Router)const router = new Router(&#123; // 控制滚动行为，如果有上次访问同一页面的位置，则返回相同的位置，否则跳转到 x: 300, y: 800 位置 scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 300, y: 800 &#125; &#125; &#125;, routes: [ &#123; path: &apos;/mainFrame&apos;, name: &apos;mainFrame&apos;, component: mainFrame, // 嵌套子路由 children: [ &#123; name: &apos;page1&apos;, path: &apos;/page1&apos;, // 对应的浏览器url为 localhost:8080/page1 component: page1, meta: &#123; needAuth: true, &#125; &#125;, &#123; name: &apos;page2&apos;, path: &apos;page2&apos;, // 对应的浏览器url为 localhost:8080/mainFrame/page2 component: page2 &#125;, &#123; name: &apos;page3&apos;, path: &apos;page3&apos;, redirect: &#123; name: &apos;page2&apos; &#125;, // 重定向路由，重定向至路由name: &apos;page2&apos; &#125;, &#123; path: &apos;/page2&apos;, alias: &apos;/page4&apos;, // 别名路由，访问localhost:8080/page4 和 访问 ../page2 一致 component: page2, &#125;, &#123; name: &apos;nameRouter&apos;, path: &apos;nameRouter&apos;, components: &#123; default: nameView, a: viewA &#125; &#125;, // 属性路由,组件可以接受路由中的参数作为props &#123; name: &apos;propsRouter&apos;, path: &apos;props/:name&apos;, // 访问../props/xiaoxixi 组件name属性为&apos;xiaoxixi&apos; component: propsRouter, props: true, &#125;, &#123; name: &apos;propsRouter&apos;, path: &apos;props/:name&apos;, // 访问../props/xiaoxixi 组件name属性为&apos;daxixi&apos; component: propsRouter, props: &#123;name: &apos;daxixi&apos;&#125;, &#125;, ] &#125;, /* 动态路由 在dynamicCom组建内可通过 this.$route.params.id 拿到浏览器地址栏 /dynamicRouter/12 的参数12 */ &#123; path: &apos;/dynamicRouter/:id&apos;, name: &apos;dynamicRouter&apos;, component: dynamicCom &#125;, &#123; path: &apos;*&apos;, // 除此之外所有路由均不匹配时会匹配此项 name: &apos;notFound&apos;, component: notFoundPage, &#125;, ]&#125;)// 全局路由钩子router.beforeEach((to, form, next) =&gt; &#123; // 进入默认主页 if（to.fullPath === &apos;/&apos;) &#123; next(&#123;name: &apos;home&apos;&#125;) &#125; else if (to.matched.some(item =&gt; item.needAuth)) &#123; next(&#123;name: &apos;needAuth&apos;&#125;) &#125; else &#123; next() // 通过路由 &#125; next(&#123;path: &apos;route1&apos;&#125;) next(new Error()) // 传递错误&#125;)router.onError(err =&gt; &#123; // 处理错误&#125;)export default router 动态路由 123456789101112131415161718192021222324&lt;script&gt; export default &#123; watch: &#123; &apos;$route&apos; (to, from) &#123; // 监听地址栏动态参数变化 console.log(to, from) &#125;, &#125;, // route hook in-component beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; &#125;) &#125;, beforeRouteUpdate (to, from, next) &#123; if (to.params.id == &apos;123&apos;) &#123; next() // call next() to change route &#125; &#125;, afterRouteLeave (to, from, next) &#123; next() &#125; &#125;&lt;/script&gt; vuex vue 状态管理 doc链接 state 全局单一状态树存储对象，遵循响应式原则 1234567891011const state = &#123; num: 5, user: &#123; name: 'xiaoxixi', age: 21, &#125;, list: [ &#123;id: '1', price: 5, name: 'banana', saled: false&#125;, &#123;id: '2', price: 10, name: 'watermelon', saled: true&#125;, ]&#125; 访问state 1this.$store.state.user 1&lt;span&gt;&#123;&#123;$store.state.user&#125;&#125;&lt;/span&gt; 快速访问state (mapState) 123456789import &#123; mapState &#125; from 'vuex'const vm = &#123; computed: &#123; ...mapState(&#123; count: state =&gt; state.count, countAlias: 'count', &#125;) &#125;&#125; getters 从state派生出一些属性，比如过滤，统计 12345678910111213const getters = &#123; listNum(state, getters) &#123; // 参数1为state对象,参数2为其他getters对象 return state.list.length &#125;, saledLength(state) &#123; return state.list.filter(item =&gt; item.saled) &#125;, findByPrice(state) &#123; // 返回函数，之后通过函数调用 return price =&gt; &#123; return state.list.find(item =&gt; item.price === price) &#125; &#125;&#125; 访问getters 12this.$store.getters.listNum // 属性访问this.$store.getters.findByPrice(5) // 方法访问 快速访问getters (mapGetters) 123computed: &#123; ...mapGetters(['listNum', 'saledLength', 'findByPrice'])&#125; mutations 更改state的唯一方式 每个mutations都有一个字符串的事件类型和一个callback(state, payload) 参数一为state, 参数2为提交的载荷 1234567const mutations = &#123; reduce (state, n) &#123; this.num -= n &#125;&#125;// in component usethis.$store.commit('reduce', 5) mutations 修改state的对象属性 必须遵守响应式规则, 必须是同步函数 1234addProps (state, prop) &#123; state.props = &#123; ...state.props, prop&#125; Vue.set(state.props, 'props', prop)&#125; 快速访问mutations(mapMutations) 123methods: &#123; ...mapMutations(['reduce'])&#125; actions 通过actions提交mutations，可以包含异步操作 123456789101112const store = &#123; actions: &#123; incrementAsync (context) &#123; window.setTimeout(() =&gt; &#123; context.commit('addProps') context.commit('lalal') &#125;, 1000) &#125; &#125;&#125;this.$store.dispatch('incrementAsync') 快速访问actions (mapActions) 12345export default &#123; methods: &#123; ...mapActions(['incrementAsync']) &#125;&#125; 异步操作 123456789101112131415actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125;// usethis.$store.dispatch('actionA').then(() =&gt; &#123; ...&#125;) plugins 123456789const myPlugin = store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; // 每次mutations之后调用 &#125;)&#125;const store = new Vuex.Store(&#123; plugins: [myPlugin]&#125;) vuex module 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647```jsimport Vue form &apos;vue&apos;import Vuex form &apos;vuex&apos;// 辅助函数import &#123;mapState, mapGetters&#125;import module1 from &apos;./modules/module1&apos;import module2 from &apos;./modules/module2&apos;const debug = process.env.NODE_ENV !== &apos;production&apos;Vue.use(Vuex)const state = &#123; todos: [ &#123;name: &apos;football&apos;, done: false&#125;, &#123;name: &apos;basketball&apos;, done: true&#125;, ]&#125;const getters = &#123; getDoneTodos(state) &#123; return state.todos.filter(item =&gt; item.done) &#125;, doneNums(state) &#123; return state.todos.filter(item =&gt; item.done).length &#125;, // 返回一个函数 getByPrice(state) &#123; return price =&gt; state.todos.filter(item =&gt; itme.price &gt; price).length &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;export default new Vuex.Store(&#123; state, getters, mutaions, actions, modules: &#123; module1, module2 &#125;, strict: debug, //设置运行模式 plugin: debug ? [createLogger()] : [], // 开发模式加入日志插件&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960```js// 服务层逻辑，封装ajax调用返回promise对象import service from &apos;../api/service/curl&apos;const state = &#123; productions: [ &#123; name: &apos;shootGun&apos;, price:3 &#125;, &#123; name: &apos;dog&apos;, price:10 &#125;, &#123; name: &apos;ball&apos;, price: 6&#125;, ], selectedProductions: [], user: &#125;// 定义state属性映射const getters = &#123; // 参数1：state对象， 参数2：自身getters，参数3：根state getAll: state =&gt; state.productions.filter(item =&gt; item.price &gt; 5), calculateAll(state, getters, rootState) &#123; return state.selectedProductions.reduce((total, item) =&gt; total + item.price * item.num, 0) &#125;&#125;// 定义commit修改, mutations必须是同步函数, const mutations = &#123; // 参数1：当前state对象, 参数2：commit后提交的载荷 addDiscountProduction(state, &#123; name, num, price&#125;) &#123; state.selectedProduction.push(&#123; name, num, price * 0.9 &#125;) &#125;, buyAll(state, &#123;buyAll&#125;) &#123; state.selectedProduction = [] state.isClear = buyAll &#125;, changeUser(state, payload) &#123; state.user = &#125;&#125;// 定义异步操作，内部触发mutationsconst actions = &#123; // 参数1：当前store对象 有state,commit,rootState等属性。 参数2：载荷对象 buyProductions(context, productions) &#123; service.buy(productions).then(res =&gt; &#123; context.commit(&apos;buyAll&apos;, res.body.success) &#125;) &#125;&#125;export default &#123; namespaced: true, // 是否启用命名空间，默认false,如果启用则数据不挂在到全局跟store上 state, getters, actions, mutations&#125; component use 12345678910111213141516171819202122import &#123; mapGetters, mapState, mapMutations, mapActions &#125; from 'vuex'new Vue(&#123; computed: &#123; ...mapGetters(&#123; getAllProducts: 'getAll' // 把getter的getAll作为名为getAllProducts的计算属性 &#125;), // 把state的productions作为同名计算属性 ...mapState(['productions', 'selectedProductions']), moduleState() &#123; return this.$store.state.moduleState.a &#125; &#125;, methods: &#123; ...mapMutations(['addDevice']), // 把store的addDevice作为同名方法 ...mapActions([]), // buyAll() &#123; this.$store.dispatch('buyProductions') &#125; &#125;&#125;)","categories":[],"tags":[]},{"title":"web前端开发调试技巧大全","slug":"debug","date":"2018-09-08T06:57:48.422Z","updated":"2018-10-01T14:56:14.142Z","comments":true,"path":"2018/09/08/debug/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/debug/","excerpt":"","text":"Debug 总结了常用web前端调试方法和nodejs调试方法 Table of contents[TOC] webfont debugconsole console.log 12// 占位符 %o(对象), %d(数字),%s(字符串), %f(浮点数)console.log(‘需要打印的是%o’,obj) console.group 打印组 1234console.group() console.log(1) console.log(2)console.groupEnd() console.trace() 打印调用栈 123456789101112function caller() &#123; exec()&#125;function exec() &#123; console.trace()&#125;caller()// exec @ VM123:5// caller @ VM123:2// (anonymous) @ VM123:8 console.time 打印执行时间 123console.time(timerName) fn（） console.timeEnd(timerName) console.dirxml 打印dom结构 1console.dirxml(document.querySelector('body')) console.dir 打印对象 1console.dir(obj) debugger在js代码内打上debugger 关键字 当代码运行至 debugger 处，浏览器打开控制台scope窗会显示当前scope的变量 Nodejs debug nodejs 程序调试工具， 方法， 技巧 node cli debug node 命令行窗口调试器 12345node inspect test.js# 进入debug模式， 会停在第一行可执行脚本处# 新版node debug 命令被弃用了， 用 inspect 代替node debug test.js 进入node debuger后输入下面命令(括号内为简写） cont(c) 执行剩余的所有代码 setBreakpoint(filename, line) 设置断点命令， 执行cont 会到此行暂定执行 ， 简称sb(filename, line), filename可省略，省略默认当前文件 clearBreakpoint(filename, line) 取消断点 简写cb() next(n) 逐步执行 list(n) 列出当前点后n行的代码 scripts 列出当前文件所有引用的模块（不包括内置模块） step(s) 进入函数内部 backtrace 查看当前函数在被调用函数的返回位置 out(o) 从函数中跳出至原执行流 watch(‘variable’) 监听变量， 变量每次修改都会显示出来, 变量值要加引号 watchers 查看所有被监听的变量值 unwatch(‘variable’) 取消监听变量 restart 从程序开始从新执行debug repl 进入repl环境 node debug with chrome 调试服务程序 启动 1node --inspect app.js 打开浏览器 输入 chrome://inspect， 点击target Source 面板 Add folder to Workspace 选择开发项目的目录 在文件中添加响应断点 查看变量 调试非服务程序 启动 在第一行就增加断点, 这样可以避免非服务脚本,运行太快而退出 1node --inspect-brk=9229 app.js 之后类似 调试运行时脚本 启动程序 1node app.js 按端口查看进程pid 1lsof -i :3000 启动调试程序 1node -e 'process._debugProcess()'","categories":[],"tags":[]},{"title":"Nodejs 总结","slug":"nodejs","date":"2018-09-02T12:51:47.045Z","updated":"2018-11-24T07:01:45.310Z","comments":true,"path":"2018/09/02/nodejs/","link":"","permalink":"http://zexiplus.github.io/2018/09/02/nodejs/","excerpt":"","text":"Nodejsnodejs 参考指南 Table of contents[TOC] Module require过的文件会加载到缓存，所以多次 require 同一个文件（模块）不会重复加载 ( a-&gt;b,b-&gt;a )循环引用并不会报错，导致的结果是 require 的结果是空对象 {}，原因是 b require 了 a，a 又去 require 了 b，此时 b 还没初始化好，所以只能拿到初始值 {} module.exports 初始值为一个空对象 {} exports 是指向的 module.exports 的引用 require() 返回的是 module.exports 而不是 exports require.cache 保存了当前模块引用的所有模块 Node REPL .break 退出noderepl .help 查看所有node repl命令 Develop Cli 常用node开发调试 cli命令 1234567891011121314151617# 查看npm 配置 (全局node_modules路径位置之类)npm config list # 设置npm配置npm install 全局安装路径npm config set prefix /usr/local/node_modules# 快速初始化项目npm init -y# 检查node代码node inspect myscript.js# 根据进程端口查看进程信息lsof -i :3000# 根据pid 杀死进程kill -9 pid Built-in moduleos 获取系统信息 http://nodejs.cn/api/os.html#os_os_platform os.platform() 显示系统平台， 等价于 process.platform darwin - mac系统， win32 - window系统， linux- linux系统 os.arch() 系统架构 例如 ‘x64’ os.cpus() 返回系统的cpus数组 os.userInfo() 返回用户信息 123456&#123; uid: -1, gid: -1, username: 'Administrator', homedir: 'C:\\\\Users\\\\Administrator', shell: null &#125; os.hostname() 返回计算机主机名 例如 ipanel-pc os.homedir() 返回当前用户home目录路径 例如 ‘C:\\Users\\Administrator’ os.freemem() 返回空闲系统内存字节数 例如 4228706304 os.totalmem() 返回系统的总内存数 os.networkInterfaces() 返回网络信息对象 ，如下 1234567&#123; '本地连接 3': [ &#123; address: 'fe80::94e1:8930:9f9c:b6c1', netmask: 'ffff:ffff:ffff:ffff::', family: 'IPv6', mac: '6c:4b:90:0d:74:d3', ...&#125; cluster 集群 http://nodejs.cn/api/cluster.html cluster.isMaster 一个node程序只有一个主进程, 此方法返回当前程序是否在主进程 cluster.fork() 只在主进程中可用, 复制出一个工作进程, 工作进程可以共享任意tcp连接 cluster.workers 返回所有进程的对象, 以进程id为键, 的哈希表 cluster.woker 当前工作对象的引用 cluster.on(‘message’, function (worker, message, handle) {}) 当主进程收到工作进程的任意消息时触发 process.on(‘message’, function () {}) 当工作进程收到主进程的消息时触发 worker.send(message, [handle]) 发送一个消息给工作进程或主进程，也可以附带发送一个handle process.send({msg: ‘hello’}) 从工作进程中发送消息给主进程 cluster.js demo 12345678910111213141516171819202122232425262728293031const cluster = require('cluster')const http = require('http')let cpuNum = require('os').cpus().lengthlet workers = []if (cluster.isMaster) &#123; for(let i = 0; i &lt; cpuNum; i ++) &#123; workers.push(cluster.fork()) // 向工作进程发送消息 workers[i].send('hello child cluster') &#125; cluster.on('exit', worker =&gt; &#123; console.log(`$&#123;worker.process.pid&#125; 工作进程已退出`) &#125;) // 监听工作进程的消息事件 cluster.on('message', function (worker, msg) &#123; console.log(`from worker message is$&#123;msg&#125;`) &#125;)&#125; else &#123; // 监听来自主进程的消息事件 process.on('message', msg =&gt; &#123; console.log(`receive $&#123;msg&#125;`) &#125;) http.createServer((req, res) =&gt; &#123; res.end('hello world') // 向主进程发送消息 process.send('the same to next') cluster.worker.send('i am a server') &#125;).listen(3000) // 共享http端口&#125; stream 流， 分为可读，可写， 可读写 都是EventEmitter的实例 http://nodejs.cn/api/stream.html 事件 data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 stream.Writable(obj) 创建可写流 , obj 必须要有_write方法 1234567const &#123; Writable &#125; = require('stream')const writable = new Writable(&#123; _write(chunk, encoding, callback) &#123; // do something callback() &#125; &#125;) buffer node二进制数据 buf.toString(encoding) 1buf.toString('utf8') process process 对象是全局对象， 不需要手动require引入 http://nodejs.cn/api/process.html process.env 系统环境变量 1234567891011# 运行程序时设置环境变量 # windows set NODE_ENV=test node test.js # uinxNODE_ENV=test node test.js# 跨平台npm i cross-env -g cross-env NODE_ENV=test node test.js# node 程序中设置process.env.NODE_ENV = 'test' process.exit(code) 指定当前进程立即退出 12345// 以 success 方式退出node进程process.exit(0)// 以 fail 方式退出node进程process.exit(1) process.argv 运行node程序的参数数组 12node one.js hello world # process.argv =&gt; ['/usr/bin/node', '/home/code/one.js', 'hello', 'world'] process.cwd() process.cwd() 代表 node 进程当前工作的目录, __dirname只返回当前文件的路径 12345678// /usr/lib/other.jsconsole.log(`process.cwd is $&#123;process.cwd()&#125;`) // /usr/libconsole.log(`__dirname is $&#123;__dirname&#125;`) // /usr/lib// /usr/main.jsrequire('./lib/other')// /usr// /usr/lib process.nextTick(cb) 一旦当前事件轮询队列的任务全部完成 , 所有cb就会依次调用 process.stdout 输出流， 是一个可写流， console.log 也属于process.stdout process.stdout.write() 12// 把用户输入输出到终端process.stdin.pipe(process.stdout) process.stdin 输入流， 可读流 12345678process.stdin.setEncoding('utf8')process.stdin.on('readable', () =&gt; &#123; let chunk = process.stdin.read() process.stdout.write(`receive data is $&#123;chunk&#125;`)&#125;)process.stdin.on('end', () =&gt; &#123; process.stdout.write('end')&#125;) process.on(‘exit’, cb) 进程退出事件 123process.on('exit', code =&gt; &#123; console.log(`退出码$&#123;code&#125;`)&#125;) process.kill(pid[,signal]) 结束进程 1process.kill(123) child_process12345678910111213141516const cp = require('child_process')// spawn 第一个参数命令，第二个参数 命令的参数let ls = cp.spawn('ls', ['-lh', '/usr'])ls.stdout.on('data', (data) =&gt; &#123; console.log(data)&#125;)ls.stdin.on('data', data =&gt; &#123; console.log(data)&#125;)ls.stderr.on('data', err =&gt; &#123; console.err(err)&#125;)ls.on('close', code =&gt; &#123; console.log(`退出码$&#123;code&#125;`)&#125;) path sep 区分windows平台和linux的文件分割符 \\ on Windows / on POSIX 12345678910111213141516171819202122232425262728293031323334//内置路径处理模块var path = require('path') //return 'currPath/www'path.join(__dirname,'www/') //把路径解析为绝对路径的函数 返回 path.resolve('/usr','./local','bin') // Returns: '/foo/bar/baz/asdf'path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// Returns:// &#123; root: 'C:\\\\',// dir: 'C:\\\\path\\\\dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;path.parse('C:\\\\path\\\\dir\\\\file.txt');┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │\" / home/user/dir / file .txt \"└──────┴──────────────┴──────┴─────┘// The path.resolve() method resolves a sequence of paths or path // segments into an absolute path.// Returns: '/foo/bar/baz'path.resolve('/foo/bar', './baz');// Returns: '/tmp/file'path.resolve('/foo/bar', '/tmp/file/');// if the current working directory is /home/myself/node,// this returns '/home/myself/node/wwwroot/static_files/gif/image.gif'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif'); file-system File system flags | Flag | detail || —- | —————————————————— || a | 打开文件进行追加。如果文件不存在，则创建该文件 || a+ | 打开文件读取并追加。如果文件不存在，则创建该文件 || r | 打开文件并读取。如果文件不存在，则发生异常 || r+ | 打开文件读取并写入。如果不存在，则发生异常 || w | 打开文件并写入。如果文件不存在则创建，存在则覆盖 || w+ | 打开文件并读取和写入。如果文件不存在则创建，存在则覆盖 | fs.readDir 打开文件夹 123456// 把一个文件夹下的文件拷贝到另一文件夹fs.readDir(path, (err, files) =&gt; &#123; files.forEach(item =&gt; &#123; fs.writeFileSync(__dirname + '/copy', fs.readFileSync(__dirname + '/origin')) &#125;)&#125;) fs.mkdir 新建目录 12// 若没有重名目录 则新建目录fs.existsSync(logFold) || fs.mkdirSync(logFold) fs.open Open file 12345const fs = require('fs')fs.open('test.txt', 'r+', (err, fd) =&gt; &#123; if (err) throw err console.log(fd)&#125;) fs.writeFile Write file 1234567891011121314// fs.writeFile(path, data, options, cb)fs.writeFile('text.txt', 'hello world', &#123;encoding: 'utf8', flag: 'w'&#125;, err =&gt; &#123; if (err) console.error(err)&#125;)// fs.write(fd, string, [position], [encoding], cb)fs.open('test.txt', 'a+', (err, fd) =&gt; &#123; fs.write(fd, 'hello world', err =&gt; &#123; if (err) return console.error(err) &#125;) fs.close(fd, err =&gt; &#123; if (err) console.error(err) &#125;)&#125;) fs.readFile Read file 1234567891011121314151617// fs.readFile(path, options, cb)fs.readFile('test.txt', &#123;encoding: null, flag: 'r'&#125;, (err, data) =&gt; &#123; if (err) console.error(err) console.log(data)&#125;)// fs.read(fd, buffer, offset, length, position, cb)fs.open('test.txt', 'r', (err, fd) =&gt; &#123; if (err) return console.error(err) let buffer = new Buffer(1024) fs.read(fd, buffer, 0, buffer.length, 0, (err, bytes) =&gt; &#123; if (err) return console.error(err) if (bytes &gt; 0) &#123; console.log(buffer.slice(0, bytes).toString()) &#125; &#125;)&#125;) fs.close close file 12345678// fs.close(fd, cb)fs.open('test.txt', 'r+', (err, fd) =&gt; &#123; if (err) throw err fs.close(fd, err =&gt; &#123; if (err) throw err console.log('close file successfully') &#125;)&#125;) fs.watch 监听文件/目录变化 12345678910// 监听filePath文件变化， 一旦改变，则运行回调函数const options = &#123; recursive: true, // 如果是目录, 是否递归监听子目录, 默认false encoding: 'utf8' // 监听文件名的字符编码&#125;fs.watch('filePath', options, (eventType, filename) =&gt; &#123; console.log(`current file state is $&#123;curr.sate&#125;`) cp.exec('mv index.js index-dep.js')&#125;) fs.createWriteStream 创建可写流 1234let writableStream = fs.createWriteStream(path.join(__dirname, '../readme.md'))let chunk = 'good good study day day up'// 向可写流中写入数据writableStream.write(chunk) http server.js 12345678910var http = require('http')//最基本服务器http.createServer((req,res) =&gt; &#123; if(req.url == '/hello') &#123; res.end('hello') &#125; if(req.url == '/world') &#123; res.end('world') &#125;&#125;).listen(6666) http method&amp;properties http.get(options, callback) 123456789101112131415161718http.get('http://nodejs.org/dist/index.json', (res) =&gt; &#123;const &#123; statusCode &#125; = res;const contentType = res.headers['content-type']; res.setEncoding('utf8');let rawData = '';res.on('data', (chunk) =&gt; &#123; rawData += chunk; &#125;);res.on('end', () =&gt; &#123; try &#123; const parsedData = JSON.parse(rawData); console.log(parsedData); &#125; catch (e) &#123; console.error(e.message); &#125;&#125;); &#125;).on('error', (e) =&gt; &#123;console.error(`错误: $&#123;e.message&#125;`); &#125;); http.request(options,[callback]) 1234567891011121314151617181920212223242526272829303132const postData = querystring.stringify(&#123; 'msg' : 'Hello World!' &#125;); const options = &#123; hostname: 'www.google.com', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(postData) &#125; &#125;; const req = http.request(options, (res) =&gt; &#123; res.setEncoding('utf8'); res.on('data', (chunk) =&gt; &#123; console.log(`响应主体: $&#123;chunk&#125;`); &#125;); res.on('end', () =&gt; &#123; console.log('响应中已无数据。'); &#125;); &#125;); req.on('error', (e) =&gt; &#123; console.error(`请求遇到问题: $&#123;e.message&#125;`); &#125;); // 写入数据到请求主体 req.write(postData); req.end(); response methods&amp;properties res.setEncoding(‘utf-8’) 设置编码格式 res.setHeader(‘Content-type’, ‘text/html’) 设置响应头 res.headers[‘content-type’] 获取content-type响应头 res.resume() 消耗res, 释放内存空间 res.writeHead(statusCode, [headers]) 设置响应头和响应码，会和setHeader合并，setHeader优先级高 1234res.writeHead(200, &#123; 'Content-Type': 'text/plain', 'Content-Length': Buffer.length(body)&#125;) request methods&amp;properties req.headers 12345678910&#123; 'host': 'localhost:3001', 'connection': 'keep-alive', 'cache-control': 'max-age=0', 'upgrade-insecure-requests': '1', 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) ...', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,zh-HK;q=0.7', 'cookie': 'name=float' // cookie会随请求头一起发送至服务器&#125; dns1234567891011121314151617181920212223242526const dns = require('dns')// dns.lookup 提供域名，解析出ip地址dns.lookup('hostname', (err, ipAddress, ipVersion) =&gt; &#123; &#125;)// dns.resolve4 与 dns.lookup作用相同，实现不同// dns.reverse 提供ip地址 反向解析出域名dns.resolve4('hostname', (err, ipAddress) =&gt; &#123; dns.reverse(ipAddress, (err, hostname) =&gt; &#123; console.log(hostname) &#125;)&#125;)// dns.Resolver 使用特定的值解析const server = new dns.Resolver([192.168.17.108])server.resolve4('hello.com', (err, ipAddress) =&gt; &#123; console.log(ipAddress) // 192.168.17.108&#125;)// 取消解析server.cancel() // 设置和返回当前dns解析的ip数组server.setServers(['123.23.22.22'])server.getServers() Async operator control1234567891011121314151617181920212223242526272829303132333435363738394041var fs = require('fs')var Promise = require('bluebird') //第三方promise模块，兼容global.Promise = Promise //全局promisefunction readFile(filename) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filename,(err, file) =&gt; &#123; if(err) &#123; reject(err) &#125; else resolve(file) &#125;) &#125;)&#125;readFile('./one.js').then(data =&gt; &#123; console.log(data)&#125;)//自己写的把普通函数转换为promise函数的函数Function.prototype.convertPromise = function() &#123; var fn = this return function() &#123; var args = [].slice.call(arguments, 0) return new Promise((resolve, reject) =&gt; &#123; args.push(function (err, file) &#123; if(err) &#123; reject(err) &#125; else &#123; resolve(file) &#125; &#125;) fn.apply(null, args) &#125;) &#125;&#125;var readFile2 = fs.readFile.convertPromise()readFile2('./one.js').then(data =&gt; &#123; console.log(data)&#125;) Package.json dependency 主版本号.次版本号.修正号 主版本号：当你做了不兼容的API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正 | 表达式 | 版本范围 | 说明 || ————————————- | ——————– | ———————————————————— || 1.2.1 | 1.2.1 | 匹配指定版本，这里是匹配1.2.1。 || ^1.0.0 | &gt;=1.0.0 且 &lt;2.0.0 | ^表示与指定的版本兼容，左边第一个非0字段不可变，后面的可变 || ^5.x | &gt;=5.0.0 且 &lt;6.0.0 | 同上 || ~0.1.1 | &gt;=0.1.1 且 &lt;0.2.0 | ~表示约等于版本，如果存在次版本号，则允许修订号为最高的，否则允许次版本为最高，如 ~1匹配&gt;=1.0.0 且 &lt;2.0.0 || * | 匹配 &gt;=0.0.0 | 通配符 || &gt;=3.0.0 | &gt;=3.0.0 | 其他符号还有&lt;,&lt;=,&gt;,&gt;=,=.字面意思。可使用空格表示AND，双竖线表示OR. || 1.30.2 - 2.30.2 | &gt;=1.30.2 且 &lt;=2.30.2 | || git://github.com/user/some.git#commit | Git URL形式的依赖 | 还支持URL、GitHub URL、本地 URL || latest | 当前发布的版本 | | 123456&#123; \"dependencies\": &#123; \"compression\": \"^1.2.3\", \"axios\": \"~1.2.3\" &#125;&#125;","categories":[],"tags":[]},{"title":"常用软件配置","slug":"Software-config","date":"2018-08-30T06:06:18.704Z","updated":"2018-09-29T16:37:30.647Z","comments":true,"path":"2018/08/30/Software-config/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Software-config/","excerpt":"","text":"software config记录并保存了常用软件的配置规则 wamp server(Apache) 配置有效的缓存策略 配置文件 httpd.conf 123456789101112131415161718# 第一种方法LoadModule expires_module modules/mod_expires.soExpiresActive On# html文档的过期时间为 从上次访问（A）开始 1000 秒钟ExpiresByType text/html A1000ExpiresByType image/gif A2592000# HTML文档的有效期是最后修改（M）时刻后的一星期ExpiresByType text/html M604800ExpiresByType text/css N1000ExpiresByType text/js \"now plus 2 days\"ExpiresByType image/jpeg \"access plus 2 months\"ExpiresByType image/bmp \"access plus 2 months\"ExpiresByType image/x-icon \"access plus 2 months\"ExpiresByType image/png \"access plus 2 months\"# 第二种方法LoadModule headers_module modules/mod_headers.soheader set cache-control \"max-age=1000\"","categories":[],"tags":[]},{"title":"网络状态协议解析","slug":"Network-protocol","date":"2018-08-30T06:06:18.703Z","updated":"2018-10-01T15:01:43.768Z","comments":true,"path":"2018/08/30/Network-protocol/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Network-protocol/","excerpt":"","text":"网络协议原理收录了一些网络协议, 网络状态的总结 目录[TOC] 浏览器输入url后发生了什么？1.DNS域名解析；2.建立TCP连接；3.发送HTTP请求；4.服务器处理请求；5.返回响应结果； 6.关闭TCP连接； 7.浏览器解析HTML；8.浏览器布局渲染； 步骤详解 建立tcp连接 ​ 客户端：“你好，在家不，有你快递。” ​ 服务端：“在的，送来就行。” ​ 客户端：“好嘞。” 发送http请求 关闭tcp连接 客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。” 服务端：“收到，我看看我这边有木有数据了。” 服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。” 客户端：“好嘞。” 浏览器解析html 浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。 浏览器通过解析HTML，生成DOM树(dom tree)，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。 要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题。 浏览器布局渲染 根据渲染树(render tree)布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。 replaint(重绘)：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不 变。​ reflow(重构)： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。 最后浏览器绘制各个节点，将页面展示给用户。 http头信息 请求头对象例子 12345678910&#123; host: \"localhost:3001\", referer: \"localhost:3001/request\", connection: \"keep-alive\", upgrade-insecure-requests: \"1\", user-agent: \"AppleWebKit/537.36 Chrome/67.0.3396.87 Safari/537.36\", accept: \"text/html,application/xhtml+xml,image/webp,image/apng,*/*;q=0.8\", accept-encoding: \"gzip, deflate, br\", accept-language: \"zh-CN,zh;q=0.9,en;q=0.8,zh-HK;q=0.7\",&#125; 请求头信息 | 字段 | 含义 || ————— | ———————————————————— || Accept | 浏览器能够处理的内容类型 || Accept-Charset | 浏览器能够显示的字符集 || Accept-Encoding | 浏览器能够处理的压缩编码 || Accept-Language | 浏览器当前设置的语言 || Host | 发出请求的页面所在域 || Referer | 发送请求页面的url || Cookie | 当前页面设置的任何cookie || Connection | 浏览器与服务器之间的连接类型,Connection : Keep-Alive 功能避免了建立或者重新建立连接, 超过5秒建立新的连接， 最大请求100次, connection: ‘keep-alive, timeout = 5,max = 100’ || User-Agent | 浏览器类型字符串 | 响应头信息 expires 和 cache-control : max-age = 1000 与缓存有关， expires 是一个过期日期， max-age是时长， 二者可以相互推算 | 响应头 | 解释 || ———————— | ———————————————————— || Allow | 服务器支持哪些请求方法（如GET、POST等） || Content-Encoding | 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。 || Content-Length | 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。 || Content-Type | 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。 || Date | 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 || Expires | 应该在什么时候认为文档已经过期，从而不再缓存它 || Last-Modified | 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 || Location | 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 || Refresh | 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。 || Server | 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 || Set-Cookie | 设置和页面关联的Cookie。 || WWW-Authenticate | 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 。 || Etag | 是资源的特定版本识别符, 可以让缓存更高效,如果没有改变, web服务器不需要发送完整的响应. 例如 ETag : “33a64df551425fcc55e4d42a148795d9f25f89d4” || Cache-Control : no-cache | 缓存设置时间 | http 状态 常用状态码 | status code | information || ———– | ———————————————- || 200 | 请求成功 || 201 | 已创建, 请求成功并且服务器创建了新资源 || 202 | 已接受, 服务器已接受请求, 但尚未处理 || 304 | 未修改 || 301 | 永久移动 || 302 | 临时移动 || 400 | 参数错误 || 401 | 请求未授权 || 403 | 拒绝访问 || 404 | 地址不存在 || 405 | 客户端请求中的方法被禁止（一般是请求方式错误） || 500 | 服务器报错 || 501 | 尚未实施, 服务器还不存在请求功能 || 502 | 请求超时，无效网关 || 503 | 服务器超载或者维护，无法响应 | 全部请求头 | status code | information || ———– | ——————————- || 100 | continue || 101 | switching protocols || 102 | processing || 200 | ok || 201 | created || 202 | accepted || 203 | non-authoritative information || 204 | no content || 205 | reset content || 206 | partial content || 207 | multi-status || 208 | already reported || 226 | im used || 300 | multiple choices || 302 | found || 303 | see other || 304 | not modified || 305 | use proxy || 307 | temporary redirect || 308 | permanent redirect || 400 | bad request || 401 | unauthorized || 402 | payment required || 403 | forbidden || 404 | not found || 405 | method not allowed || 406 | not acceptable || 407 | proxy authentication required || 408 | request timeout || 409 | conflict || 410 | gone || 411 | length required || 412 | precondition failed || 413 | payload too large || 414 | uri too long || 415 | unsupported media type || 416 | range not satisfiable || 417 | expectation failed || 418 | I’m a teapot || 422 | unprocessable entity || 423 | locked || 424 | failed dependency || 426 | upgrade required || 428 | precondition required || 429 | too many requests || 431 | request header fields too large || 500 | internal server error || 501 | not implemented || 502 | bad gateway || 503 | service unavailable || 504 | gateway timeout || 505 | http version not supported || 506 | variant also negotiates || 507 | insufficient storage || 508 | loop detected || 510 | not extended || 511 | network authentication required |","categories":[],"tags":[]},{"title":"Linux 使用参考","slug":"Linux","date":"2018-08-30T06:06:18.701Z","updated":"2018-10-01T15:00:39.972Z","comments":true,"path":"2018/08/30/Linux/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Linux/","excerpt":"","text":"linux 关于linux 系统 的基本概念和操作总结 目录[TOC] 文件结构 目录 描述 / 主层次 的根，也是整个文件系统层次结构的根目录 /bin 存放在单用户模式可用的必要命令二进制文件，所有用户都可用，如 cat、ls、cp等等 /boot 存放引导加载程序文件，例如kernels、initrd等 /dev 存放必要的设备文件，例如/dev/null /etc 存放主机特定的系统级配置文件。 /etc/opt 存储着新增包的配置文件 /opt/. /etc/sgml 存放配置文件，比如 catalogs，用于那些处理SGML(译者注：标准通用标记语言)的软件的配置文件 /etc/X11 X Window 系统11版本的的配置文件 /etc/xml 配置文件，比如catalogs，用于那些处理XML(译者注：可扩展标记语言)的软件的配置文件 /home 用户的主目录，包括保存的文件，个人配置，等等 /lib /bin/ 和 /sbin/中的二进制文件的必需的库文件 /lib&lt;架构位数&gt; 备用格式的必要的库文件。 这样的目录是可选的，但如果他们存在的话肯定是有需要用到它们的程序 /media 可移动的多媒体(如CD-ROMs)的挂载点。(出现于 FHS-2.3) /mnt 临时挂载的文件系统 /opt 可选的应用程序软件包 /proc 以文件形式提供进程以及内核信息的虚拟文件系统，在Linux中，对应进程文件系统（procfs ）的挂载点 /root 根用户的主目录 /sbin 必要的系统级二进制文件，比如， init, ip, mount /srv 系统提供的站点特定数据 /tmp 临时文件 (另见 /var/tmp). 通常在系统重启后删除 /usr 二级层级存储用户的只读数据； 包含(多)用户主要的公共文件以及应用程序 /usr/bin 非必要的命令二进制文件 (在单用户模式中不需要用到的)；用于所有用户 /usr/include 标准的包含文件 /usr/lib 库文件，用于/usr/bin/ 和 /usr/sbin/中的二进制文件 /usr/lib&lt;架构位数&gt; 备用格式库(可选的) /usr/local 三级层次 用于本地数据，具体到该主机上的。通常会有下一个子目录, 比如, bin/, lib/, share/. /usr/local/sbin 非必要系统的二进制文件，比如用于不同网络服务的守护进程 /usr/share 架构无关的 (共享) 数据. /usr/src 源代码，比如内核源文件以及与它相关的头文件 /usr/X11R6 X Window系统，版本号:11，发行版本：6 /var 各式各样的（Variable）文件，一些随着系统常规操作而持续改变的文件就放在这里，比如日志文件，脱机文件，还有临时的电子邮件文件 /var/cache 应用程序缓存数据. 这些数据是由耗时的I/O(输入/输出)的或者是运算本地生成的结果。这些应用程序是可以重新生成或者恢复数据的。当没有数据丢失的时候，可以删除缓存文件 /var/lib 状态信息。这些信息随着程序的运行而不停地改变，比如，数据库，软件包系统的元数据等等 /var/lock 锁文件。这些文件用于跟踪正在使用的资源 /var/log 日志文件。包含各种日志。 /var/mail 内含用户邮箱的相关文件 /var/opt 来自附加包的各种数据都会存储在 /var/opt/. /var/run 存放当前系统上次启动以来的相关信息，例如当前登入的用户以及当前运行的daemons(守护进程). /var/spool 该spool主要用于存放将要被处理的任务，比如打印队列以及邮件外发队列 /var/mail 过时的位置，用于放置用户邮箱文件 /var/tmp 存放重启后保留的临时文件 操作mac os下载软件1brew install tree tree 树形目录12# 列出当前文件夹下两层目录结构tree -L 2 #####tldr 命令手册 1234567891011tldr chmod# returnsChange the access permissions of a file or directory.- Give the [u]ser who owns a file the right to e[x]ecute it: chmod u+x file- Give the user rights to [r]ead and [w]rite to a file/directory: chmod u+rw file...... script 记录命令行回话1script autojump 一键跳转12 软件源配置文件123456# 文件名/etc/apt/sources.list# 文件内容 code 为系统版本代号 ubuntu 14 为 trusty， ubuntu 16 为 xenial ,ubuntu 17 为 artful ， ubuntu 18为 bionicdeb http://nginx.org/packages/debian/ codename nginxdeb-src http://nginx.org/packages/debian/ codename nginx find 查找文件12345# 在etc文件夹下查找名为 nginx.conf 的文件find /etc -name nginx.conf# 在根目录/下查找名为usr的文件夹find / -name usr -type d grep 文本搜索12345678910grep /regExp/ fileName [options]# 显示所有以d开头的文件中包含 test的行grep ‘test’ d*# 显示在aa，bb，cc文件中匹配test的行。$ grep ‘test’ aa bb cc# 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。$ grep ‘[a-z]\\&#123;5\\&#125;’ aa traceroute 网络测速 拓扑结构 tarceroute 可以列出分组经过的路由节点, 计算并返回每一跳的延时 1traceroute bing.com chown 改变文件/文件夹所有者123# 把software文件夹拥有者改为pi# 首个pi为用户 必选, 第二个为可选用户组chown -R pi:pi Software pwd 显示当前路径1pwd ln 创建软连接1ln -s /usr/node/bin/node /usr/local/bin/node man 显示命令细节指示1man ls, man sudo 新建并执行shell文件123touch demo.shchmod +x demo.sh./demo.sh #执行 echo 写入文件1echo \"aaaa\" &gt; foo.txt top 按cpu用量查看进程1234top -o cpu# 杀死进程 2200 为进程idsudo kill -9 2200 lsof 按端口占用查看进程1234# 查看3000端口对应的进程lsof -i :3000kill -9 pid ssh连接服务器123456789101112131415161718192021222324252627# 登录ssh username@ipAddress# 登出logout# 重启sudo rebootsudo init 6# 关机sudo power offsudo init 0# 编辑ssh配置文件vim /etc/ssh/sshd_config# 设置 sshd_config 文件的客户端链接时长,心跳# 增加下列字段# 1、客户端每隔多少秒向服务发送一个心跳数据# 2、客户端多少秒没有相应，服务器自动断掉连接ClientAliveInterval 30ClientAliveCountMax 86400# 重启sshd服务service sshd reload 标准流12345678# 向info.log文件写入 1234 , 1代表标准输出流echo 1234 1&gt;info.log# 输出错误流 2 代表标准错误流node error.js 2&gt;error.log# error.jsconsole.error('there is an error') scp从服务器上传/下载文件 ftp默认端口 22 1234567891011# 从服务器向本地下载文件scp username@ip:/remotePath/folterName/fileName /localPath/folderName# 从本地向服务器上传文件scp /localPath/folderName/fileName username@ip:/remotePath/folderName# 从服务器下载目录scp -r username@ip:/remotePath/folderName /localPath/# 将整个目录同步到服务器scp -r /localPath/folderName username@ip:/remotePath/folderName 注册开机启动程序 使用 upstart 或者 systemd , 取决于你的系统使用的哪种服务管理 systemd 命令行工具 systemctl 12345# 查看systemctl 版本systemctl --version# 增加配置文件touch /etc/systemd/system/nodeserver.service Create the service file nodeserver.service 123456789101112131415161718192021[Unit]Description=Node.js Example Server#Requires=After=mysql.service # Requires the mysql service to run first[Service]ExecStart=/usr/bin/node /opt/nodeserver/server.js# Required on some systems#WorkingDirectory=/opt/nodeserverRestart=always# Restart service after 10 seconds if node service crashesRestartSec=10# Output to syslogStandardOutput=syslogStandardError=syslogSyslogIdentifier=nodejs-example#User=&lt;alternate user&gt;#Group=&lt;alternate group&gt;Environment=NODE_ENV=production PORT=1337[Install]WantedBy=multi-user.target enable the service 1systemctl enable nodeserver.service start the service 1systemctl start nodeserver.service verify it’s running 1systemctl status nodeserver.service upstart 1 其他软件配置nginxnginx默认静态html目录 /usr/share/nginx/html 配置文件 / etc/nginx/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#运行用户user nobody;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志及PID文件#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;#工作模式及连接数上限events &#123; #epoll是多路复用IO(I/O Multiplexing)中的一种方式, #仅用于linux2.6以上内核,可以大大提高nginx的性能 use epoll; #单个后台worker process进程的最大并发链接数 worker_connections 1024; # 并发总数是 worker_processes 和 worker_connections 的乘积 # 即 max_clients = worker_processes * worker_connections # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4 为什么 # 为什么上面反向代理要除以4，应该说是一个经验值 # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000 # worker_connections 值的设置跟物理内存大小有关 # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数 # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右 # 我们来看看360M内存的VPS可以打开的文件句柄数是多少： # $ cat /proc/sys/fs/file-max # 输出 34336 # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内 # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置 # 使得并发总数小于操作系统可以打开的最大文件数目 # 其实质也就是根据主机的物理CPU和内存进行配置 # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。 # ulimit -SHn 65535&#125;http &#123; #设定mime类型,类型由mime.type文件定义 include mime.types; default_type application/octet-stream; #设定日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off， #以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; #开启gzip压缩 gzip on; gzip_disable \"MSIE [1-6].\"; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; #设定虚拟主机配置 server &#123; #侦听80端口 listen 80; #定义使用 www.nginx.cn访问 server_name www.nginx.cn; #定义服务器的默认网站根目录位置 root html; #设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; #默认请求 location / &#123; #定义首页索引文件的名称 index index.php index.html index.htm; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #过期30天，静态文件不怎么更新，过期可以设大一点， #如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ .php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; &#125;&#125; vim 强行退出不保存修改 ctrl + c =&gt; :q! 解压文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.tar 解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.tar.xz解压：tar -Jxvf FileName.tar.xz压缩：tar -Jcvf FileName.tar.xz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName———————————————.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知———————————————.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z———————————————解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -","categories":[],"tags":[]},{"title":"Express —— nodejs开发框架总结","slug":"Express","date":"2018-08-30T06:06:18.700Z","updated":"2018-10-01T14:58:29.262Z","comments":true,"path":"2018/08/30/Express/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Express/","excerpt":"","text":"Express 介绍了express 框架的搭建， 配置， 简单使用和扩展用法 目录[TOC] 快速使用 下载生成器 1npm i -g express-generator 12345678910111213141516171819202122232425262728var express = require('express')var path = require('path')var app = express()// 应用中间件app.use(express.static(path.join(__dirname, 'www/')))app.use((req, res, next) =&gt; &#123; &#125;)app.get('/',(req, res) =&gt; &#123; res.end('hello')&#125;)// 挂载多个中间件函数app.get('/', fn1, fn2, fn3) app.listen(3000)// 定义路由var users = express.Router()users.get('/', fn)users.get('/home', fn)// 自定义路径router.get('/:name', function (req, res) &#123; res.send('hello, ' + req.params.name)&#125;)app.use(users) API express express() 返回一个服务器对象实例 1const app = express() express.static(dirname) 设置express服务器静态目录 1app.use(express.static(`$&#123;__dirname&#125;/static`)) http.createServer(app) http 代理express服务器 1http.createServer(app).listen(3001) app app.locals 保存本地变量 1app.locals.title = 'my title' app.delete() 删除 路由, 中间件 123app.delete('/', function (req, res) =&gt; &#123; res.send('delete request to home page') &#125;) app.use(path, fn) 使用中间件 1234567891011121314151617181920212223// 全局使用app.use((req, res, next) =&gt; &#123; // 设置状态码和响应头 res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;) // 根据不同的url 设置不同的响应体 switch (req.url) &#123; case: '/': res.end('hello world'); break; case: 'doc': res.end('welcome to doc page') break; default: res.end('where are you') &#125; // 调用下一个中间件函数, 不调用next request对象就不再向后传递了 next(); &#125;)// 匹配 '/path'路由调用中间件app.use('/path', (req, res, next) =&gt; &#123;&#125;) app.all(‘*’, fn) 所有请求都经过此方法 123456app.all('*', (req, res, next) =&gt; &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;) next()&#125;) app.get(path, fn), app.post(), app.put(), app.delete … 响应不同请求方法 12345678910111213141516171819202122232425app.get('/home', (req, res) =&gt; &#123;&#125;)app.post('/login', (req, res) =&gt; &#123;&#125;)// put 请求用于上传资源app.put('/logout', (req, res) =&gt; &#123;&#125;)// get 动态匹配app.get('/path/:id', (req, res) =&gt; &#123; res.end(`请求参数是$&#123;req.params.id&#125;`)&#125;)// 参数后加问号表示可选参数app.get('/path/:name?', (req, res) =&gt; &#123; if (req.params.name) &#123; // do something &#125;&#125;)// 匹配多个参数 app.get('/path/:where/who/:name', (req, res) =&gt; &#123; res.end(`path is $&#123;req.params.where&#125;, name is $&#123;req.params.name&#125;`)&#125;) // 匹配正则表达式app.get(/^\\/path\\/(\\w+)(\\.\\.(\\w+))?/, (req, res) =&gt; &#123;&#125;) app.set(key, val) 设置express实例变量 123// 设置模版引擎和模版目录app.set('view engine', 'pug')app.set('views', __dirname + '/views') app.listen(port, [callback]) 监听端口 app.engine(ext, callback) 设置模版引擎 12// 模版引擎设置为pugapp.engine('pug', require('pug').__express) app.path() 返回express实例所对应的路径 12345678const app = express()const doc = express()const blog = express()app.use('/doc', doc)doc.use('/blog', blob)// returns /doc/blogconsole.log(blog.path()) request req.app 对服务器实例app的引用 req.ip 请求的IP地址 req.url 请求的路径 req.files 请求上传的文件 req.method 请求的方法 req.headers 请求头 1req.headers['x-no-compression'] req.params 请求的参数对象 1234app.get('/path/:params/route/:params2', (req, res) =&gt; &#123; &#125;)req.params // returns &#123;params: 123, params2: 345&#125; req.query 请求的查询参数 123let url = 'http://www.test.com/search?q=123&amp;s=456'req.query.q // returns 123req.query // &#123;q: 123, s: 456&#125; req.cookies 12// Cookie: name=tobireq.cookies.name // 'tobi' req.signedCookies 加密的cookie 值 123// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3req.signedCookies.user // tobi req.protocol 返回请求的协议 1req.protocol // 'http' , 'https', '' req.param(‘key’) 获取 get, post 请求参数 123456// get: ?name=tobireq.param('name') // 'tobi'// post: age=16req.param('age') // 16// /user/tobi for /user/:namereq.param('name') // tobi req.is(type) 判断请求类型 123req.is('application/json') // true or falsereq.is('application/*') // true or falsereq.is('text/*') req.get(headerName) 获取请求头信息 1req.get('Contentd-Type') // 'text/html' req.accepts(contentType) 根据请求头 accepts 字段判断 浏览器可以接受的文档类型 12req.accepts('html') // truereq.accepts(['html', 'json']) // true req.acceptsLanguage(lang), req.acceptsCharsets(charset), req.acceptsEncoding(encoding) 判段浏览器可以接受的语言, 字符集, 编码类型 response res.writeHead(statusCode, options) 设置http状态吗和响应头信息 1res.writeHead(200, &#123;'Content-Type': 'text/plain', 'Content-Length': 1234&#125;) res.setHeader(key, value) 设置响应头 1res.setHeader('cache-control': 'max-age=315360000, public, immutable') res.redirect([statusCode], url) 重定向 12res.redirect(301, 'http://www.bing.com')res.redirect('http://www.bing.com') res.sendFile(filePath) 发送文件 1res.sendFile('/path/to/play.mp4'); res.render(templateName, message) 用模版渲染页面 12// 在模版目录里面找到 index 前缀文件, res.render('index', &#123;message: 'hello world'&#125;) res.status(code) 返回状态码 1res.status(500).send('something error') res.send(body) 发送响应体 123res.send('&lt;p&gt;title&lt;/p&gt;')res.send(&#123;some: 'json'&#125;)res.send(new Buffer('hello world')) res.end(body) 发送响应并结束响应 1res.end('&lt;p&gt;this is end&lt;/p&gt;') res.download(path, [filename], [fn]) 下载文件 123456789res.download('/download/file1.pdf')res.download('/download/file2.pdf', 'book.pdf')res.download('/download/file3.pdf', err =&gt; &#123; if (err) &#123; &#125; else &#123; &#125;&#125;) res.cookie(name, value, [opt]) 设置cookie 12res.cookie('name', 'fabi', &#123;domain: '.temp.com', path: '/', secure: true&#125;)res.cookie('rememberme', '1', &#123; expires: new Date() + 1000, httpOnly: true &#125;) res.clearCookie(name, [opt]) 清除cookie 12res.clearCookie('name', &#123;path: '/'&#125;)res.clearCookie() res.format() 格式化输出返回, 配合req.accepts() to select handler for the request 1234567res.format(&#123;&#125;)res.format(&#123; 'text/plain': function () &#123; res.send('hello world') &#125;, 'text/html': function () &#123; res.send('&lt;p&gt;hello world&lt;/p&gt;') &#125;, 'application/json': function () &#123; res.send(&#123;message: 'hey') &#125;&#125;,&#125;) res.type() 控制返回类型 123res.type('html')res.type('png')res.type('application/json') res.json() 返回对象 123res.json(&#123;name: 'float'&#125;)res.json(null)res.status(500).json(&#123; error: 'message' &#125;) express router 简单router 123456789const router = express.Router()router.get('/about', (req, res) =&gt; &#123; res.send('welcome about')&#125;)app.use('/app', router)// url: www.demo.com/app/about router.route 挂载多个方法 123456789const router = express.Router()router.route('/api') .post((req, res) =&gt; &#123; &#125;) .get((req, res) =&gt; &#123; &#125;)&#125;) router.param 对参数进行解析 1234567router.param('name', (req, res, next, name) =&gt; &#123; req.name = name next()&#125;)router.get('/hello/:name', (req, res) =&gt; &#123; res.send(req.name)&#125;) express with https 搭建https服务器 123456789101112const fs = require('fs')const options = &#123; keys: fs.readFileSync('/usr/local/key.pem'), cert: fs.readFileSync('/usr/local/key-cert.pem'),&#125;const https = require('https');const express = require('express')const app = express()let server = https.createServer(options, app)server.listen(3000) Https 证书, 私钥创建 12345# 创建私钥openssl genrsa 1024 &gt; key.pem# 创建证书openssl req -x509 -new -key key.pem &gt; key-cert.pem express middlewarehttp://www.expressjs.com.cn/resources/middleware.html 内置中间件 express.static() 设置静态目录, 存放静态资源 1app.use(express.static(__dirname + '/static')) 第三方中间件 cookie-parser https://github.com/expressjs/cookie-parser 用于解析cookie到, cookie-parser不会对出站cookie做设置, 需要手动调用res.setHeader(‘Set-Cookie’: ‘…’) signedCookie : cookie 在出站时生成一段防篡改验证码 1npm i cookie-parser 1res.setHeader('Set-Cookie', `name=$&#123;xiaoxixi&#125;|$&#123;md5(123454)&#125;`) 123456789const cookieParser = require('cookie-parser')app.use(cookieParser())app.get('/', (req, res) =&gt; &#123; // Cookie: name=xiaoxixi, age=24 console.log(req.cookies) // &#123;name: 'xiaoxixi', age: '24'&#125; // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3 console.log(req.signedCookies) // tobi&#125;) body-parser https://github.com/expressjs/body-parser 处理post请求体 1npm i body-parser 1234567891011const bodyParser = require('body-parser')// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extend: false&#125;))// parse application/jsonapp.use(bodyParser.json())// 或直接使用express 内置函数app.use(express.urlencoded(&#123; extend: false &#125;))app.use(express.json()) cookie-session https://github.com/expressjs/cookie-session session 作为存储在服务器端的标识符, 常常存在于散列中, 通过客户端发送的sessionid来判断会话属于哪个用户 1npm i cookie-session 1234567891011121314151617// cookie-session 设置出站cookie // 例如 Set-Cookie: session=eyJ2aWV3cyI6NH0=; path=/; httponlyconst cookieSession = require('cookie-session')app.use(cookieSession(&#123; name: 'session', keys: ['key1', 'key2'], maxAge: 24 * 60 * 60 * 1000 // one day&#125;))app.get('/', function (req, res, next) &#123; // Update views req.session.views = (req.session.views || 0) + 1 // Write response res.end(req.session.views + ' views')&#125;) compression https://github.com/expressjs/compression 用来压缩响应 1npm i compression 12345678910111213const expression = require('compression')// 压缩所有的响应 需要在添加路由前调用app.use(expression())app.use(compression(&#123;filter: function (req, res) &#123; // 根据请求头 过滤压缩响应 if (req.headers['x-no-compression']) &#123; return false &#125; else &#123; return compression.filter(req, res) &#125;&#125;&#125;)) error-handler https://github.com/expressjs/errorhandler 只在开发环境使用的错误处理中间件, 用于把错误信息返回给客户端 1npm i errorhandler 1234567891011121314const errorhandler = require('errorhandler')const notifier = require('node-notifier')if (process.env.NODE_ENV === 'development') &#123; app.use(errorhandler(&#123; log: function (err, str, req) &#123; let title = 'Error in ' + req.method + ' ' + req.url notifier.notify(&#123; title: title, message: str &#125;) &#125; &#125;))&#125; express-session https://github.com/expressjs/session 创建session 1npm i express-session 123456789101112131415const session = require('session')app.use(session(&#123; cookie: &#123; secure: true , maxAge: 60 * 60 * 1000 * 24&#125;,// 设置过期时间为1天的session secret: 'myapp_sid', resave: false, saveUninitialized: true&#125;))app.use((req, res, next) =&gt; &#123; if (!req.session.views) &#123; req.session.views = &#123;&#125; &#125; req.session.views[req.pathname] = (req.session.views[req.pathname] || 0) + 1 next()&#125;) morgan https://github.com/expressjs/morgan http日志请求中间件 1npm i morgan 123456789101112131415const morgan = require('morgan')const path = require('path')const fs = require('fs')// 把日志存档到日志const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), &#123; flags: 'a'&#125;)app.use(morgan('combined', &#123; stream: accessLogStream, skip: function (req, res) &#123; return res.statusCode &lt; 400 &#125;&#125;)) passport https://github.com/jaredhanson/passport 登录验证 1npm i passport multer https://github.com/expressjs/multer 上传文件 1npm i multer 12345678910const multer = require('multer')const upload = multer(&#123; dest: '/uploads' &#125;)app.post('/profile', upload.single('avatar'), (req, res, next) =&gt; &#123; // req.file is avatar&#125;)app.post('/photos', upload.array('photos', 12), (req, res, next) =&gt; &#123; // req.files is photos &#125;) upload.html 12345&lt;form action=\"/pictures/upload\" method=\"POST\" enctype=\"multipart/form-data\"&gt; Select an image to upload: &lt;input type=\"file\" name=\"image\"&gt; &lt;input type=\"submit\" value=\"Upload Image\"&gt;&lt;/form&gt; serve-favicon https://www.npmjs.com/package/serve-favicon 处理浏览器请求站点小图标 1npm i serve-favicon 1234const favicon = require('serve-favicon')const path = require('path')app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))) cors https://github.com/expressjs/cors 处理跨域请求 1npm i cors 123456789const cors = require('cors')// 允许全部请求跨域app.use(cors())// 允许制定路由跨域app.get('/cors', cors(), (req, res) =&gt; &#123; res.status(201).end('hello world')&#125;) method-override https://github.com/expressjs/method-override 支持你在没有put delete的浏览器上使用这些方法 1npm install method-override 12const methodOverride = require('method-override')app.use(methodOverride('X-HTTP-Method-Override')) http-errors https://github.com/jshttp/http-errors 创建错误的http响应 1npm i http-errors 1234567const httpErrors = require('http-errors')app.use((req, res, next) =&gt; &#123; if (!req.user) &#123; return next(httpErrors(401, 'please login first')) &#125; next()&#125;) debug 启动调试 12345# on mac$ DEBUG=express:* node server.js# on windowsset DEBUG=express:* &amp; node server.js Dev &amp; Ops forever | supervisor 开发环境 node 进程刷新 pm2 生产环境node 程序 重启 12345678910111213141516171819202122232425npm i -g pm2# 启动node程序pm2 start app.js# 手动分配四个cluster数量启动node进程pm2 start app.js -i 4# 默认启动最大进程数pm2 start app.js -i max# 列出pm2的进程列表pm2 list# 根据id停止进程pm2 stop 0# 重启pm2 restart 0# 显示 进程 0 的详细信息pm2 show 0# 从列表删除pm2 delete 0 upstart 系统进程管理工具 12345678# downloadsudo apt install upstart# 修改配置文件 必须位于/etc/init/ 目录下sudo touch /etc/init/autonode.conf# 启动程序sudo service autonode systemd 系统进程管理工具2 12345systemctl --versiontouch /etc/systemd/system/autonode.servicevim /etc/systemd/system/autonode.service autonode.service 123456789101112131415161718192021[Unit]Description=Node.js Example Server#Requires=After=mysql.service # Requires the mysql service to run first[Service]ExecStart=/usr/bin/node /opt/nodeserver/server.js# Required on some systems#WorkingDirectory=/opt/nodeserverRestart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Output to syslogStandardOutput=syslogStandardError=syslogSyslogIdentifier=nodejs-example#User=&lt;alternate user&gt;#Group=&lt;alternate group&gt;Environment=NODE_ENV=production PORT=1337[Install]WantedBy=multi-user.target hellonode.conf 1234567891011author \"float\" # 指定作者description \"hellonode\" # 程序的名称或描述setuid \"nonrootuser\" # 用nonrootuser用户运行程序start on (local-filesystems and net-device-up IFACE=eth0) # 在文件系统和网络可用时启动程序stop on shutdown # 关机时停止respawn # 程序崩溃时停止(默认5秒10次)respawn limit 20 5 # 设置为5秒内重启20次, 如果崩溃的话console log # 将 stdin 和 sterr 输出到 /var/log/upstart/hellonode.logenv NODE_ENV=production # 设置环境变量exec pm2 start app.js -i 4 # 启动的脚本命令","categories":[],"tags":[]},{"title":"web前端常用库收录","slug":"Webfront-library","date":"2018-08-28T15:01:21.721Z","updated":"2018-09-29T16:40:02.134Z","comments":true,"path":"2018/08/28/Webfront-library/","link":"","permalink":"http://zexiplus.github.io/2018/08/28/Webfront-library/","excerpt":"","text":"webfront js library前端javascript 仓库收录 Table of content[TOC] Jquery $el.append(a) 在el元素内部末尾添加元素a, 原生dom操作为el.appendChild(a) $el.prepend(a) 在el元素内部开头添加元素a, 原生dom操作为el.insertBefore(a, el.firstChild) crypto.jshttps://github.com/sytelus/CryptoJS CryptoJS是一个纯javascript写的加密类库，目前支持MD5，SHA-1，SHA-256，AES，Rabbit，MARC4，HMAC，HMAC-MD5，HMAC-SHA1，HMAC-SHA256，PBKDF2","categories":[],"tags":[]},{"title":"web前端工程化工具 webpack 重点突破","slug":"Webpack","date":"2018-08-27T02:21:31.574Z","updated":"2018-10-27T17:08:57.711Z","comments":true,"path":"2018/08/27/Webpack/","link":"","permalink":"http://zexiplus.github.io/2018/08/27/Webpack/","excerpt":"","text":"webpack 学习总结目录[TOC] 开始 Download 1npm i -g webpack@3.6.0 读取参数使用webpack 1webpack ./entry.js ./output.js 读取配置文件使用 webpack package.json 1234&#123; \"dev\": \"webpack --config ./webpack.dev.config.js\", \"build\": \"webpack --config ./webpack.prod.config.js\"&#125; 配置文件结构 webpack.config.js 123456789101112131415161718192021222324252627const path = require('path')const WebpackHtmlPlugin = require('webpack-html-plugin')module.exports = &#123; // 入口文件 可多个, main 名可自定义 entry: &#123; 'main': './main.js' &#125;, // 产出文件 output: &#123; // 指定产出文件目录 path: path.resolve('./dist') filename: './build.js' &#125;, // 监视文件 入口文件变化时自动构建 watch: true, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html' // 参照物, 把生成的js文件插入此文件 &#125;), ] &#125; entry @Object 入口文件 output @Object 出口文件 watch @布尔 是否自动化构建 module @对象 模块 plugins @数组 插件, 插件的执行顺序与索引有关 loader 加载器在js文件中加载css, img等文件!感叹号用于分割 loader, ? 问号用于传参 样式表加载器 style-loader, css-loader, less-loader main.js 1import './main.css' webpack.config.js 1234567modeule.exports = &#123; module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;&#125; 图片加载器 url-loader limit 限制图片大小, 单位b main.js 1import img from './pic.jpg' 12345678910modeule.exports = &#123; module: &#123; loaders: [ &#123; // 图片超过1kb会被生成 一个 1kb的图片, 如果小于1kb, 会被生成base64编码的文件 test: /\\.(jpg|png|gif|svg)$/, loader: 'url-loader?limit=1000' &#125; ] &#125;&#125; ES67转译加载器 babel-loader 12345678910111213modeule.exports = &#123; module: &#123; loaders: [ &#123; // 图片超过1kb会被生成 一个 1kb的图片, 如果小于1kb, 会被生成base64编码的文件 test: /\\.js$/, loader: 'babel-loader', options: &#123; exclude: /node_modules/, // 排除node_modules文件夹 presets: ['env'], // 处理es6关键字 plugins: ['transform-runtime'] // 处理函数 &#125; &#125; ] &#125;&#125; vue-loader 1234567module.exports = &#123; module: &#123; loaders: [ &#123;test: /\\.vue$/, loader: 'vue-loader'&#125; ] &#125;&#125; plugins 插件 webpack-dev-server 1webpack-dev-server --open --hot --config ./webpack.dev.config.js –open 自动打开浏览器 –hot 热替换, 不刷新的情况下替换 –inline 自动刷行 –port 9999 定制端口 – process 显示编译进度 html-webpack-plugin 自动注入插件","categories":[],"tags":[]},{"title":"web前端工程师技能树","slug":"SkillTree","date":"2018-08-21T02:16:26.507Z","updated":"2018-09-29T16:36:59.659Z","comments":true,"path":"2018/08/21/SkillTree/","link":"","permalink":"http://zexiplus.github.io/2018/08/21/SkillTree/","excerpt":"","text":"skill tree 前端技能树 主流web前端所需掌握的前端技能树 javascript 闭包 this指向 双向绑定原理与实现(数据劫持与代理) 如何调试node程序 如何优化js性能 css 如何扩展css功能 高清方案, vw支持方案 动画性能优化 算法 如何计算时间/空间复杂度 动态规划的理解与运用 框架/选型 react/vue 选型分析(jsx模版语法, 单双数据绑定, 成员交接成本, 扩展性等各项属性对比) react/vue 优化方式 构建 webpack 多页面架构可能遇到的问题 webpack 代码分隔方式 webpack 性能及提速方案 webpack 缓存存在的问题及解决方案 webpack 插件原理","categories":[],"tags":[]},{"title":"Javascript","slug":"javascript","date":"2018-08-13T09:06:58.226Z","updated":"2018-10-09T09:38:32.087Z","comments":true,"path":"2018/08/13/javascript/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/javascript/","excerpt":"","text":"Javascript javascript 常用知识点总结 Table of Contents[TOC] Skill 求值表达式 (0, vald) 1234let obj = &#123;a: 1, b: function() &#123;console.log(this.a)&#125;&#125;obj.b() // returns 1(0, obj.b)() // returns undefined(obj.b)() // returns 1 返回值函数 bind 123456// bad return function() &#123; return sum(5, 1)&#125;// goodreturn sum.bind(5, 1) arguments 与箭头函数 12345// arguments 不可以在箭头函数中使用，不存在(...rest) =&gt; &#123; console.log(arguments) // undefined console.log(rest) // 使用rest数组代替arguments&#125; Object.isExtensible() &amp; Object.preventExtensions() 1234let a = &#123;&#125;Object.isExtensible(a) // expected : trueObject.preventExtensions(a)Object.isExtensible(a) // expected: false Object.getOwnPropertyDescriptor(obj, prop) 123let obj = &#123;get a() &#123; return 1 &#125;&#125;Object.getOwnPropertyDescriptor(obj, 'a')// return &#123;get: ƒ, set: undefined, enumerable: true, configurable: true&#125; 蹦床函数 trampoline 蹦床函数（把递归函数转化为循环的函数，防止调用栈过多造成 maximum call exceed 错误） 123456const trampoline = (f) =&gt; &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f() &#125; return f&#125; string.LocaleCompare() 比较字符顺序, sort()默认使用字符的asicii码比较, 会导致不是按a-z顺序, 使用 localeCompare比较顺序 1234['único','árbol', 'cosas', 'fútbol'].sort(function (a, b) &#123; return a.localeCompare(b);&#125;);// [\"árbol\", \"cosas\", \"fútbol\", \"único\"] ##Class javascript class Number toFixed 固定小数位数 16.12333.toFixed(2) // 6.12 parseInt, Number 转化字符串为数字 123let num = '123%'parseInt(num, 10) // 123Number(num) // NaN String match方法 把字符串中匹配模式的的字符串组成数组并返回 相当于 regexp的exec方法 12let arr = 'dog yellow green bat cat dat'.match(/.at/)// arr =&gt; ['bat', 'cat', 'dat'] replace替换 12'a-b-c-d'.replace('-', ':') // 'a:b-c-d''a-b-c-d'.replace(/-/g, ':') // 'a:b:c:d' 遍历字符串 1234for (let letter of 'abc') &#123; console.log(letter)&#125;// 'a' 'b' 'c' includes 方法 判断给定字符串是否包含字符 12String.prototype.includes(searchString[, position])// true or false substring 方法 截取字符串 12// 截除首字符str.substring(1) startsWith, endWith 判断字符串开头, 结尾 12'hello world'.startsWith('hel') // true'hello world'.endsWith('orld') // true RegExp test 判断字符串时候匹配 1/a/.test('abc') // true Array Array.from 把类数组转化为数组 123456const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo);// 去重Array.from(new Set(array))[... new Set(array)] … 合并数组 123var a = [1,3,3]var b = [4]var c = [...a,...b] 变量交换 12let a = 1, b = 2;[a, b] = [b, a] find 找到并返回第一个true的值 12[1,2,3,4].find(item =&gt; item &gt; 2)// 3 Object {a} 解构赋值 12345let &#123;a, b, c&#125; = &#123;a: 1, b: 2, c: 3&#125;console.log(a) // 1let &#123;a: animal&#125; = &#123;a: 1, b: 2, c: 3&#125;console.log(animal) // 1 Object.assign 对象浅拷贝, 只修改了对象的原型链, 并没有真正复制属性值 1234let obj = &#123;a: 1, b: 2, c: 3&#125;let extendObj = Object.assign(obj, &#123;d: 4&#125;) // &#123;a: 1, b: 2, c: 3, d: 4&#125;delete obj.aextendObj // &#123;b: 2, c: 3, d: 4&#125; Function rest 剩余参数 123456789function add(...rest) &#123; let sum = 0; for (var val of rest) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 解构赋值&amp;默认参数 12345678910111213141516function demo(&#123;x = 666, y&#125; = &#123;&#125;) &#123; return console.log(console.log(x, y));&#125;// 传undefined 会触发默认效果， null则不会demo(&#123;&#125;) == demo() // 666, undefineddemo(&#123;x: 7, y: 8&#125;) // 7, 8demo(&#123;x: undefined, y: 8&#125;) // 666, 8demo(&#123;x: null, y: 8&#125;) // null, 8let ajax = function(url, option = &#123; crossDomain : false, transformJson : true&#125;) &#123; console.log(option.crossDomain,option.transformJson)&#125;let ajax2 = function(url, &#123; crossDomain = false, transformJson = true&#125;) &#123; console.log(crossDomain, transformJson)&#125; generator 生成器函数 123456789function* sayHello() &#123; yield 'hello1'; yield 'hello2'; return 'end'&#125;var helloGenerator = sayHello();helloGenerator.next() // returns &#123;value: 'hello1', done: false&#125;;helloGenerator.next() // returns &#123;value: 'hello2', done: false&#125;;helloGenerator.next() // returns &#123;value: 'end', done: true&#125;; Iterator 迭代器函数 123var person = &#123;name: 'xiaoxixi', age: 24&#125;;var iterator = new Iterator(person);iterator.next() // returns ['name', 'xiaoxixi']; JSON JSON.stringify(obj, filter, space) obj 为需要格式的对象， filter为函数或数组， space为空格缩进 123let obj = &#123;a: 1, b: 2, c: 3&#125;let str1 = JSON.stringify(obj, ['a', 'b'], 4)// str1 =&gt; &#123;a: 1, b: 2&#125; Date date.toLocaleDateString() 转化为当地时间字符串 12new Date().toLocaleDateString()// 9/16/2018 date.toDateString() 12new Date().toDateString()// \"Sun Sep 16 2018\" date.toLocaleTimeString() 12new Date().toLocaleTimeString()// 11:30:22 AM Math Math.pow 基数的n次方 1Math.pow(4, 2) // 16 ES6 Decorator 123456789101112131415161718192021// 装饰器修饰类 @decoratorclass MyClass() &#123; &#125;function decorator(target) &#123; target.hasDecorator = true; target.prototype._number = 0;&#125;MyClass.hasDecorator // truenew MyClass()._number === 0 // true// 装饰器修饰类的属性class MyClass2() &#123; @readonly name() &#123; return 'xiaoxixi' &#125;&#125;function readonly(target, name, descriptor) &#123; descriptor.writable = false; return descriptor&#125; Promise123456// 手动将promise转化为失败态 reject()Promise.reject(\"Testing static reject\").then(function(reason) &#123; // 未被调用&#125;, function(reason) &#123; console.log(reason); // \"Testing static reject\"&#125;); new webApi requestAnimationFrame 12345678910/************ js动画 以60hz调用函数得函数 requestAnimationFrame **********/requestAnimationFrame(function (timeStack) &#123; // 接受一个函数作为参数，这个函数得参数为一个 date 对象，代表当前函数运行时的时间戳&#125;)somethingAnimation() &#123; el.style.width = `$&#123;parseInt(el.style.width, 10) + 1&#125;%`; // 每一帧的操作 if(something) &#123; // 根据判断条件调用下一帧动画 requestAnimationFrame(somethingAnimation) &#125;&#125; FileReader 123456789/************* 文件读取构造函数 构造函数 FileReader *************************/&lt;input type=\"file\" id=\"fileUp\"&gt;document.addEventListener(document.querySelector('#fileUp'), 'change', function(e) &#123; var reader = new FileReader(); reader.readAsDataURL(e.target.files[0]); reader.onload = function() &#123; someDom.innerHTML = `&lt;img src=\"$&#123;reader.result&#125;\" /&gt;` &#125;&#125;) RAM URL 12345678/********* 对象URL window.URL.createObjectURL() *******************/var objUrl = window.URL.createObjectURL(e.target.files[0]); //指向一块内存地址someDom.innerHTML = `&lt;img src=\"$&#123;objUrl&#125;\" /&gt;`/*********** xhr 上传文件 构造函数 FormData ******************/var data = new FormData();data.append('file',e.target.files[0]);xhr.send(data) Web worker 1234567891011121314151617/*********** Web Worker 多线程对象 ***********/var worker = new Worker('sort.js')var arr = [68,66,89,32,18]worder.onmessage = function(event) &#123; var data = event.data; console.log('sorted array is', data)&#125;worker.postMessage(arr)// sort.js 文件self.onmessage = function(event) &#123; var data = event.data; data.sort(function(a, b) &#123; return a - b &#125;) self.postMessage(data)&#125; Html5 notification API 1234567var myNotify = new Notification('标题', &#123; body: '这是正文内容'&#125;)myNotify.onclick = function () &#123; console.log('消息被点击')&#125; others comment specification 12345678// 函数（sublime快捷键 /** + 回车） /** * 数据格式化 * @param src &#123;Array&#125; 长度自由的一维数组，子元素为json对象 * @param data &#123;Object&#125; 参考数据 * @ignore created 2013-10-11 * @return result &#123;Array&#125; 返回格式化后与src类型相同的数组 */","categories":[],"tags":[]},{"title":"web前端程序员必备单词,短语,简称收录","slug":"Word","date":"2018-08-13T09:06:58.223Z","updated":"2018-09-29T16:41:12.184Z","comments":true,"path":"2018/08/13/Word/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/Word/","excerpt":"","text":"term abbr full explain SSO Single Sign O 单点登录 CAS Central Authentication Service 中心授权服务 DAO data access object 数据访问对象 ISP Internet Service Provider 互联网服务提供商 FCC Federal Communications Commission 美国联邦通信委员会 PR pull request 提交请求 LPWA low power wide area A/B test 网站更新了新UI，统计用户是否更喜欢新页面。定义之前的页面为A，新页面为B，一半用户会被重定向至B， 统计下通过A/B页面到达网站内页的用户占的百分比是多少。 UX User expreience 用户体验 GR graceful degradation 优雅降级, 先从最主流的浏览器实现,再回头兼容老版本浏览器,修复bug PE progressive enhancement 渐进增强, 先从最基本的功能做起, 保证高度的兼容性, 逐渐迭代复杂功能 FAQ Frequently asked question 常见问题 TCP Transmisssion control protocol 传输控制协议 负责在不可靠的传输信道上提供可靠的抽象层 IP internet Protocol 因特网协议 SSR server side render 服务端渲染 Prefix &amp; suffix pre 预先 de 反 re 重复 words intersect 相交 deprecated 弃用 Interaction 交互 detailed below 详细如下 conjunction 连词 trend 趋势 category 类别 stacked 堆叠 Indicates 指示 emulate 仿真 ​ wildcard 通配符 credentials 证书 innovations 创新 rapidly 急速 delivering 交付 cuttingedge 前沿 insight 眼光 gains 收益 snippet 片段 causal 因果 ​ consistency 一致性 guarantees 担保 sequential 顺序 secondary 次要 manipulations 操作 proper 适当的 omitted 省略 inferred 推断 pulse 脉冲 amend 修改 ​ proposal 提议，提案 interoperability 互通性 assess 评估 catalogue 目录 brewing 酿造，混合 custom operators 自定义操作符 nutshell 简而言之 extracts 摘录 subsequent 随后的 recognition 识别 Violations 违规 thermal 热 anomalies 异常 unparalleled 空前的 distributed 分布式 hood 罩子 leverage 杠杆 firmata 签约 repetition 重复 interprets 解释 ​ plural 复数的 gotcha 疑难杂症 visionary 空想家 forerunner 先行者 shrink 收缩 unattended 无人值守的 alternate 备用的 deploy 部署 sparse 稀疏 migrate 迁移 ​ ultimate 终极的,最终的 abstraction 抽象化 conformant 符合 aggregation 聚合 advanced 高级的 shield 保护 brake 制动 spinner 微调 poles 极 voltage 电压 ​ satisfies 满足 ultrasonic 超声的 Infrared 红外线 compress 压缩 hung up 挂了 optimize 优化 vibrant 充满活力的 capacity 容量 archive 档案 thread 线程 ​ synchronized 同步 aggregate 合集 bulk 大批 minifier 缩小器 mangle 损坏 discriminator 鉴别 distinct 不同 legacy point 遗留点 spherical 球形 deliberately 故意 ​ complex 复杂 contraption 玩意儿 domino 多米诺骨牌 inventor 发明者 insurance 保险 retirement 退休 grid 格子 exceeds 超过 concepts 概念 legend 说明 ​ logarithmic 对数的 regarding 关于 plotted 绘制 make sense 合理 overlapping 重叠 composing 构成 nested 嵌套 corresponds 对应 outlet 出口 precedence 优先权 ​ semicolon 分号 quoted 引 introduce 采用，介绍 practice 实践 predictable 可预测 incorrect 不正确的 side effects 副作用 hollow 空心 disallow 不允许 stripped 剥离 ​ syntax 语法 kebab 烤肉串 demand 需求 hassle 争论 comprehensive 全面 specification 规范 manually 手动 masterpiece 杰作 initially 原来 maintain 保持 ​ parentheses 括号 indentation 缩进 assignment 赋值 circulate 循环 unary 一元 Integrating 整合 summary 概要 composed of 由。。。组成 Intuitive 直观的 combine 结合 ​ intermediate 中间 essentially 实质上 arbitrary 随机，随意 dimensional 尺寸的，空间的 Predictor 预报器 Protocol 协议 outperform 表现出色 offloading 卸载 detection 发现 pinned 置顶 ​ consistent 一贯的 toolset 工具集 manipulate 使用，操纵 occasions 场合 notable 显著的 adheres 黏附 semantic 语义 commercially 商业 permissive 宽容 kernel 内核 ​ demonstration 示范 dummy 假的 verbos 动词 coroutine 携程 respectively 分别 illustrated 插图 catalogue 目录 segments 片段 tensors 张量 yield 产生 ​ prior 预先 described 描绘 expert 专家 governance 治理 Steering 掌舵 Technical 技术 Committee 委员会 guidelines 方针 conduct 引导 collaborators 合作者 ​ Initial 初始 consensus 共识 agenda 议程 moderator 主席 dissent 异议 inspector 检查员 manually 手动的 invoked 调用 arch 拱门，拱起 comprehensively 综合 ​ corresponding 相应的 manner 方式 experimental 试验 syscalls 系统调用 underneath 在…下 topic heading 主标题 patch 补丁，打补丁 matures 成熟 proven 证明 Primitive 原始 ​ Terminology 术语 distinguish 区分 cluster 簇 strip 剥夺 Zen 禅 dense 稠密 purity 纯度 ， 纯净 practical 实用的 ambiguity 歧义 Indeterminate 不定的 ​ attachment 附件 duplicate 重复的 mutate 变异 snip 剪断 dump 倾倒 spec 规范 quantity 数量 reproduction 复制 proposal 提议 inventory 库存 ​ delimit 划分界限 as per 按照 batch 批量 degree 学历 caveats 注意事项 enhancement 增强 mimics 模仿 nor 也不 Shebangs 小东西 Interpolation 插值 ​ sponsors 赞助商 orientation 方向 flexibility 灵活性 capabilities 功能 suspends 挂起 decouple 解耦 productivity 生产率 coexist 共存 compose 构写 scene 情景 ​ emphasize 注重 embrace 接受，拥抱 integration of 整合 dramatically 显著的 diverse 多种 fundamental 基础的， 基本原理 indicator 指示符 verbose 详细的 up-to-date最新的 retrieve 取回 ​ ellipse 椭圆 polyline 折线 polygon 多边形 draft 草案 flagged 标记 squash 压扁 rebase 复位，垫底 trampoline 蹦床 factorial 阶乘 detection 发现 ​ constrained 受限，制约 ops 运营 collaboration 合作 rationalizing 合理化 agile 敏捷 legacy applications 传统应用程序 evolve 发展，变化，进化 automate 自动化 investment 投资 ​ rarely 很少 duplex 复式 exclusively 仅仅 retrieved 检索 纠正 挽回 potentially 可能 threshold 阈值 threads 线程 concurrency 并发 contrast 对比 construct 构造 inefficient 低效 ​ scalable 可扩展的 governance 管理 collaborators 合作者 are made collaborators 成为合作者 individuals 个人 invitations 邀请函 significant 重大 identified 确定 particular 特定的 opt 选择 ​ crypto 加密 formula 配方，公式 elevate 提升 architecture 架构 eject 推出 suppress 抑制 represent 表示 synopsis 概要 Manual 手册 truncat 截去 ​ backslashes 反斜线 escape 转义 bounce 反弹, 跳跃 detect 检测 stuff 东西，东东 bunch 大量，簇 miscellaneous 杂 eject 推出 suppress 抑制 represent 表示 ​ synopsis 概要 circuits 电路 sketch 草图 affordable 实惠 schematic 概要 palette 调色板 terms 条款 aspect 方面 primed cache 启动缓存 compile 编译 ​ idiosyncratic 特质 captivating 迷人的 spot 斑点，发现 cords 线 plotter 绘图仪 shafts 轴 massive 海量的 deficits 赤字 bio 个人简历 mandarin 普通话 官话 ​ retweet 转载，转推 transparency 透明度 crooked 扭曲的 numerous 多 terrific 了不起的 stakeholders 利益相关者 pioneering 创举 ban 禁止 tax 税 witch 巫婆 ​ drone 无人机 Avenger 复仇者 flyover 天桥 silk 丝 subsidies 补贴 massive 大规模的 destructive 破坏性的 bycatch 误补 territorial 领土的 hereby 特此 ​ obtaining 获得 council 政务会 nuclear 核 bode 预兆 yup 是的 coated 涂 droplets 液滴 creatures 生物 concise 简洁的 conduct 开展 ​ domestic 国内的 surveillance 监控 contact 联系 gotcha 明白了 spare 剩余的，备用的，空闲的 yeehaw 惊叹词（兴奋的表达） hell 地狱 sufficient 足够 pros 优点 cons 缺点 ​ gauge 衡量 metrics 指标 exception 例外 redundant 冗余 regardless 而不管 accidentally 偶然的 stitch 缝合，拼接 cliffs 悬崖 mechanism 机制 constraints 限制 ​ interferes 干涉 mitigate 缓解 Exceptional 优秀的 idiosyncratic 特质 forgery 伪造 bachelor 学士 teaser 预告 celebrity 名人 contract 合同 periodic 定期 ​ quizzes 测验 labs 实验室 fairness 公平 couple 耦合 cast 投 variance 差异 molest 骚扰 oral 口的 sketches 素描 epic 史诗般的 ​ criteria 标准 supreme 至上的 uphold 维持 except for 除了 racism 种族主义 Estimated 预估 encapsulates 包括包裹 identical 相同，一致 delegate 代表 cascade 及联 performant 高性能的 aka 别名 stale 陈旧的 craft 打造，手艺 Typography 排印，排版 Horizontally 水平的 Vertical 垂直的 slack 偷懒 insomnia 失眠症 discard 抛弃 ​ eliminate 消除 counterpart 副本 demonstrate 演示 curly braces 大括号 dimensions 尺寸，维度 encounter 遇到 portrait 纵向，肖像 portrait mode 竖屏模式 landscape 风景 landscape mode 横屏模式 ​ mockup 模型，样例 realm 领域 Universal 通用 tweak 调整，拧 ultra 超 dedicated 专用的 diagram 图表 Alternatively 另外 boil it down 总结一下 contemplating 考虑 ​ manipulate 操作 versus 相对，与 screw something up 把事情搞砸了 orthogonal to 和…息息相关 overwhelmed 不堪重负，压倒 vast 广大 historical 历史的 lens 镜头 characters 字符 ink 墨水 ​ dip 浸 trendy 新潮 concrete 具体的 conceptual 概念上的 crap 废物 warranted 必要的 decade 十，年代 inevitably 必将 run into 遇到 mass 块 ​ critical 临界 hit critical mass 达到临界质量 wind up 以…结束 multiple 多 intrinsic 固有的 inherent 固有的 complicate 使…复杂 impact 碰撞 illustration 插图 crisply 清晰 ​ fuzzy 模糊 narrow 狭窄 suffix 后缀 scenarios 场景 incognito 匿名的 commerce 商业，商务的 e-commerce 电子商务 measure 测量 subjected 受到 former 前者 ​ get around 绕过 populate 填充 descendant 后代 leeway 余地 Inherit 继承的 pluck 选取 crucial 重要的 coordinate 配合，协作 satellite 卫星 communities 社区 ​ thrive 茁壮成长 mechanics 机制 disposal 处置 era 时代 reduction 减少 decent 正经的，像样的，合适的 audience 听众 premium 额外付费 budget 预算 trade-offs 权衡 ​ Scavenger 清道夫 condensed 精简 generic 通用的 serif 趁线 genuine 真实的 synthesized 综合的 roman 常规的 representative 代表 numerically 数字 monk 和尚 ​ gothic 哥特 cursive 草体，行书 gears 齿轮 amateur 业余 subconscious 潜意识 caption 标题 ligature 连字 nudge 轻推 reserve 保留 twofold 双重 ​ activate 激活 subtle 巧妙的 hyphens 连字符（-） uneven 不均匀的 inviting 诱人的 strips 带子 optimal 最佳的 inconsistent 不一致的 scratch 划破，挠 barely 仅仅 ​ burden 负担 apostrophes 逗号标点 vocabulary 词汇 alter 改变 underlying 底层 disposable 一次性的 tenant 客户，租户 swap 交换 emphasis 重点 extra 额外的，特别 ​ replicate 复制 flat 平坦，简洁 Workbench 工作台 Migration 迁移 Wizard 向导 effectively 实际上 gentler 简洁的 sophisticated 复杂的 thus far 至此 divergence 差异 comes in handy 派上用场 summarize 总结 incorporate 合并，包括 accommodate 适应容纳 conventions 公约 overarching 总体 recursive 递归，逐步 obsolete 过时的 etiquette 礼仪 granular 细粒度 pseudo 伪 armed with 用…武装 presentational 表征的 solely 独自的 equivalent 等同 maintainable 可维护的 alterations 改变 sake of 为了 complications 并发症 stringent 严格 gnarly 复杂，粗糙 frowned upon （皱眉头）不满意 glossed over 轻轻带过 versatile 多才多艺的 interplay 相互作用 installment 部分，分期 fault 故障 generalization 概要 vectors 矢量 scalar 标量 ​ matrices 矩阵，模型 heap 堆 shim 垫片 crack 破解 durable 耐用的 sustainable 可持续发展的 portable 轻便的 discard 放弃 hint 提示 chunk 块 saturate 饱和度 chaos 混沌 keygen 注册机 material 材料 median 中位数 vendor 供应商 vibration 震动 mute 静音,哑巴 simulation 模拟 monotony 单调，乏味 ​ address 解决 reproducible 可复现的 unobtrusive 不显眼的 partial 局部的 coercion 强制 ephemeral 短暂的 gradual 缓增 adoption 采用 relevant 相应 tray 托盘 denied 拒绝 crawle 爬行, 抓取 variadic 可选的 intact 原封不动的 Hierarchy 等级制度 Decompose 分解 interlude 插曲 Miscellaneous 各种各样的 forum 论坛","categories":[],"tags":[]},{"title":"React Native 学习总结","slug":"React-Native","date":"2018-08-13T09:06:58.219Z","updated":"2018-11-22T14:52:03.705Z","comments":true,"path":"2018/08/13/React-Native/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/React-Native/","excerpt":"","text":"React-NativeReact Native 学习总结 启动 下载react-native-cli命令行工具(需要配合Xcode使用) 1npm i -g react-native-cli 初始化项目 1react-native init projectname Ios通过命令行运行项目 1react-native run-ios ios通过Xcode打开项目 双击ios目录下的 FirstApp.xcodeproj android通过命令行运行项目 首先启动android模拟器 1emulator -avd a7","categories":[],"tags":[]},{"title":"Markdown 语法总结","slug":"Markdown","date":"2018-08-13T09:06:58.217Z","updated":"2018-10-01T15:05:09.443Z","comments":true,"path":"2018/08/13/Markdown/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/Markdown/","excerpt":"","text":"markdown 总结一些markdown的常用语法 语法 废弃线 – 双波浪线包裹 – 这里是废弃的内容~~ toc 生成markdown 的目录 – [toc] + 回车 文件引用 index.js README.md 文件写法Repository name 仓库名 一级标题 Overview 概览 二级标题 Table of contents 目录 三级标题 Quick start 快速开始 二级标题 install 下载 四级标题 start 开始 四级标题 debug 调试 四级标题 Feathres 特色 二级标题 Known issues 已知问题 二级标题 Troubleshoting 故障排除 二级标题 Advanced Use 高级用法 二级标题 Configuration 配置 二级标题 Options 选项 三级标题 Usage example 使用例子 三级标题 license 许可证 二级标题","categories":[],"tags":[]},{"title":"Electron 使用javascript开发通用桌面程序框架","slug":"Electron","date":"2018-08-13T09:06:58.216Z","updated":"2018-10-01T14:57:02.550Z","comments":true,"path":"2018/08/13/Electron/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/Electron/","excerpt":"","text":"Electron使用javascript, html, css 构建跨平台桌面应用 https://electronjs.org/ 1npm i electron@latest 目录[TOC] 封装/打包 &amp; 脚手架模版 electron-vue https://github.com/SimulatedGREG/electron-vue vue 在 electron环境下的脚手架 12345678910# 初始化项目结构vue init simulatedgreg/electron-vue my-projectcd my-projectyarn # 开发模式yarn run dev# 编译生成二进制文件yarn run build electron-forge 可打包成二进制文件 https://github.com/electron-userland/electron-forge 123456789101112npm install -g @electron-forge/cli@betaelectron-forge init my-new-appcd my-new-app# 开发模式下打开应用npm start# 生成二进制文件npm run package# 生成二进制文件的压缩包npm run make 使用说明, 两种方法 使用electron-forge init projectname 来初始化项目, 然后在此项目内开发 基于已有的项目, 把package.json文件内的 script , config, dependencies 和 devDependdencies 复制进来 electron-packager https://github.com/electron-userland/electron-packager 1electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] electron-builder https://github.com/electron-userland/electron-builder 12# download yarn add electron-builder --dev APIapp 主线程可用 https://electronjs.org/docs/api/app 监听应用程序的生命周期, 控制窗口操作 12345678910111213const &#123; app &#125; = require('electron')app.on('window-all-closed', () =&gt; &#123; app.quit()&#125;)// 使程序获得焦点app.focus() // 退出程序app.quit()// 隐藏程序app.hide() BrowserWindow https://electronjs.org/docs/api/browser-window 创建或销毁窗口 12345678910111213141516171819202122232425262728293031323334const &#123; BowserWindow &#125; = require('electron').remotelet win = new BowserWindow(&#123; width: 400, height: 400, minWidth: 400, minHeight: 400, resizable: true, frame: false, // 无边框 show: true, // 显示或隐藏&#125;)win.loadURL(path.join(`file://$&#123;__dirname&#125;/app/index.html`))// 监听页面 window.close() 事件win.on('close', () =&gt; &#123; app = null&#125;)// 监听页面的crash事件并给出提示框win.on('crash', () =&gt; &#123; const option = &#123; type: 'info', message: 'This process has crashed.', &#125; electron.dialog.showMessageDialog(option, fn)&#125;)win.on('move', function () &#123; app.getSize() // 获得尺寸 app.getPosition() // 获得位置&#125;)win.on('resize', fn)win.show() app/index.html 12&lt;a href=\"javascript:window.close()\"&gt;点击关闭窗口&lt;/a&gt;&lt;a href=\"javascript:process.crash()\"&gt;点击触发crash&lt;/a&gt; dialog 对话框 https://electronjs.org/docs/api/dialog 打开文件夹 12345678const &#123; dialog &#125; = require('electron').remotedialog.showOpenDialog(&#123; properties: ['openDirectory', 'openFile', 'multiSelections'],//允许选择目录,文件,多选 defaultPath: '', // 默认打开路径&#125;, function (filePaths) &#123; // filePaths 为路径数组&#125;) 保存文件操作 12345dialog.showSaveDialog(&#123; defaultPath: '',&#125;, function (filename) &#123; &#125;) 系统通知对话框 123456dialog.showMessageDialog(&#123; type: 'info', title: 'Renderer Process Crashed', message: 'This process has crashed.', buttons: ['Reload', 'Close']&#125;) IpcRenderer 从渲染进程到主进程的异步通讯 https://electronjs.org/docs/api/ipc-renderer 12345// 绑定信道事件ipcRenderer.on(channel, function (event, arg) &#123;&#125;)// 向主进程发送事件ipcRenderer.send(channel, args) ipcMain 从主进程到渲染进程通讯 https://electronjs.org/docs/api/ipc-main 1ipcMain.on(channel, function (event, arg) &#123;&#125;) remote 渲染进程可用 https://electronjs.org/docs/api/remote 在渲染进程中使用主进程模块, 方法 123456const &#123; BrowserWindow &#125; = require('electron').remotelet win = new BrowserWindow(&#123; width: 700, height: 700,&#125;)win.loadURL('http://www.github.com') globalShortcut 快捷键监听 https://electronjs.org/docs/api/accelerator 123456const &#123; app, globalShortcut &#125; = require('electron')app.on('ready', () =&gt; &#123; globalShortcut.register('CommandOrControl+Y', () =&gt; &#123; // do something &#125;)&#125;) clipboard 主线程, 渲染进程可用 https://electronjs.org/docs/api/clipboard 剪贴板 12345678910111213141516171819const &#123; clipboard &#125; = require('electron')// 复制纯文本clipboard.writeText('some string')// 读取剪贴板中的内容let clipText = clipboard.readText()// 带有格式的文本clipboard.writeHTML('&lt;p&gt;this is a p&lt;/p&gt;')// 读取带有格式的剪贴板内容let clipHtml = clipboard.readHTML()// 复制图片到剪贴板clipboard.writeImage(image)// 读取剪贴板的图片let img = clipboard.readImage() shell 主进程, 渲染进程可用 https://electronjs.org/docs/api/shell 系统级别调用命令 12345678910111213141516const &#123; shell &#125; = require('electron')// 使用默认浏览器打开网址shell.openExternal('https://www.github.com') // 在finder中显示文件 返回Boolean值, 成功为true, 失败为falseshell.showItemInFolder(fullPath)// 以默认应用打开文件 返回Boolean值, 成功为true, 失败为falseshell.openItem(fullPath) // 删除文件 返回Boolean值, 成功为true, 失败为falseshell.moveItemToTrash(fullPath)// 放出系统提示音shell.beep() systemPreferences 主进程可用 https://electronjs.org/docs/api/system-preferences 获取 系统偏好设置 1234const sys = require('electron').systemPreferences// 是否是黑暗模式 mac os有效sys.isDarkMode() tray 主进程可用 https://electronjs.org/docs/api/tray 系统托盘 123456789101112131415161718192021const &#123; app, Menu, Tray &#125; = require('electron')let tray = nullapp.on('ready', () =&gt; &#123; tray = new Tray('/path/to/myicon') const contextMenu.buildFromTemplate([ &#123;label: 'Item1', type: 'radio'&#125;, &#123;label: 'Item2', type: 'radio', checked: true&#125; ]) // 设置鼠标提示 tray.setToolTip('hello my guest') // 设置菜单内容 tray.setContextMenu(contextMenu) // 销毁托盘 tray.destory() // 设置图标 tray.setImage(image) tray.on('click', (event, bounds, position) =&gt; &#123; // event 事件对象, bounds 系统托盘图标的边界, position 事件的位置信息 &#125;) &#125;) screen 主进程, 渲染进程可用, 在 app 模块ready事件之后可用 https://electronjs.org/docs/api/screen 检测屏幕, 光标位置信息 123456789101112131415161718const electron = require('electron')const &#123; app, BrowserWindow &#125; = electronapp.on('ready', () =&gt; &#123; const &#123; screen &#125; = electron // 获得显示器长宽 const &#123; width, height &#125; = screen.getPrimaryDisplay().workAreaSize // 获得所有显示器列表数组 const displays = screen.getAllDisplays() // 获取鼠标绝对位置 const cursor = screen.getCursorScreenPoint() // 返回菜单的高度 const menu = screen.getMenuBarHeight()&#125;) session 主进程可用 https://electronjs.org/docs/api/session 管理浏览器会话, cookie, 缓存 123456789const &#123; BrowserWindow &#125; = require('electron')let win = new BrowserWindow(&#123; width: 800, height: 600&#125;)win.loadURL('http://www.github.com')const session = win.webContents.sessionconsole.log(session.getUserAgent()) Menu 主进程可用 https://electronjs.org/docs/api/menu 创建原生应用菜单 123456789101112131415const &#123; app, Menu &#125; = require('electron')const template = [ &#123; label: 'Edit', submenu: [ &#123;role: 'undo'&#125;, &#123;role: 'redo'&#125;, &#123;role: 'delete'&#125;, ] &#125;]const menu = Menu.buildFromTemplate(template)Menu.setApplicationMenu(menu) Notification 主进程可用 https://electronjs.org/docs/api/notification 系统通知栏 12345678910111213import Notification from 'electron'Notification.isSuported() // 返回系统是否支持通知const opt = &#123; title: '通知', body: '这是一条通知', icon: '/assets/img/nogify.png', sound: '/assets/sound/notify.mp3',&#125;const notify = new Notification(opt)// 显示这条通知notify.show() webContents 主进程可用 https://electronjs.org/docs/api/web-contents 渲染和控制web页面 123456789101112131415161718const &#123; BrowserWindow &#125; = require('electron')let win = new BrowserWindow(&#123; width: 800, height: 600&#125;)let contents = win.webContents// 获取app所有的web 页内容, 是一个数组contents.getAllWebContents()// 获取当前焦点的web 内容页contents.getFocusedWebContents()// 主进程向渲染进程发消息contents.send(channel, function (args) &#123; // do someting &#125;) webFrame 渲染进程可用 https://electronjs.org/docs/api/web-frame 自定义渲染页面 12345678910111213const &#123; webFrame &#125; = require('electron')// 页面放大2倍webFrame.setZoomFactor(2)// 获取当前页面的缩放倍数webFrame.getZoomFactor()// 插入text到焦点元素webFrame.insertText(text)// 释放不在使用的内存webFrame.clearCache() webView 渲染进程可用 https://electronjs.org/docs/api/webview-tag 类似于iframe 在进程中显示独立的网页 123456&lt;webview id=\"view\" src=\"https://www.github.com\" plugins // 可以访问插件 preload=\"./test.js\" // 指定事先加载脚本 &gt;&lt;/webview&gt; powerMonitor 主进程可用 https://electronjs.org/docs/api/power-monitor 监控系统级事件 123456789const electron = require('electron')const &#123; app &#125; = electron// 必须在程序启动后监听系统电源事件app.on('ready', () =&gt; &#123; electron.powerMonitor.on('suspend', () =&gt; &#123; console.log('the system is going to sleep') &#125;)&#125;) powerSaveBlocker 主进程可用 https://electronjs.org/docs/api/power-save-blocker 组织系统进入休眠状态 1234567const &#123; powerSaveBlocker &#125; = require('electron')// 阻止系统休眠const id = powerSaveBlocker.start('prevent-display-sleep')// 取消powerSaveBlocker.stop(id) cookies 主线程可用 https://electronjs.org/docs/api/cookies 查询和修改一个会话的cookies 123456789101112131415161718const &#123; session &#125; = require('electron')// 设置cookieconst cookie = &#123; url: 'http:// www.github.com', name: 'dummy_name', value: 'dummy_value',&#125;session.defaultSession.cookies.set(cookie, err =&gt; &#123; if (err) &#123; console.log(err) &#125; &#125;)// 读取cookiesession.defaultSession.cookies.get(&#123;url: 'http://www.github.com'&#125;, (err, cookies) =&gt; &#123; console.log(err, cookies)&#125;) DesktopCapturer 渲染进程可用 https://electronjs.org/docs/api/desktop-capturer 录屏, 截屏 net 主进程可用 https://electronjs.org/docs/api/net 使用Chromium的原生网络库发出HTTP / HTTPS请求 12345const &#123; net &#125; = require('electron')const request = net.request('https://www.github.com')request.on('response', res =&gt; &#123; console.log(res)&#125;) client-request 主线程可用 https://electronjs.org/docs/api/client-request 发起http/https请求 1234567891011121314const &#123; ClientRequest &#125; = require('http')const request = new ClientRequest(&#123; method: 'GET', protocol: 'https:', hostname: 'github.com', port: 443, path: '/'&#125;)request.on('login', (authInfo) =&gt; &#123;&#125;)request.on('response', res =&gt; &#123; console.log(res)&#125;)","categories":[],"tags":[]},{"title":"Requirejs 学习收录","slug":"Requirejs","date":"2018-08-09T09:52:33.831Z","updated":"2018-09-29T16:36:05.881Z","comments":true,"path":"2018/08/09/Requirejs/","link":"","permalink":"http://zexiplus.github.io/2018/08/09/Requirejs/","excerpt":"","text":"requirejs RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载 基本使用 加载使用 data-main 属性不可忽虑, 指定主代码所属的脚本文件 123&lt;head&gt; &lt;script src=\"js/require.js\" data-main=\"js/entry.js\"&gt;&lt;/script&gt;&lt;/head&gt; 配置项 config paths 用于指定模块的位置, 属性值可以是字符串/数组, 若是数组, 从第一个地址加载, 加载失败则用之后的路径加载 12345678910// paths 指定模块的链接地址require.config(&#123; paths: &#123; 'vue': './lib/vue.min', 'vueRouter': [ 'www.cdnjs.com/js/vueRouter.js', './lib/vue-router.min' ] &#125;&#125;) baseUrl 用于指定本地模块的基准目录, 该属性通常由require.js加载时的data-main属性指定 1234require.config(&#123; paths: ..., baseUrl: 'js/entry.js'&#125;) shim 有些库不是amd规范库, 需要该属性帮助加载非amd兼容的库 12345678910require.config(&#123; paths: &#123; 'underscore': 'lib/underscore', &#125;, shim: &#123; 'underscore': [ exports: '_' ] &#125;&#125;) 定义模块 define entry.js 1234567891011121314151617181920212223242526272829// 定义命名模块define('myModule', function () &#123; return &#123;&#125;&#125;)// 定义无依赖模块, define 接受的函数只能是对象或者函数define(&#123; method1: function () &#123;&#125;, method2: function () &#123;&#125;&#125;)define(function () &#123; var module = [] return module&#125;)// 定义有依赖的模块define(['js/module1', 'js/module2'], function (module1, module2) &#123; // 使用module1, module2 module1.method1();&#125;)// 定义多个模块, 避免数组太长,参数太长书写不便define(function (require) &#123; var module1 = require('js/module1'); var module2 = require('js/module2'); var moduel3 = require('js/module3');&#125;) 调用模块 require 1234require(['js/module1', 'js/module2'], function (module1, module2) &#123; module1.methods(); module2.methods();&#125;) 例子 vue &amp; vueRouter &amp; element with requirejs Index.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link href=\"css/elementUi.css\" /&gt; &lt;script data-main=\"entry.js\" src=\"lib/require.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;el-button&gt;test&lt;/el-button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; entry.js 123456789101112131415161718192021222324require.config(&#123; paths: &#123; 'vue': 'lib/vue.min', 'vueRouter': 'lib/vue-router.min', 'ELEMENT': 'lib/elementUI.js', &#125;, baseUrl: 'lib'&#125;)define('entry', function (require, exports, module) &#123; var ELEMENT = require('ELEMENT'); var Vue = require('vue'); var router = require('script/router') Vue.use(ELEMENT); new Vue(&#123; el: '#app', router: router; data: function () &#123; return &#123; text: 'hello world' &#125; &#125; &#125;)&#125;) router.js 123456789101112131415define('router', function (require, exports, module) &#123; var Vue = require('vue'); var VueRouter = require('vueRouter'); var component1 = require('component1'); Vue.use(VueRouter) return new VueRouter(&#123; routes: [ &#123; path: '/', component: component1, &#125; ] &#125;)&#125;)","categories":[],"tags":[]},{"title":"DOM & BOM 总结","slug":"DOM&BOM","date":"2018-08-02T06:28:06.389Z","updated":"2018-10-01T14:56:27.309Z","comments":true,"path":"2018/08/02/DOM&BOM/","link":"","permalink":"http://zexiplus.github.io/2018/08/02/DOM&BOM/","excerpt":"","text":"DOM &amp; BOMdom对象和bom对象总结 table of contents[TOC] DOMdocument object model HTMLCollection &amp;&amp; nodeListsimiliarty: 都是类数组，都有length属性 都有getter， list.item(0) 或 list[0] 都是动态的， 其内元素变化会反映到其自身 difference: nodeList 保存的是node( 包含含空节点，文本节点, 注释等)，HTMLCollection 保存的是 element（element继承node，不含其他元素， 只有element元素nodetype 为 1） HTMLCollection有个nameItem() 方法，可以返回集合中name属性和id属性值的元素。 Node attribute attribute Intro demo someNode.nodeType 节点类型（1 - 12） 1 为 元素element，3 为文本，11 位文档片段documentFregment someNode.nodeName 节点标签名 ‘p’, ‘div’ , someNode.tagName someNode.nodeValue 节点值 someNode.childNodes 节点的子节点类数组，保存着一个nodeList someNode.childNodes[0]someNode.childNodes.item(1)Array.prototype.slice.call(childNodes, 0) someNode.children 返回子节点中还是元素的集合(nodetype为1),是HTMLCollection的实例 someNode.children[0] someNode.hasChildNodes() 子节点是否含有childNodes someNode.childNodes.length === 0 someNode.parentNode 节点的父节点，所有子节点拥有同一父节点 someNode.previousSibling 节点的兄弟节点（相邻的上一个节点） someNode.nextSibling 节点的兄弟节点（相邻的下一个节点） someNode.firstChild 节点的第一个子节点, 可能是文本，注释， 空节点等 someNode.lastChild 节点的最后一个子节点 someNode.firstElementChild 节点的第一个元素节点 someNode.lastElementChild 节点的最后一个元素节点 someNode.previousElementSibling 节点的兄弟节点（相邻的上一个元素节点） someNode.nextElementSibling 节点的兄弟节点（相邻的下一个元素节点） someNode.childElementCount 返回子元素（nodeType = 1）节点个数 someNode.dataset 返回当前元素的自定义属性集 &lt;div data-myrule=&quot;123&quot;&gt;&lt;/div&gt; div.dataset.myrule // return ‘123’ Node method method Intro Demo someNode.appendChild(A) 在someNode的nodeList末尾添加一个A someNode.insertBefore(A, B) 在参照节点（B）前添加一个A 节点, 若第二个参数是 null , 则执行与 appendChild 相同操作 someNode.replaceChild(new,old) 用new节点替换 old节点，old为someNode的子节点 someNode.replaceChild(node, someNode.firstChild) someNode.removeChild(A) 移除someNode下的某个子节点A A.removeChild(A.firstChild) someNode.cloneNode(boolean) 复制节点 ，boolean 为 true 执行深复制， boolean 为 false 执行浅复制(只复制当前元素，不复制子元素)。执行复制之后的节点没有父节点，成了孤儿，必须通过以上集中操作才能显示。 const deepNode = someNode.cloneNode(true) deepNode.length // 3 const shallowNode = someNode.cloneNode(false) shallowNode.length // 0 someNode.machesSelector(cssSelector) 接收一个css选择符作为参数，返回 el.machesSelector(‘body.label’) // =&gt; true or false document Attr &amp; method Intro Demo document.documentElement 取得对元素的引用 document.documentElement === document.childNodes[0] === document.firstChild document.title 获取/设置文档标题 document.title // 获取titile document.title = ‘epic doc’ // 设置title document.URL 获取页面完整的url（不可设置） https://cn.demo.com/search?q=1234 document.domain 获取/设置页面的域名，只能设置其站点的子域名 document.domain // https://cn.demo.com document.domain = ‘demo.com’ // success document.domain = ‘baidu.com’ // failed document.referrer 获取跳转到当前页面的那个页面的url document.getElementById() document.getElementsByTagName() 返回一个HTMLCollection,有个方法nameItem() const list = document.getElementsByTagName(‘p’); list.nameItem(‘myName’) // 返回这个htmlCollection 中name为myName的元素 document.getElementsByName() 返回一个HTMLCollection document.anchors 返回一个HTMLCollection，包含所有带name属性的元素 document.forms 返回所有元素 document.images 返回所有元素 document.links 返回所有带href属性的元素 document.open() docuement.close() document.createElement(tagName) 创建元素 document.createElement(‘div’) document.createTextNode(string) 创建文本节点 document.createTextNode(‘hello world’) doc.createDocumentFragment() 创建轻量级文档，继承document的所有属性。 const fregment = document.createDocumentFragment(); for( let i = 0; i &lt; 3; i++) { let li = document.createElement(‘li’); fregment.appendChild(li)} document.querySelector() 返回第一个匹配的节点 document.querySelectorAll() 返回所有匹配的节点， 是一个nodeList快照，不会动态刷新 doc.getElementsByClassName(classStr) 参数传入类名字符串，多个类名用空格隔开 document.getElementByClassName (‘sidebar content green’) element Nodetype 为 1 (important) nodevalue为 null attr &amp;&amp; method Intro demo el.nodeName 返回元素标签名(大写) el.nodeName === el.tagName === ‘DIV’ el.tagName 返回元素标签名(大写) el.id 返回元素的id el.className 返回元素的类名字符串，多个类名用空格隔开 el.classList 返回一个具有length属性的DOMTokenList的实例,具有item(), add(), contains(), remove(), toggle() 方法 el.classList.add(val) //添加 el.classList.contains(val) // 判断el.classList.remove(val) // 删除el.classList.toggle(val) // 切换 el.title 返回元素的标题 el.style 返回 一个 以object 表示的css描述, 属性转换为驼峰命名法,例如: background-color =&gt; style.backgroundColor = ‘red’ el.style // =&gt; {color: ‘#fff’} el.getAttribute(‘style’) // =&gt; ‘color: …’ el.getAttribute(attrName) 返回属性字符串表示 el.setAttribute(attrName, attrValue) 设置属性 el.removeAttribute(attrname) 移除属性 el.contains(A) 判断节点A是否是el的子节点,返回true,false el.scrollIntoView(true/false) 使元素出现在视窗内 el.scrollByLines(lineCount) 使元素滚动指定的行数,lineCount 可以是正负值 non-standard el.scrollByPages(pageCount) 使元素滚动指定的页数,pageCount 可以是正负值 non-standard dynamic script &amp;&amp; style12345678910111213141516171819202122232425// dynamic scriptfunction dynamicScript(url) &#123; let script = document.createElement('script') script.type = 'text/javascript' script.src = url document.body.appendChild(script)&#125;function dynamicScriptWithText(text) &#123; let script = document.createElement('script') script.type = 'text/javascript' let textNode = document.createTextNode(text) script.appendChild(textNode) document.body.appendChild(script)&#125;// dynamic style function dynamicStyle(url) &#123; let link = document.createElement('link') link.type = 'text/css' link.rel = 'stylesheet' link.href = url document.head.appendChild(link)&#125; html translation 显示 说明 实体名称 实体编号 半方大的空白 &amp; ensp; &#8194; 全方大的空白 &amp; emsp; &#8195; 不断行的空白格 &amp; nbsp; &#160; &lt; 小于 &amp; lt ; &#60; &gt; 大于 &amp; gt ; &#62; &amp; &amp;符号 &amp; amp ; &#38; “ 双引号 &amp; quot; &#34; © 版权 &amp; copy; &#169; ® 已注册商标 &amp; reg; &#174; ™ 商标（美国） ™ &#8482; × 乘号 &amp; times; &#215; ÷ 除号 &amp; divide; &#247; 1234567&lt;input id=\"user[name]\" /&gt;// 转义特殊css字符用双反斜杠 '\\\\'&lt;script&gt; document.querySelector('user[name]') // null document.querySelector('user\\\\[name\\\\]') // &lt;input id=\"user[name]\" /&gt;&lt;/script&gt; dom size window.innerHeight 浏览器视窗内高度（当前页面 ，不包括外层iframe） window.innerWidth 浏览器内宽度 div.offsetHeight 元素在垂直方向占用的空间大小（单位-像素） div.offsetWidth 元素在水平方向占用空间大小（单位-像素） div.offsetLeft 元素的左外边框至包含元素的左内边框之间的像素距离 div.scrollLeft 既可以确定元素当前滚动状态，又可以设置元素的滚动位置 BOMbowser object model location浏览器导航对象 ####location attribute Location.href 读取/设置当前window的url 1window.location === window.document.location location.search 读取/设置当前url的搜索字符串 Location.hash 读取/设置当前url的hash location method location.reload() 刷新当前页面 Location.assign(href) 设置当前页面url, 浏览器可产生历史记录, 后退按钮可点击回到上一页 Location.replace(href) 设置当前页面url, 浏览器不产生历史记录","categories":[],"tags":[]},{"title":"Database nodejs常用数据库总结","slug":"Database","date":"2018-08-02T06:28:06.385Z","updated":"2018-10-01T15:02:58.174Z","comments":true,"path":"2018/08/02/Database/","link":"","permalink":"http://zexiplus.github.io/2018/08/02/Database/","excerpt":"","text":"Database 常用数据库操作 Table of Contents[TOC] NO-SQLmongoDB doc mongo command start mongodb 1sudo service mongod start stop mongodb 1sudo service mongod stop restart mongodb 1sudo service mongod restart use mongodb 1234567891011121314# 指定目录启动mongo服务器mongod --dbpath d:\\data\\db # 启用web界面的mongo服务器 界面端口 28017sudo mongod --rest# only connect to the local default mongo servicemongo# or 指定host和端口访问mongo --host 192.168.0.4:27017# 指定用户名密码和数据库访问mongo -u \"myUserAdmin\" -p \"abc123\" --authenticationDatabase \"admin\" mongo config123456789101112# 文件路径/etc/mongodb.conf# 地址和端口配置net: port: 27017 # 默认值，只能通过局域网访问 若通过外网访问，需要设置为 服务器内网ip（192.168.0.4） bindIp: 127.0.0.1 #开启验证登录security: authorization: enabled mongo cli 账号密码管理 https://blog.csdn.net/fofabu2/article/details/78983741 mongodb的用户名和密码是基于特定数据库的，而不是基于整个系统的。所有数据库db都需要设置密码 12345678# 列出当前mongodb服务中的所有数据库show dbs# 选择数据库(若没有admin数据库，则创建admin数据库)use admin# 删除当前数据库db.dropDatabase() 12345678// 新建账户并赋予权限db.createUser(&#123;user: 'xiaoxixi', pwd: 'admin123', roles: [&#123; role: 'userAdminAnyDatabase', db: 'admin',&#125;]&#125;)// 验证创建用户是否成功 0 失败， 1 成功db.auth('xiaoxixi', 'admin123') role取值 readAndWrite 读写 userAdminAnyDatabase 用户管理身份任意数据库 mongoose https://github.com/Automattic/mongoose mongoose 连接mongodb 1234var mongoose = require('mongoose')var db = mongoose.connect('mongodb://username:password@192.168.1.101:port/db_name')db.connection.on('open',fn)db.disconnect() //关闭所有连接 mongoose 模型定义及实例化 123456789101112131415161718var userSchema = new mongoose.Schema(&#123; userName: &#123; type: String, required: true &#125;, password: &#123; type: String, require: true &#125;&#125;)//通多schema定义model，数据库中会自动创建一个名为userInfos的集合var User = mongoose.model('user',userSchema) //直接定义modelvar Dog = mongoose.model('dog',&#123;name: String&#125;) var xiaoxixi = new User(&#123;username:'xiaoxixi',password: '123'&#125;) //实例化var lovelydog = new Dog(&#123;name: 'lovely'&#125;) mongoose 模型扩展 123456789101112131415161718192021//statics 类上扩展userSchema.statics.find_by_username = function(username,cb) &#123; return this.findOne(&#123; //this指向User username:username &#125;,cb)&#125;//调用User.find_by_username('xiaoxixi',function(err,docs) &#123; &#125;)//methods 对象上扩展userSchema.methods.is_exist = function(cb) &#123; var query = &#123; username: this.uername, password: this.password &#125; return this.model('user').findOne(query,cb) // this指向User的实例&#125;//调用var xiaoxixi = new User(&#123;username:'xiaoxixi',password: '12345'&#125;).is_exist(cb) mongoose promise 12//所有方法均可采用promise规范User.find(&#123;&#125;,cb) === User.find(&#123;&#125;).then(cb) mongoose CRUD 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//增加并存储单条数据var userone = new User(&#123;username:'123',password:'456'&#125;).save(function(err,user) &#123;&#125;)//搜索多条文档User.find(&#123;&#125;, function(err,users) &#123;&#125;) //users为文档数组 &#123;&#125;为查询条件//搜索单条文档User.findOne(&#123;&#125;, function(err,user) &#123;&#125;) //user为单条文档//查询并更新User.findOneAndUpdate(conditions, update,cb)//查询并删除User.findOneAndRemove(conditions, cb)//按id查询User.findById(xiaoxixi._id, function(err,user) &#123;&#125;) //移除文档userone.remove((err,user) =&gt; &#123;&#125;) //user参数指代userone//按条件删除单条文档User.deleteOne(&#123;username:'123'&#125;, err =&gt; &#123;&#125;)//批量删除User.deleteMany(&#123;username:/xiaoxixi/,age: &#123;$gte: 18&#125;&#125;,err =&gt; &#123;&#125;)//批量操作User.bulkWrite([ insertOne: &#123; username:'xiaoxixi', password: '123' &#125;, updateOne: &#123; filter: &#123;name: '123'&#125;, update: &#123;password: '666'&#125; &#125;, deleteOne: &#123; filter: &#123;name: '7878'&#125; &#125;]).then(err =&gt; &#123;&#125;)//查询符合条件的数量User.count(&#123;name: 'xiaoxixi'&#125;, (err,count) =&gt; &#123;&#125;)//新建单/多条数据User.create([&#123;name: 'xiaoxixi'&#125;,&#123;name: 'daxixi'&#125;], (err,users) =&gt; &#123; var xiaoxixi = users[0] var daxixi = users[1]&#125;)//异步操作语法whereUser.find(&#123;age: &#123;$gte: 18,$lte: 50&#125;&#125;,cb)User.where('age').gte(18).lte(50).exec(cb)User.where('age').gte(18).where('name',/^b/) SQLmySQL","categories":[],"tags":[]},{"title":"Event 事件对象总结","slug":"Event","date":"2018-08-01T07:10:42.312Z","updated":"2018-10-14T06:20:57.148Z","comments":true,"path":"2018/08/01/Event/","link":"","permalink":"http://zexiplus.github.io/2018/08/01/Event/","excerpt":"","text":"Event浏览器事件总结 Table of contentsEvent 事件对象常用属性 type 事件类型 例如 keydown 键码相关 key, code, which, keyCode 1234567// 例如按键向上箭头事件&#123; key: 'ArrowUp', code: 'ArrowUp', keyCode: 38, which: 38,&#125; 模拟事件创建事件对象, 触发事件执行 创建事件对象 new Event() || createEventObject || createEvent 1234var eventObj = new Event('click', &#123;bubbles: false, cancelable: false, composed: false&#125;)var eventObj1 = document.createEventObject()var eventObj2 = document.createEvent('Events')var eventobj3 = document.createEvent('KeyboardEvents') 初始化事件对象类型 eventObj.initEvent 1234if (eventObj2.initEvent) &#123; eventObj2.initEvent('keyup', true, true) eventObj3.initEvent('keydown', true, true, window, \"U+0009\") // 模拟tab按键&#125; 分发事件 el.dispatchEvent || el.fireEvent 12document.querySelector('div').dispatchEvent(eventObj)document.fireEvent('onkeyup', eventObj) 焦点事件 获得页面当前焦点元素 123document.activeElement// 点击焦点按钮document.activeElement.click() 获得焦点 1element.focus() 取消焦点 1element.blur() 避免获得焦点 1&lt;a tabindex=\"-1\"&gt;&lt;/a&gt; 跨域 event: message 12345window.addEventListener('message', function (e) &#123; if (event.origin.indexOf('http://yoursite.com')) &#123; // do some thing &#125;&#125;) postMessage 12var frame = document.getElementById('frame')frame.contentWindow.postMessage('any thing') 非跨域访问 cross-origin 判定规则 &lt;protocol&gt;://&lt;hostname&gt;:&lt;port&gt;/path/to/page.html 中protocol, hostname, port 任一不同, 即判定为跨域 1234567// sub pagefunction say() &#123; alert('hello')&#125;// parent pageframe.window.say()","categories":[],"tags":[]},{"title":"web项目测试总结","slug":"Test","date":"2018-07-30T07:13:44.523Z","updated":"2018-10-09T06:59:05.138Z","comments":true,"path":"2018/07/30/Test/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Test/","excerpt":"","text":"test此文档总结了常用测试案例, 例如单元测试,集成测试,端到端测试, 涵盖了常用的测试库 Table of contents[TOC] unit testJestDelightful JavaScript Testing https://github.com/facebook/jest quick start download 1npm i -S jest config 12345&#123; \"scripts\": &#123; \"test\": \"jest\" &#125;&#125; demo 123456789101112// sub.jsmodule.exports = function (a) &#123; return function (b) &#123; return a - b &#125;&#125;// sub.test.jsconst sub = require('./sub')test('test title: 3 - 2 = 1', () =&gt; &#123; expect(sub(3)(2)).toBe(1)&#125;) run 1npm run test Api https://jestjs.io/docs/en test 定义描述测试 123test('your test title', () =&gt; &#123; // if any test turns failed , test failed&#125;) expect 期望值 1expect(1 + 1).toBe(2) toBe 判断值相等 toEqual 判断对象键值一致 12const obj = &#123;a: 1, b: 2&#125;expect(obj).toEqual() toBeNull 判断是否为null Number category toBeGreaterThan toBeLessThan toBeLessThanOrEqual String category toMatch 匹配正则 1expect('str').not.toMatch(/I/) Array category toContain 包含 1expect([1, 2, 3]).toContain(1) Error category toThrow 12function throwErr() &#123; throw new Error('you have an error')&#125;expect(throwErr()).toThrow('you have an error') async test 12345678function fetchData() &#123; return axios.get('demo.json')&#125;test('async test', async () =&gt; &#123; const data = await fetchData() expect(data.id).toBe(12)&#125;) hooks jest可以在测试开始前和测试执行之后完成用户指定操作 beforeEach 在测试执行前执行操作 123beforeEach(() =&gt; &#123; // do some thing before&#125;) afterEach 在测试执行后操作 123afterEach(() =&gt; &#123; // do soem thing after&#125;) e2e test###nightWatch 配置文件 nightwatch.conf.js（nightwatch.json）示例配置详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950require('babel-register')var config = require('../../config')// http://nightwatchjs.org/gettingstarted#settings-filemodule.exports = &#123; src_folders: ['test/e2e/specs'], // 测试的文件夹（相对于根目录） output_folder: 'test/e2e/reports', // 输出log的文件夹（相对于根目录） custom_assertions_path: ['test/e2e/custom-assertions'], //自定义断言文件夹（相对于根目录） selenium: &#123; //自定义selenium-server 配置 start_process: true, // selenium-server(测试服务)程序路径 e.g: bin/selenium-server-standalone-2.43.0.jar server_path: require('selenium-server').path, host: '127.0.0.1', port: 4444, cli_args: &#123; 'webdriver.chrome.driver': require('chromedriver').path // 'webdriver.ie.driver', 'webdriver.firefox.profile' &#125; &#125;, test_settings: &#123; // 设置全局参数，默认变量 default: &#123; launch_url : \"http://localhost\", // 可在测试文件browser.lanuchUrl 拿到 selenium_port: 4444, selenium_host: 'localhost', silent: true, globals: &#123; //全局变量 browser.globals.devServerURL devServerURL: 'http://localhost:' + (process.env.PORT || config.dev.port) &#125; &#125;, chrome: &#123; // 针对chrome的配置 desiredCapabilities: &#123; browserName: 'chrome', javascriptEnabled: true, acceptSslCerts: true &#125; &#125;, firefox: &#123; // 针对firefox的配置 desiredCapabilities: &#123; browserName: 'firefox', javascriptEnabled: true, acceptSslCerts: true &#125; &#125; &#125;&#125; 测试文件 test.js 示例12345678910111213141516module.exports = &#123; 'default e2e tests': function (browser) &#123; // automatically uses dev Server port from /config.index.js // default: http://localhost:8080 // see nightwatch.conf.js const devServer = browser.globals.devServerURL browser .url(devServer) .waitForElementVisible('#app', 5000) .assert.elementPresent('.hello') .assert.containsText('h1', 'Welcome to Your Vue.js App') .assert.elementCount('img', 1) .end() &#125;&#125; ####API api参考 Usual 1234567891011// 元素选择器 element()element(selector) // browser.element('#main') // 判断 expectbrowser.expect.element('#password').to.be.an('input')// 等待元素可见 browser.waitForElementVisible('body', 5000)// 设置input的值browser.setValue('#username', value) Expect 12// 链式调用助动词 （没有实际意义）to,be,been,is,that,which,and,has,have,with,at,does,of Assert 12.assert // 测试失败结束测试.verify // 测试失败跳过，进行下一条测试","categories":[],"tags":[]},{"title":"网站设计取色排版原则","slug":"Web-design","date":"2018-07-30T07:13:44.514Z","updated":"2018-09-29T16:39:36.504Z","comments":true,"path":"2018/07/30/Web-design/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Web-design/","excerpt":"","text":"web design收录了 网站设计原则, 配色方案, 素材地址 配色网站: https://color.adobe.com/zh/explore/?filter=most-used&amp;time=all 分析配色网站: site pattle 网站布局,排版 https://www.thebestdesigns.com/ 图片素材 https://dribbble.com/ web design principle 响应式布局,移动优先原则，及默认的css样式为移动样式，然后通过媒体查询 用 桌面样式覆盖 移动采用上下布局, 桌面端采用 左右布局 整体字体在 14px 到 20px 之间 保持适当行距（1.5倍） 段落采用缩进或隔行，不能两者同时用，首段不用隔行或缩进 web design meterialcolor 浅色主题 边框颜色: #EAEDF0 字体颜色: #5D6063 背景颜色: #FBFCFC","categories":[],"tags":[]},{"title":"Web 性能分析","slug":"Performance","date":"2018-07-30T07:13:44.513Z","updated":"2018-10-02T02:51:03.308Z","comments":true,"path":"2018/07/30/Performance/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Performance/","excerpt":"","text":"Web performanceQuestion 常见问题 什么是阻塞？在页面中我们通常会引用外部文件，而浏览器在解析HTML页面是从上到下依次解析、渲染，如果中引用了一个a.js文件，而这个文件很大或者有问题，需要2秒加载，那么浏览器会停止渲染页面（此时是白屏显示），2秒后加载完成才会继续渲染，这个就是阻塞。 为什么会阻塞？因为浏览器不知道a.js中执行了哪些脚本，会对页面造成什么影响，所以浏览器会等js文件下载并执行完成后才继续渲染，如果这个时间过长，会白屏。 CSS文件也一样，因为CSS文件会对DOM的样式，布局，色彩，效果产生影响，所以浏览器会等CSS文件下载并执行完成后继续。 css 阻塞css 的加载不会阻塞dom的解析(DOM tree), 但会阻塞dom 树的渲染(render tree). 会阻塞之后js代码的执行. 为了避免dom树重新渲染回溯影响性能浪费, 所以css代码的加载会阻塞dom树渲染. 加载事件 load 事件和 DOMContentLoaded 事件 load事件: 页面中的所有静态资源加载完成时触发包括样式表, 图像, 脚本 DOMContentLoaded事件: 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载. 注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发 解决阻塞 延迟加载 defer 把script标签放到 body 的最后一行, 或者在script标签加入 defer属性 1234567891011&lt;head&gt; &lt;script src=\"js/defer.js\" defer&gt;&lt;/script&gt; &lt;script src=\"js/defer2.js\" defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;!-- other --&gt;&lt;html&gt; &lt;body&gt; &lt;/body&gt; &lt;script src=\"js/defer.js\"&gt;&lt;/script&gt;&lt;/html&gt; 异步加载 async 告知浏览器可以边下载边渲染而不用等到js下载再执行后才渲染, 使用了 async 属性的脚本不能保证执行的先后顺序, 异步脚本一定会在页面load事件前执行(所有资源都下载完), 但可能会在DOMContentLoaded 事件前或后执行 1234&lt;head&gt; &lt;script src=\"js/async.js\" async&gt;&lt;/script&gt; &lt;script src=\"js/async2.js\" async&gt;&lt;/script&gt;&lt;/head&gt; 这两种的不同点: defer 会 立即下载,但到 浏览器解析至html标签时才顺序执行.而放在body后的script代码会在遇到这个标签时才下载,下载完成后执行. 动态加载 createElement(‘script’) 当有需要时,再加载脚本 1234567function createScript(src) &#123; var script = document.createElement('script') script.type = 'text/javascript' script.src = src document.head.appendChild(script)&#125;document.querySelector('button').onclick = createScript load 事件之后加载 Onload 事件为页面中所有的图片, 视频,js文件,css文件 等资源都加载完才触发 123window.onload = function () &#123; createScript('js/onload.js')&#125; DOMContentLoaded 事件之后加载 DOMContentLoaded 事件为 形成完整的DOM树后就会触发, 不会理会图像, javascript文件, css文件等其他资源时候下载完毕 123window.addEventListener('DOMContentLoaded', function () &#123; createScript('js/onDOM.js')&#125;) page optmize proposal网页性能优化的34条建议 Minimize HTTP Requests 最小化http请求数 Use a Content Delivery Network 使用内容分发网络 Add an Expires or a Cache-Control Header 给相应头增加过期字段 Gzip Components 压缩组件 Put Stylesheets at the Top 在head内使用样式表 Put Scripts at the Bottom 在body的最后一行引入脚本(或增加defer属性) Avoid CSS Expressions 避免css表达式(只有ie支持css表达式例如top:expression(eval(document.documentElement.scrollTop + document.documentElement.clientHeight - 60)));) Make JavaScript and CSS External 确保脚本和样式表是外联文件 Reduce DNS Lookups 减少dns查询次数 Minify JavaScript and CSS 最小化js和css Avoid Redirects 避免重定向 Remove Duplicate Scripts 删除重复的脚本 Configure ETags 相应头配置ETags字段, 从而判断版本信息 Make Ajax Cacheable 使ajax请求响应可缓存 Flush the Buffer Early 如果请求事件过长, 先发送部分数据 Use GET for AJAX Requests 尽可能在ajax请求使用get方法 Post-load Components 使用延迟加载(对于非必须的优化脚本例如动画,拖动等可以使用延迟加载技术确保主要功能是快速响应的) Preload Components 使用预加载(下一页的图片等资源) Reduce the Number of DOM Elements 减少dom元素数, 减少嵌套标签,减少空标签 Split Components Across Domains 拆分组件至不同域来使用同时下载 Minimize the Number of iframes 使用最少数的iframes No 404s http相应是昂贵的, 消除不必要的404响应 Reduce Cookie Size 减少cookie大小 Use Cookie-free Domains for Components 对于静态资源的请求不使用cookie携带 Minimize DOM Access 减少dom树的直接操作(缓存已放翁过的元素, 减少页面重构次数) Develop Smart Event Handlers 使用高性能的事件处理函数(事件代理, DOMContentLoaded) Choose over @import (IE浏览器使用@import引入的css会在页面最下方引入css一样效果) Optimize Images 优化图片格式,大小 Optimize CSS Sprites 优化精灵图 Don’t Scale Images in HTML 图片的尺寸与显示尺寸对应 Make favicon.ico Small and Cacheable 使网页标题图表小且可缓存 Keep Components under 25K 使文件小于25k(iphone不会缓存25k以上文件大小) Pack Components into a Multipart Document 将文件打包到多个文档 Avoid Empty Image src 避免图片带有空src属性(减少不必要的请求)","categories":[],"tags":[]},{"title":"Koa 新一代web服务开发框架","slug":"Koa","date":"2018-07-30T07:13:44.512Z","updated":"2018-10-01T15:04:00.907Z","comments":true,"path":"2018/07/30/Koa/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Koa/","excerpt":"","text":"koa 官方doc link 笔记 link Table of contents[TOC] 1. koa app Index.js 123456789101112131415161718192021const Koa = require('koa')const app = new Koa()// compute response timeapp.use(async (ctx, next) =&gt; &#123; const startTime = new Date() await next() const endTime = new Date() const time = endTime - startTime ctx.set('X-Response-Time', `$&#123;time&#125;ms`)&#125;)app.use(async (ctx) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3000)console.log('the server is listenning at 3000 port') app’s attributes using explian app.listen app.listen(3000) 监听端口 app.env app.env == ‘development’ app环境变量 app.use app.use(function (ctx, next) {}) 使用中间件 app.keys app.keys = [‘name’, ‘xiaoxixi’] 设置cookie app.context.db app.context.db = new Db() 全局context 设置 app.slient app.slient = true 关闭警告模式(error事件不会出发) app.on app.on(‘error \\ ‘) 监听事件 app.proxy app.proxy = true 设置代理 app.callback() http.createServer(app.callback()) 返回可以被http/connect使用的回调函数 2. middlewaredefine middleware middleware/log.js 1234567891011function log ( ctx ) &#123; console.log(`request method is $&#123;ctx.method&#125;`) console.log(`request header is $&#123;JSON.stringify(ctx.header)&#125;`)&#125;module.exports = function () &#123; return async function ( ctx, next ) &#123; log(ctx) await next() &#125;&#125; use middleware index.js 1234const log = require('./middleware/log.js')const app = new Koa()app.use(log()) 3.router123456789101112131415161718192021222324252627282930313233343536373839// 手动实现路由app.use((ctx, next) =&gt; &#123; let body switch (ctx.request.url) &#123; case '/': body = 'hello one' break case '/home': body = 'hello home' break &#125; ctx.body = body&#125;)// koa-router 中间件const Router = require('koa-router')// 定义2个子路由const config = new Router()const home = new Router()home.get('/one', ctx =&gt; &#123; ctx.body = 'home one' &#125;)config.get('/user', ctx =&gt; &#123; ctx.body = 'user'&#125;).get('/setting', ctx =&gt; &#123; ctx.body = setting&#125;)// 创建父路由，装载子路由const router = new Router()router.use('/home', home.routes(), home.allowedMethods())router.use('/config', config.routes(), config.allowedMethods())// app对象使用父路由app.use(router.routes()).use(router.allowedMethods()) 4.ctx context(ctx) 包含http-response 和 http-request 对象 ctx’s attributes Explian ctx.request koa 请求对象 ctx.response koa 响应对象 ctx.req node http 请求 ctx.res node http 响应 ctx.state ctx.state.user = db.find({name: ‘xiaoxixi’}) 推荐的命名空间 ctx.app 对 app 引用 ctx.cookies.set ctx.cookies.set(‘name’, ‘xiaoxix’, { signed: true }) 设置响应体cookie ctx.cookies.get ctx.cookies.get(‘name’) 获取cookie ctx.throw ctx.throw(400, ‘not found’) 手动抛出错误 5. ctx.request ctx.request attribute alias Explian demo ctx.request.header ctx.header, ctx.request.headers, ctx.headers 请求头 ctx.request.method ctx.method 请求方法 ctx.method = ‘post’ ctx.request.origin ctx.origin 请求源地址(协议和地址) =&gt; http://bing.com ctx.request.length 请求长度 Content-Length ctx.request.url ctx.url 请求url(不包括host) /path?a=123&amp;b=456 ctx.requset.path ctx.path 请求路径 /path ctx.request.href ctx.href 请求href(protocol, host and url) (http://example.com/foo/bar?q=1) ctx.request.queryString ctx.queryString 查询字符串 a=123&amp;b=456 ctx.request.search ctx.search 完整的查询字符串 ?a=123&amp;b=456 ctx.request.host ctx.host 请求的主机 ctx.request.type 请求类型 image/png ctx.request.charset 请求的字体类别 ‘utf-8’ ctx.request.query ctx.query 请求的查询对象 ctx.request.query = {color: ‘blue’, age: 12} ctx.request.fresh ctx.fresh true 没有改变， false改变了 请求体没有改变 If (ctx.fresh) {ctx.status = 304} ctx.request.stale ctx.stale ctx.fresh的反义词 ctx.request.secure ctx.secure 检查协议是否为https ctx.protocol === ‘https’ ctx.request.ip ctx.ip 请求主机的ip ctx.request.ips ctx.ips 请求主机的ip数组 ctx.request.is(types) ctx.is(typs) 判断请求的类型 // With Content-Type: text/html; charset=utf-8 ctx.is(‘html’); // =&gt; ‘html’ ctx.is(‘text/html’); // =&gt; ‘text/html’ ctx.is(‘text/*’, ‘text/html’); // =&gt; ‘text/html’ ctx.is(‘text/json’) // =&gt; false ctx.request.accepts(types) ctx.accepts(types) 判断请求的类型是否为可接受的 // Accept: text/html ctx.accepts(‘html’); // =&gt; “html” ctx.request.acceptsEncoding() ctx.acceptsEncoding() 判断可接受的编码类型 // Accept-Encoding: gzip ctx.acceptsEncodings(‘gzip’, ‘deflate’, ‘identity’); // =&gt; “gzip” ctx.acceptsEncodings([‘gzip’, ‘deflate’, ‘identity’]); // =&gt; “gzip” ctx.request.acceptsCharset() ctx.acceptsCharset() 判断可接受的字符类型 // Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5 ctx.acceptsCharsets(); // =&gt; [“utf-8”, “utf-7”, “iso-8859-1”] ctx.request.accerptsLanguages() ctx.acceptsLanguages() 判断可接受的语言类型 // Accept-Language: en;q=0.8, es, pt ctx.acceptsLanguages(‘es’, ‘en’); // =&gt; “es” ctx.acceptsLanguages([‘en’, ‘es’]); // =&gt; “es” ctx.request.socket 返回request的socket连接对象 ctx.request.get(filed) 获得请求头字段 request.get(‘Content-Type‘) 6.ctx.response ctx.response.attributes alias Explian Demo ctx.response.header ctx.response.headers 响应头对象 ctx.response.socket 响应socket ctx.response.status ctx.status 获得/设置响应的状态码 ctx.status=200 ctx.status // =&gt; 304 ctx.response.message ctx.message 获得/设置响应的状态码信息 ctx.message = ‘ok’ ctx.message // =&gt; ‘not found’ ctx.response.length ctx.length 获得/设置响应的长度 ctx.length = 199 ctx.length // =&gt; 300 ctx.response.body ctx.body 获得/设置响应体 ctx.body = ‘hello world’ ctx.body // =&gt; ‘123’ ctx.response.get(field) 获得相应头字段 ctx.response.get(‘Content-Type’) ctx.response.append(field,val) 添加响应头字段 ctx.response.append(‘Link’, ‘localhost’) ctx.response.set(object) ctx.set(object) 设置响应头信息 ctx.set({‘Etag’: ‘1234’, ‘Last-Modified’: date }) ctx.response.remove(field) ctx.remove(field) 删除响应头字段 ctx.remove(‘Content-Type’) ctx.response.type 获取/设置响应体类型 ctx.response.type // =&gt; text/html ctx.response.type = ‘image/png’ ctx.response.is(types) 判断响应体的类型 if(ctx.response.is(‘html’)) return ctx.response.redirect(url) ctx.redirect(url) 响应跳转 ctx.redirect(‘back’); ctx.redirect(‘back’, ‘/index.html’); ctx.redirect(‘/login’); ctx.redirect(‘http://google.com&#39;); ctx.response.attachment(filename) ctx.attachment(filename) 触发浏览器下载 ctx.response.headerSent ctx.headerSent 检查是否已经发送响应头 if (ctx.headerSent) { // do} ctx.response.lastModified ctx.lastModified 返回/设置Last-Modified响应头的日期对象 ctx.lastModified = new Date(); ctx.response.etag ctx.etag ctx.etag = crypto.createHash(‘md5’).update(ctx.body).digest(‘hex’); ctx.response.vary(field) ctx.response.flushHeaders() 刷新响应头，并开始响应体","categories":[],"tags":[]},{"title":"Html","slug":"html","date":"2018-07-30T07:13:44.511Z","updated":"2018-10-10T08:51:22.470Z","comments":true,"path":"2018/07/30/html/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/html/","excerpt":"","text":"html html总结 目录[TOC] html 组件 html imports 状态, 草案 垫片方案 引用google 的 webcomponents.js 1&lt;link rel=\"imports\" href=\"myFile.html\" /&gt; html标签meta 关键字 viewport 浏览器视窗大小 width = device-width 宽度等于设备宽度 Initial-scale=1 初始化大小为1(不缩放) Maxium-scale=1 最大尺寸为1 Minium-scale=1 最小尺寸为1 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maxium-scale=1\"&gt; description 网站描述(利于seo) 1&lt;meta name=\"description\" content=\"this is a superme website...\"&gt; screen-orientation 屏幕方向 portrait 强制竖向显示 1&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; format-detection 文本格式化方案 telephone=no 手机号不显示为拨号连接 1&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt; a超链接 a 标签跳转 123456789&lt;!-- 相同页面跳转 --&gt;&lt;a href=\"#my-place\"&gt;&lt;/a&gt;...&lt;div id=\"my-place\"&gt; &lt;/div&gt;&lt;!-- 不同页面跳转 --&gt;&lt;a href=\"space.html#my-place\"&gt;&lt;/a&gt; a标签下载 1&lt;a download=\"file_name\" href=\"file_path\"&gt;download&lt;/a&gt; a标签target 1234&lt;a src=\"test.html\" target=\"custom-iframe\"&gt;点击设定iframe链接&lt;/a&gt;&lt;iframe id=\"custom-iframe\"&gt; &lt;/iframe&gt; 取消焦点控制 1&lt;a tabindex=\"-1\" &gt;按tab 焦点不会聚焦到此a标签&lt;/a&gt; figure12345&lt;figure&gt; &lt;figcaption&gt;These words are the caption of the picture. This is called a ligature.&lt;/figcaption&gt; &lt;img src='ligature.svg'/&gt;&lt;/figure&gt; look like this Html 模版pug(jade) html 模板引擎，可以配合express koa做服务端渲染 pug在线文档 属性 123456a(href=&apos;www.bing.com&apos;,class=&apos;myClass&apos;) hello//- （）括号内普通属性属性之间空格或逗号, 空格后标签文字- var flag = truespan(class=flag ? &apos;light&apos; : &apos;dark&apos;)//- 变量表达式 - 之后","categories":[],"tags":[]},{"title":"web图形方案总结","slug":"Graphic","date":"2018-07-30T07:13:44.511Z","updated":"2018-10-01T14:59:28.289Z","comments":true,"path":"2018/07/30/Graphic/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Graphic/","excerpt":"","text":"Graphicweb前端常用图形处理 目录[TOC] SVG 简介：基于xml的矢量图形描述文件 展现方式 浏览器直接打开 html中标签引用 html中svg标签引入 css的background引入 123456789101112131415161718&lt;!-- simple.svg --&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\"&gt; &lt;circle cx=\"100\" cy=\"100\" r=\"90\" fill=\"#777\" /&gt; &lt;circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"#000\" /&gt; &lt;path d=\"M 50 100 A 50 50 0 0 0 150 160\" stroke=\"white\" stroke-with=\"3\" fill=\"none\" /&gt;&lt;/svg&gt;&lt;!-- img --&gt;&lt;img src=\"simple.svg\" width=\"100\" height=\"100\" /&gt;&lt;style&gt; .svg &#123; width: 200px; height: 200px; background: #07f url(simple.svg) repeat; fill: yellow; // 使用fill修改颜色而不是color &#125;&lt;/style&gt; 基本元素12345678910111213&lt;rect /&gt; &lt;circle /&gt; &lt;ellipse /&gt;&lt;line /&gt;// 折线&lt;polyline /&gt;// 多边形&lt;polygon /&gt;// 任意路径&lt;path /&gt; 基本属性fill, stroke, stroke-width, transform 基本图形样例 rect 1&lt;rect x=\"50\" y=\"50\" width=\"200\" height=\"200\" rx=\"10\" ry=\"30\" /&gt; circle 1&lt;circle cx=\"50\" cy=\"50\" r=\"100\" /&gt; ellipse 1&lt;ellipse cx=\"50\" cy=\"50\" rx=\"20\" ry=\"40\" /&gt; line 1&lt;line x1=\"0\" y1=\"50\" x2=\"87\" y2=\"500\" /&gt; polyline 1&lt;polyline points=\"30 20 100 500 30 89\" /&gt; polygon 1&lt;polygon points=\"20 20 30 58 59 59\" /&gt; canvas绘制路径12345678var ctx = canvas.getContext(‘2d’) // 获取canvas2d上下文canvas.getContext(‘webgl’) //获取3d对象ctx.beginPath() //开始绘制路径 //ctx.closePath() //连接起点终点ctx.moveTo(x,y) //设直线段的起点ctx.lineTo(x,y) //设置线段的终点ctx.lineWidth = 1.0 //设直线段宽度ctx.strokeStyle = ‘red’ //设直线段颜色ctx.stroke() //绘制线段 绘制矩形1234ctx.fillStyle = ‘yellow’ //填充色ctx.fillRect(x,y,w,h) //绘制实心矩形ctx.strokeRect(x,y,w,h) //绘制空心矩形ctx.clearRect(x,y,w,h) //清除矩形 绘制文本1234ctx.font = ‘20px bold Arial’ //设置字体，大小ctx.textAlign = ‘left’ //设置字体居中方式ctx.fileText(text,x,y) //绘制实心字体ctx.strokeText(text,x,y) //绘制空心字体 绘制圆形和扇形12//绘制扇形，anticlockwise 顺时针false，逆时针true，绘制扇形前需要调用beginPath方法ctx.arc(x,y,r,startAngle,endAngle,anticlockwise) 图像处理123456//绘制图像ctx.drawImage(img,x,y[,width,height]) ctx.getImageData(x,y,width,height) //获取图像信息imageData对象有一个data属性，它的值是一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255ctx.putImageData(imgData,x,y) 设置渐变色1234567//x1,y1起点坐标 x2，y2 终点坐标var gradient = ctx.createLinearGradient(x1, y1, x2, y2) gradient.addColorStop(0,color)gradient.addColorStop(1,color) //创见圆形渐变createRadialGradient(x1,y1,r1,x2,y2,r2) Icon图标引入方案svg使用icons8生成整张svg图像 ，按生成页提示名称引入svg 优点：可以任意改变颜色，缩放不会模糊,经编译后无bug 12345678910111213141516171819202122232425&lt;!-- use 标签引入svg路径 --&gt;&lt;i class=\"icon-2\"&gt; &lt;svg&gt; &lt;use xlink:href=\".../path/to/Default.min.svg#icon-2\"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/i&gt;&lt;style&gt; /* 改变大小和颜色 */ .icon-2 &#123; color: red； font-size: 24px； &#125;&lt;/style&gt;&lt;!-- 单独使用构造svg --&gt;&lt;svg width=\"32px\" height=\"32px\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;path d=\"M24,10c0-1.657-1.343-3-3-3c-0.68,0-1.301,0.235- 1.804,0.617C18.467,6.641,17.312,6,16,6 s-2.467,0.641-3.196,1.617C12.301,7.235,11.68,7,11,7c-1.657,0-3,1.343-3,3H6v12h3v3.134C8.701,25.307,8.5,25.63,8.5,26 c0,0.552,0.447,1,1,1c0.841,0,1.5-0.682,1.5-1.552V22h1v3.134c-0.299,0.173-0.5,0.496-0.5,0.866c0,0.552,0.447,1,1,1 c0.841,0,1.5-0.682,1.5-1.552V22h4v3.134c-0.299,0.173-0.5,0.496-0.5,0.866c0,0.552,0.447,1,1,1c0.841,0,1.5-0.682,1.5-1.552V22h1 v3.134c-0.299,0.173-0.5,0.496-0.5,0.866c0,0.552,0.447,1,1,1c0.841,0,1.5-0.682,1.5-1.552V22h3V10H24z M24,20H8v-8h16V20z M15,16 c0-0.552,0.448-1,1-1s1,0.448,1,1c0,0.552-0.448,1-1,1S15,16.552,15,16z M19,16c0-0.552,0.448-1,1-1s1,0.448,1,1 c0,0.552-0.448,1-1,1S19,16.552,19,16z M11,16c0-0.552,0.448-1,1-1s1,0.448,1,1c0,0.552-0.448,1-1,1S11,16.552,11,16z\" fill=\"currentColor\"&gt; &lt;/path&gt;&lt;/svg&gt; sprit图highCharts 图表绘制工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116highCharts.chart(el,options);var options = &#123; chart: &#123; type: 'spline', backgroundColor: '#031824', &#125;, title: &#123; text: '付费用户情况', style: &#123; color: '#fff' &#125;, &#125;, subtitle: &#123; text: '', &#125;, xAxis: &#123; type: 'datetime', //类别 linear, logarithmic, datetime or categories dateTimeLabelFormats: &#123; // don't display the dummy year month: '%e. %b', year: '%b', &#125;, title: &#123; text: '', style: &#123; color: '#fff' &#125;, &#125;, &#125;, yAxis: &#123; title: &#123; text: '', &#125;, min: 0, gridLineWidth: 1, // 格子线宽度 tickInterval: 0.5, //y轴单位间隔 dataLabels: &#123; enabled: true, //显示每一点的数据 &#125;, &#125;, tooltip: &#123; headerFormat: '&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br&gt;', pointFormat: '&#123;point.x:%e. %b&#125;: &#123;point.y:.2f&#125; m', &#125;, plotOptions: &#123; spline: &#123; marker: &#123; enabled: true, &#125;, &#125;, &#125;, series: [&#123; name: '付费用户', color: '#333', //数据线条颜色 allowPointSelect: true, //可选择此点 lineWidth: 5, //线条宽度 data: [ [Date.UTC(1970, 9, 21), 0], [Date.UTC(1970, 10, 4), 0.28], [Date.UTC(1970, 10, 9), 0.25], [Date.UTC(1970, 10, 27), 0.2], [Date.UTC(1970, 11, 2), 0.28], [Date.UTC(1970, 11, 26), 0.28], [Date.UTC(1970, 11, 29), 0.47], [Date.UTC(1971, 0, 11), 0.79], [Date.UTC(1971, 0, 26), 0.72], [Date.UTC(1971, 1, 3), 1.02], [Date.UTC(1971, 1, 11), 1.12], [Date.UTC(1971, 1, 25), 1.2], [Date.UTC(1971, 2, 11), 1.18], [Date.UTC(1971, 3, 11), 1.19], [Date.UTC(1971, 4, 1), 1.85], [Date.UTC(1971, 4, 5), 2.22], [Date.UTC(1971, 4, 19), 1.15], [Date.UTC(1971, 5, 3), 0], ], &#125;, &#123; name: '免费用户', data: [ [Date.UTC(1970, 9, 29), 0], [Date.UTC(1970, 10, 9), 0.4], [Date.UTC(1970, 11, 1), 0.25], [Date.UTC(1971, 0, 1), 1.66], [Date.UTC(1971, 0, 10), 1.8], [Date.UTC(1971, 1, 19), 1.76], [Date.UTC(1971, 2, 25), 2.62], [Date.UTC(1971, 3, 19), 2.41], [Date.UTC(1971, 3, 30), 2.05], [Date.UTC(1971, 4, 14), 1.7], [Date.UTC(1971, 4, 24), 1.1], [Date.UTC(1971, 5, 10), 0], ], &#125;, &#123; name: '总用户', data: [ [Date.UTC(1970, 10, 25), 0], [Date.UTC(1970, 11, 6), 0.25], [Date.UTC(1970, 11, 20), 1.41], [Date.UTC(1970, 11, 25), 1.64], [Date.UTC(1971, 0, 4), 1.6], [Date.UTC(1971, 0, 17), 2.55], [Date.UTC(1971, 0, 24), 2.62], [Date.UTC(1971, 1, 4), 2.5], [Date.UTC(1971, 1, 14), 2.42], [Date.UTC(1971, 2, 6), 2.74], [Date.UTC(1971, 2, 14), 2.62], [Date.UTC(1971, 2, 24), 2.6], [Date.UTC(1971, 3, 2), 2.81], [Date.UTC(1971, 3, 12), 2.63], [Date.UTC(1971, 3, 28), 2.77], [Date.UTC(1971, 4, 5), 2.68], [Date.UTC(1971, 4, 10), 2.56], [Date.UTC(1971, 4, 15), 2.39], [Date.UTC(1971, 4, 20), 2.3], [Date.UTC(1971, 5, 5), 2], [Date.UTC(1971, 5, 10), 1.85], [Date.UTC(1971, 5, 15), 1.49], [Date.UTC(1971, 5, 23), 1.08], ], &#125;],&#125;;","categories":[],"tags":[]},{"title":"chrome 浏览器接口参考","slug":"Bowser","date":"2018-06-19T02:30:44.534Z","updated":"2018-10-01T15:02:34.987Z","comments":true,"path":"2018/06/19/Bowser/","link":"","permalink":"http://zexiplus.github.io/2018/06/19/Bowser/","excerpt":"","text":"chrome.runtime chrome浏览器接口 Table of contents[TOC] chrome.runtime summary 链接 Methods &amp; properties connect, id, getURL, getMainifest, onMessage, sendMessage, onConnect 123456789101112// propertieschrome.runtime.id // the id of the extension/app// methods// connectchrome.runtime.connect(string id, object connectInfo)// sendMessagechrome.runtime.sendMessage(string id, any message, object options, function reponseCallback)// onMessagechrome.runtime.onMessage.addListener(function callback) 插件和页面消息传递 链接 content.js 1234567891011121314// 从页面js发送消息到chrome插件chrome.runtime.sendMessage(&#123;greeting: \"您好\"&#125;, function(response) &#123; console.log(response.farewell);&#125;);// 页面监听浏览器插件发送的消息chrome.runtime.onMessage.addListener( function(request, sender, sendResponse) &#123; console.log(sender.tab ? \"来自内容脚本：\" + sender.tab.url : \"来自扩展程序\"); if (request.greeting == \"您好\") sendResponse(&#123;farewell: \"再见\"&#125;); &#125;); plugin.js 123456// 在扩展程序中与页面通讯chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function(tabs) &#123; chrome.tabs.sendMessage(tabs[0].id, &#123;greeting: \"您好\"&#125;, function(response) &#123; console.log(response.farewell); &#125;);&#125;);","categories":[],"tags":[]},{"title":"ElementUI 踩坑记录","slug":"ElementUI","date":"2018-06-14T01:15:27.740Z","updated":"2018-10-01T14:57:26.562Z","comments":true,"path":"2018/06/14/ElementUI/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/ElementUI/","excerpt":"","text":"elementUiel-table自定义表头jsx实现 1234567891011121314151617181920212223242526&lt;template&gt; &lt;el-table&gt; &lt;el-table-column :render-header=&quot;renderHeader&quot;&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; renderHeader() &#123; return (&lt;div class=&quot;readlist-table-header&quot;&gt; &lt;a class=&#123;[&quot;readtab&quot;,&#123;&quot;active&quot;:!this.readStatus&#125;]&#125; href=&quot;javascript:void(0)&quot; onClick=&#123;this.toUnread&#125;&gt; 未读（&lt;span&gt;&#123;this.tData.unreadNum&#125;&lt;/span&gt;） &lt;/a&gt; &lt;a class=&#123;[&quot;readtab&quot;,&#123;&quot;active&quot;:this.readStatus&#125;]&#125; href=&quot;javascript:void(0)&quot; onClick=&#123;this.toUnread&#125;&gt; 已读（&lt;span&gt;&#123;this.tData.readedNum&#125;&lt;/span&gt;） &lt;/a&gt; &lt;/div&gt;); &#125;, toUnread() &#123; console.log(...) &#125; &#125; &#125;&lt;/script&gt;","categories":[],"tags":[]},{"title":"人工智能框架tensorflow学习总结","slug":"Tensorflow","date":"2018-06-14T01:12:28.962Z","updated":"2018-09-29T16:37:56.152Z","comments":true,"path":"2018/06/14/Tensorflow/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Tensorflow/","excerpt":"","text":"config &amp;&amp; use ####激活virtualenv 12345678910# 建立全新的virtualenv $ virtualenv --system-site-packages ~/tensorflow$ cd ~/tensorflow$ source bin/activate # 如果使用 bash$ source bin/activate.csh # 如果使用 csh(tensorflow)$ # 终端提示符应该发生变化# 使用完tensorflow后退出(tensorflow)$ deactivate","categories":[],"tags":[]},{"title":"Regexp 正则表达式实用总结","slug":"Regexp","date":"2018-06-14T01:12:28.961Z","updated":"2018-09-29T16:23:17.479Z","comments":true,"path":"2018/06/14/Regexp/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Regexp/","excerpt":"","text":"正则表达式学习笔记1234567891011121314151617181920212223242526272829303132333435363738394041- 作为元字符只能用在[] 例如[a-z] 除此之外不需要转义 /-\\d/ ，匹配-5 # 也是普通字符，不需转义^ 取非匹配 [^a-z] 用在[]表示除a-z以外的所有字符\\[ 要匹配特殊字符[ 必须转义，例如匹配myArr[8] --- 模式为 myArr\\[[0-9]\\]单个匹配空白符 \\r 回车 \\n 换行 \\t 制表符任一空白符 \\s === [\\r\\t\\n\\f\\v]任意数字 \\d === [0-9] 非数字 \\D === [^0-9]任意字母数字下划线 \\w === [0-9a-zA-z_] 非数字字母下划线 \\W === [^0-9a-zA-z_]+ 匹配至少一个字符(贪婪形多多益善) +？匹配至少一个字符（懒惰型满足就返回) * 匹配0次或多次（贪婪形多多益善）*? 匹配0次或多次（懒惰型满足就返回）？ 匹配0个或1个&#123;3&#125; 匹配3次才算一次匹配&#123;2，4&#125; 匹配最少2次，最多4次&#123;3，&#125; 匹配至少重复3次/ 正斜杠不用转义\\b boundary 单词边界，单词的开始或结尾\\B 非边界^ 字符串开头位置$ 字符串结尾位置","categories":[],"tags":[]},{"title":"树莓派 调试开发配置指南","slug":"Raspberry","date":"2018-06-14T01:12:28.961Z","updated":"2018-09-29T16:19:01.281Z","comments":true,"path":"2018/06/14/Raspberry/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Raspberry/","excerpt":"","text":"系统设置App软件源 文件位置 /etc/apt/sources.list Ip地址 //ip 192.168.17.149 wlan 192.168.41.89 Mjpg-streamer 使用 1./mjpg_streamer -i \"./input_uvc.so -d /dev/video0 -n -y -f 25 -r 640x480\" -o \"./output_http.so -n -w /usr/local/www\" 访问：http://localhost:8080/?action=stream 改变文件权限 1chmod 751 file 三个数字从左到右（用户，用户组，其它成员） 4：读取，2：写入，1：执行【7 = 所有权限】 把可执行文件设为全局命令 1ln -s name /usr/local/bin/name boot设置 1sudo raspi-config wringPi 1 引脚可以设置为servo模式new five.Pin({pin:1,mode:4}) wifi 设置 12345//搜索附近wifiiwlist scan //编辑文件设置密码sudo vim /etc/wpa_supplicant/wpa_supplicant.conf windows 环境变量设置set //显示全部环境变量set Path=… //设置环境变量path linux 显示环境变量env 查看端口占用情况netstat mac os ssh 连接树莓派1$ ssh pi@192.168.17.149 我的树莓派设置vnc 密码 12341234 wiringPi引脚定义，图例如下 fritizing 使用说明资源库","categories":[],"tags":[]},{"title":"Python 学习总结","slug":"Python","date":"2018-06-14T01:12:28.960Z","updated":"2018-09-29T16:18:23.446Z","comments":true,"path":"2018/06/14/Python/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Python/","excerpt":"","text":"usage12# 手动下载库函数pip install pandas Tip 是索引-1返回列表最后一个元素，-2 返回倒数第二个… [1,2,3][-1] # return 3 ** 表示乘方 , 3 ** 2 # return 9 命令行键入 quit() + 回车 退出命令行 列表末尾增加元素 list.append()。 插入 list.insert(index, el)。 删除元素del list[0]。删除并弹出最后一个list.pop()。 删除并弹出任一项list.pop(index) 。 根据值删除元素list.remove(value)并使用，如果有重复只删除第一个。 语句末尾无分号，注释用 # 去除字符串右边空格（空行/换行符等） str.rstrip(), 去除左边空格 str.strip() ​ 排序 list.sort(reverse=True) #按字母反向排序 , 临时排序 list2 = list.sorted(). 长度 len(list) for 循环 for 语句以：结尾， 下一行有缩进 1234dogs = [‘harmi’, ‘lucy’, ‘catty’]for dog in dogs: pring('welcome' + dog) ​ 生成数字列表 list(range(1,5)), # returns [1,2,3,4],指定步长 list(range(5,10,2)),# returns [5,7,9] 列表统计计算 list = [1,2,3] min(list) # returns 1,max(list) #returns 3,sum(list) #returns 6 列表解析 a = [value \\ 2** for value in range(1,5)] #returns [1,4,9,16] 列表切片 list = [1,2,3,4,5] list[1:3] # returns [2,3], list[:3] # returns [1:2,3], list[1:] # returns [2,3,4,5] 复制列表 list2 = list[:] 定义元祖（不可改变其中元素的列表） dimensions = (1,2,3,4,5) 条件判断 与 and , 或 or , 存在于 in , 例如： 1 in (1,2,3) # returns True，不包含 not in 等于 == ,大于等于 &gt;= ,取非 not if语句 if condition_test: if []: 不会执行，空数组的布尔值等于false 字典定义 alien = {‘color’: ‘red’, num: 5}, 访问值 alien[‘color’] # returns ‘red’ , 删除键值 del alien[‘red’] 23.字典遍历12345678910111213141516171819# 遍历键值for key,value in alien.items(): print(key+':'+value) # 遍历键for key in alien.keys(): print(key) # 遍历值for val in alien.values(): print(val) # 顺序遍历键for key in sorted(alien.keys()): print(key)# 遍历不重复的集合for key in set(alien.values()): print(key) input()用户输入 message = input(‘give some tips’) ， 输入的文字被视为字符串，格式化为数字 message=int(message) 函数 12345678910111213141516171819# 定义函数def fn(): \"\"\"此处为文档字符串，描述函数功能，以三个引号起始\"\"\" print('hello word') # 默认值函数def fn(a=1, b=2): print(a,b) # 传递任意数量的参数, *会创建一个args 的空元组，然后依次入参def fn(*args): print(args)fn(1,2,3,4) # returns (1,2,3,4)# 传递任意数量的关键字形参 ，** 会创建一个空字典，并将收到的键值对装进这个空字典def fn(**dir): for key,val in dir: print(key,val)fn(a = 1, b = 2 ) # returns &#123;'a': 1, 'b': 2&#125; 模块 1234567891011121314151617# 整体导入import module_name # 调用模块的函数module_name.fn()# 导入特定的函数from module_name import fnfn()# as 给导入的函数起别名from module_name import function_name as fn# as 给导入的模块取别名import module_name as mn# 导入模块中的所有函数 , 引入之后元模块中所有的变量都可以直接使用from module_name import * 类 12345678910111213141516171819202122232425262728# 创建类class Dog(): \"\"\"模拟小狗\"\"\" def __init__(self, name, age): \"\"\"初始化函数,每次实例化时会自动调用\"\"\" self.name = name, self.age = age def jump(self): \"\"\"模拟小狗跳\"\"\" print('dog' + self.name + 'is jumping')# 实例化haski = Dog('haski', 2)# 继承类class Parent(): \"\"\"我是父类\"\"\" def __init__(self, name, age): self.name = name self.age = age def some_fn(self): print('i am ' + self.name):class Sub(Parent): def __init__(self, name, age): self.name = name self.age = age 读写文件 123456789101112131415161718192021222324252627282930# 打开文件读取with open('some.txt') as file: contents = file.read() print(contents)# 逐行读取with open('some.txt') as file: for line in file: print(line) # 读取文件赋值给列表with open(some.txt) as file: lines = file.readLines()for line in lines: print(line.strip())# 打开文件模式 , 第二个参数 mode 为 a追加, w写入, r读取(默认), r+读写 open('some.txt', 'w')# 使用json存储数据 json.dump(data, json_obj)import jsonnumbers = [1,2,3,4,5]with open('temp.json', 'w') as json_obj: json.dump(numbers, json_obj) # 读取json文件import jsonwith open('temp.json', 'r') as json_obj: number = json.load(json_obj)print(number) ​","categories":[],"tags":[]},{"title":"开发常见问题疑难解答","slug":"Puzzle","date":"2018-06-14T01:12:28.960Z","updated":"2018-09-29T16:17:54.057Z","comments":true,"path":"2018/06/14/Puzzle/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Puzzle/","excerpt":"","text":"why /\\d{6}/.test(‘440303008000’) //true 要只匹配6个数字 /^\\d{6}$/.test(‘1234566565’) //false Unexpected side effect in “sortArr” computed property 1234//vue 计算属性 ， this es-lint报错sortArr() &#123; return this.rankData.sort((prev, next) =&gt; next.value - prev.value);&#125; 原因 side effect 修改了原数据（data或prop） 正确做法 123sortArr() &#123; return this.rankData.slice(0).sort((prev, next) =&gt; next.value - prev.value);&#125; process变量在vue的静态环境和开发环境是否存在 12// 开发环境，无论是&lt;script&gt;标签还是mounted均存在// 静态环境（node http-server服务器和apache服务器均可） 无论是&lt;script&gt;标签还是mounted均存在 npm install 时 报错, 解决：删除package-lock.json继续下载 1Unexpected token &lt; in JSON at position 25997","categories":[],"tags":[]}]}