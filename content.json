{"meta":{"title":"Float's blog","subtitle":"float's blog","description":"float's blog | 浮躁哥的技术博客","author":"float","url":"http://zexiplus.github.io"},"pages":[],"posts":[{"title":"nodejs 实用库收录","slug":"node-library","date":"2018-09-13T08:21:06.808Z","updated":"2018-09-29T16:16:36.242Z","comments":true,"path":"2018/09/13/node-library/","link":"","permalink":"http://zexiplus.github.io/2018/09/13/node-library/","excerpt":"","text":"node package librarynodejs 实用仓库收录, 下载/使用方法总结 https://github.com/zexiplus/awesome-nodejs Table of contents[TOC] package.json scripts12345678910&#123; \"scripts\": &#123; \"prebuild\":…., // npm run build 前执行 \"build\":…., \"postbuild\":…. // npm run build 后执行 &#125;, \"bin\": &#123; \"command\": \"./bin/script.js\" &#125;&#125; package structor Folder Use bin 命令行脚本 docs 文档 example 例子 lib 程序的核心功能 test 测试脚本及相关资源 npm script 初始化仓库 1npm init 登录 npm 账号 1npm login 发布包 1npm publish 全剧链接 可以让包在机器上全局使用 bin 命令 123sudo npm linksudo npm unlink bin 文件 12#!/usr/bin/env nodeconsole.log('hello world') 自定义参数 自定义参数 – 会把之后的所有参数存入process.argv 12345npm run command -- --someArg npm run -- --test# index.jsprocess.argv.includes('--test') // true 锁定版本 1npm shrinkwrap 设置镜像 1npm config set registry http://registry.npmjs.org node packagesmoment 时间格式化库 https://github.com/moment/moment 1npm i moment 12345678910//es6 import引入import moment from 'moment' //nodejs 引入var moment = require('moment')//把时间对象格式化为文本 2018-01-09 12:14:27moment(new Date).format('YYYY-MM-DD hh:mm:ss')//把文本解析为date对象 moment('2018-01-09 12:14:27') rollup 整合多个js文件到一个js文件 https://github.com/rollup/rollup#quick-start-guide 1npm i rollup 1234567891011121314const path = require('path')const rollup = require('rollup').rolluprollup(&#123; input: path.resolve(__dirname, '../src/vue.js')&#125;).then((bundle) =&gt; &#123; bundle.write(&#123; file: path.resolve(__dirname, '../dist/vue.js'), format: 'umd', name: 'Vue' &#125;)&#125;).catch((e) =&gt; &#123; console.error(e)&#125;) busboy 文件上传 https://github.com/mscdex/busboy 1npm i busboy 123456789101112131415161718const Busboy = require('busboy')const http = require('http')http.createServer((req, res) =&gt; &#123; var busboy = new Busboy(&#123; headers: req.headers &#125;); busboy.on('file', function(fieldname, file, filename, encoding, mimetype) &#123; var saveTo = path.join(os.tmpDir(), path.basename(fieldname)); file.pipe(fs.createWriteStream(saveTo)); &#125;); busboy.on('finish', function() &#123; res.writeHead(200, &#123; 'Connection': 'close' &#125;); res.end(\"That's all folks!\"); &#125;); return req.pipe(busboy); &#125; res.writeHead(404); res.end();&#125;).listen(3000) opn 预览文件插件 浏览器/图片 https://github.com/sindresorhus/opn 1npm i opn 12345678var opn = require('opn') open('http://localhost:8080')opn('unicorn.png').then(() =&gt; &#123; // 预览图片&#125;);opn('http://sindresorhus.com', &#123;app: 'firefox'&#125;); supervisor 检测node.js代码变化， 自动重启脚本 https://github.com/petruisfan/node-supervisor 12345# download$ sudo npm i -g supervisor# use supervisor test.js mocha 用于node测试代码 https://mochajs.org/ 12345# download$ sudo npm i -g mocha# usemocha test.js test.js 12345678var assert = require('assert');describe('Array', function() &#123; describe('#indexOf()', function() &#123; it('should return -1 when the value is not present', function() &#123; assert.equal([1,2,3].indexOf(4), -1); &#125;); &#125;);&#125;); should.js BDD 风格（behavior driven development) 测试库，是assert模块的扩展 https://github.com/shouldjs/should.js 1npm i should -D 1234567891011121314151617181920212223var should = require('should')var user = &#123; name: 'tj' , pets: ['tobi', 'loki', 'jane', 'bandit']&#125;;user.should.have.property('name', 'tj');user.should.have.property('pets').with.lengthOf(4);// If the object was created with Object.create(null)// then it doesn't inherit `Object.prototype`, so it will not have `.should` getter// so you can do:should(user).have.property('name', 'tj');// also you can test in that way for null'sshould(null).not.be.ok();someAsyncTask(foo, function(err, result)&#123; should.not.exist(err); should.exist(result); result.bar.should.equal(foo);&#125;); uglifyjs 压缩混淆代码工具 node-notifier 跨平台的系统通知插件 https://github.com/mikaelbr/node-notifier 1npm install node-notifier 123456const notifier = require('node-notifier')notifier.notify('message')notifier.nogiry(&#123; title: 'My title', message: 'hello world'&#125;) ora 界面友好的交互式输出工具 spinner https://github.com/sindresorhus/ora 1234567npm i oraconst spinner = ora('Loading unicorns').start();setTimeout(() =&gt; &#123; spinner.color = 'yellow'; spinner.text = 'Loading rainbows';&#125;, 1000); ansi.js 彩色化命令行 文字, 前景色, 背景色 https://github.com/TooTallNate/ansi.js 1npm install ansi 1234567891011const ansi = require('ansi'), cursor = ansi(process.stdout)// You can chain your calls forever:cursor .red() // Set font color to red .bg.grey() // Set background color to grey .write('Hello World!') // Write 'Hello World!' to stdout .bg.reset() // Reset the bgcolor before writing the trailing \\n,// to avoid Terminal glitches .write('\\n') // And a final \\n to wrap things up chalk 彩色化输出 https://github.com/chalk/chalk 1npm i chalk 12345678const chalk = require('chalk')console.log(chalk.red('hello'))// 自定义const error = chalk.bold.redconst info = chalk.keyword('origin')console.log(error('error occured'))console.log(info('be careful origin')) commander.js 创建命令行工具的库 https://github.com/tj/commander.js 1npm install commander --save 基本用法 12345678910111213141516#!/usr/bin/env nodeconst programe = require('commander')programe.version(require('../package.json').version)programe .command('init [env]') // 命令名称 .alias('i') // 简称 .description('init a project') // 描述 .option('-s --setup_mode [mode]', 'which setup mode to use') .action((env, options) =&gt; &#123; // 执行命令的回调函数 let mode = options.setup_mode env = env || 'dev' &#125;)programe.parse(process.argv) API version 版本 1programe.version('1.2.3', '-v --version') 123programe --versionprograme -v# returns 1.2.3 option 选项 与参数不同的是 option 不区分顺序 12345programe .option('-p --peppers', 'Add peppers') .parse(process.argv)console.log(programe.peppers) // true 12programe -p# true command 命令 12345programe .command('list &lt;num&gt;') .action((num) =&gt; &#123; conosle.log(num) &#125;) 12programe list 10# log 10 命令必选参数 \\ 1234567programe .command('rm &lt;dir&gt;') .option('-r --recursive') .action((dir, cmd) =&gt; &#123; console.log(dir) console.log(cmd.recursive) &#125;) 123programe rm /bin# /bin# false 命令可选参数 [param] 12345678programe .command('rm &lt;dir&gt; [otherdirs...]') .action((dir, otherdirs) =&gt; &#123; console.log(dir) if (otherdirs) &#123; othersdirs.forEach((item) =&gt; &#123; console.log(item) &#125;) &#125; &#125;) arguments 声明参数 12345programe .arguments('&lt;dir&gt; [env]') .action((dir, env) =&gt; &#123; &#125;) 正则参数 12345programe .option('-s --size &lt;size&gt;', 'dick size', /^(large|medium|small)$/i, 'medium') .action(cmd =&gt; &#123; console.log(`dick size is $&#123;cmd.size&#125;`) &#125;) 12programe -s 18# log medium usage 使用提示 1programe.usage('command [option] &lt;param&gt;') 12programe# returns Usage: programe command [option] &lt;param&gt; 参数列表 1programe chromix-too, chromix 控制浏览器刷新, 关闭, 重启, 不支持windows系统 npm https://www.npmjs.com/package/chromix-too chrome插件 chromix-too 1234567891011121314151617181920212223# 下载npm i -g chromix-too# 启动服务chromix-too-server# 查看浏览器列表chromix-too ls# 输出如下17 https://blog.zfanw.com/webpack-tutorial/ webpack 4 教程373 https://www.npmjs.com/package/chromix-too chromix-too - npm# focus a tabchromix focus https://blog.zfanw.com/webpack-tutorial# 刷新某页面chromix reload https://blog.zfanw.com/webpack-tutorial# 打开新的页面chromix open https://blog.zfanw.com/webpack-tutorial# 通过id 关闭页面chromix rm 17 12// module useconst chromix = require('chromix-too')().chromix shields git repository 图标生成工具 https://github.com/badges/shields 12npm install -g gh-badgesbadge build passed :green .png &gt; mybadge.png Inquirer.js 命令行用户交互界面库 https://github.com/sboudrias/Inquirer.js 1npm i inquirer 单个询问 1234567891011const inquirer = require('inquirer')let prompt = inquirer.createPromptModule()let options = &#123; type: 'list | rawlist | expand | checkbox | confirm | input | password | editor', name: 'question name', choices: ['1', '2', '3 hello']&#125;prompt(options).then(cb) 多个询问 12345678910const inquirer = require('inquirer')inquirer .prompt([ option1, option2, option3, ]) .then(anwser =&gt; &#123; &#125;) prerender.io 服务端渲染 https://prerender.io/ js-cookie 操作cookie https://github.com/js-cookie/js-cookie Install 1npm i js-cookie usage 1Cookies.set('name', 'value', &#123; expires: 7 &#125;) // 七天过期时间 http-server http静态服务器 https://github.com/indexzero/http-server install 1npm i -g http-server usage 123456789http-server [path] [optionis]# demo# 指定8080端口http-server -p 8080# 指定ip地址http-server -a 0.0.0.0 hexo博客搭建生成器 https://github.com/hexojs/hexo install 1npm install hexo-cli -g usage 12345hexo init blogcd blog# 启动静态页面服务器hexo server","categories":[],"tags":[]},{"title":"工作踩坑总结记录","slug":"experience","date":"2018-09-08T07:02:19.061Z","updated":"2018-10-01T14:58:02.399Z","comments":true,"path":"2018/09/08/experience/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/experience/","excerpt":"","text":"experience工作踩坑总结 vue 的 router-link 绑定click事件绑定不上，需要在原生元素上绑定. **@click.native** 1&lt;router-link @click.native=\"handleClick\" &gt;&lt;/router-link&gt; 在vue中绑定html 字符串, 使用 v-html 指令 1&lt;div v-html=\"htmlTemplate\"&gt;&lt;/div&gt; a 链接 控制 iframe跳转 1234&lt;a href=\"target.html\" target=\"iframepage\"&gt;&lt;/a&gt;&lt;iframe id=\"iframepage\"&gt; &lt;/iframe&gt; 通过a标签访问javascript函数 1&lt;a href=\"javascript:dosomething();\"&gt;&lt;/a&gt;","categories":[],"tags":[]},{"title":"系统/软件快捷键收录","slug":"shortCuts","date":"2018-09-08T06:57:48.423Z","updated":"2018-10-08T12:50:43.100Z","comments":true,"path":"2018/09/08/shortCuts/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/shortCuts/","excerpt":"","text":"shortcuts 保存了系统/软件常用快捷键,以便查看使用 ←↑→↓ windows windows系统快捷键说明 快捷键 在当前文件夹下打开cmd窗口 shift + rightMouse mac mac 快捷键说明 快捷键 锁屏 ctrl + command + q 搜索文件 command + 空格 工作区缩略图 Ctrl + Tab 打开App菜单 option + A 打开launchpad option + D 更改文件默认启动软件 鼠标右键 / getinfo / open with 系统截全屏 command + shift + 3 截部分屏幕 command + shift + 4 连接远程文件夹 command+ k 预览图片 选中图片 + space vsCode 插件介绍 https://zhuanlan.zhihu.com/p/27905838 修改编辑器快捷键 code/ 首选项/ 键盘快捷方式 vsCode 快捷键说明 按键 开启命令面板 command + shift + p 转到定义 command + option + ↓ 开启/切换终端面板 ctrl + ` 格式化代码 option + shift + f 把文件夹在 finder 中显示 command + option + R 向上移动行 option + ↓ 预览markdown文件 command + K V 启用调试 F5 启用多行编辑 option + 鼠标选择 在文件夹中查找 command + shift + F 启用quokka command + K Q 停用quokka command + K S 使用markdonw toc 插件生成文档目录 markdown 中右键 , markdown toc insert 使用expand-region 选中括号内内容 command + shift + M 注册code 系统命令 command + shift + P &gt; shell code 在命令行中使用vscode code main.js 插入假数据 命令面板 输入 faker sublime sublime快捷键说明 快捷键 编译执行代码 ctrl + B 复制当前行到下一行 ctrl + shift + d 移动当前行 ctrl + shift + 上下左右箭头 选中花括号里面的全部内容 Ctrl+Shift+M 可快速选中一行中的某一部分 shift + ctrl然后按←或→ chrome chrome 快捷键说明 快捷键 重新打开刚关闭的页面 Shift + Ctrl + T (mac) 打开开发者工具 option + commond + I (mac) 清除系统缓存 command + shift + back (mac) 后退 command + [","categories":[],"tags":[]},{"title":"Vue插件使用技巧","slug":"vue-plugins","date":"2018-09-08T06:57:48.423Z","updated":"2018-09-29T16:38:38.679Z","comments":true,"path":"2018/09/08/vue-plugins/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/vue-plugins/","excerpt":"","text":"Vue Pluginsvue 插件收录, 用法 Table of content[TOC] prerender-spa-plugin 预渲染插件， 提升首屏徐然速度， seo优化 https://github.com/chrisvfritz/prerender-spa-plugin vue-server-renderer 服务端渲染插件 Vue-axios 客户端ajax 请求插件 git repo 创建ajax实例对象 axios.create(options) 123456axios.create(&#123; baseURL: 'http://localhost:3000', timeout: 1000, headers: &#123;'X-Custom-Header': 'football'&#125;, withCredentials: true,&#125;) 全局ajax请求拦截 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//挂载请求拦截器var interceptor = axios.interceptors.request.use(function (config) &#123; // 对请求进行设置（格式。。。）返回config if (config.method === 'post') &#123; config.headers['Content-Type'] = 'application/x-www-form-urlencoded'; &#125; return config;&#125;, function (error) &#123; // 失败操作 alert('操作失败') return Promise.reject(error);&#125;);//取消拦截器axios.interceptors.request.eject(interceptor)/* -------------------响应拦截器，可处理失败响应等等 --------------------- */axios.interceptors.response.use(function (response) &#123; //根据响应状态吗判断 if (response.status !== 200) &#123; alert('服务器异常'); return Promise.reject(response); &#125; //根据响应返回信息判断 else if (response.data.ret !== 0) &#123; alert(ERR_CODE[response.data.ret] || '操作失败'); //返回失败态promise return Promise.reject(response.data.ret_msg); &#125; return response;&#125;, function (error) &#123; // 错误处理 return Promise.reject(error);&#125;);/* ------------------ Promise.all应用(多项操作，但接口不支持多个) --------------------- */&#123; arr: [1,2,4,5] getById(id) &#123; // service接口请求，返回promise实例 return this.service.getById(id) &#125; getByIds() &#123; new Promise.all(this.arr.map(item =&gt; this.getById(item))).then(results =&gt; &#123; this.getList() &#125;).catch((err) =&gt; &#123; alert('请求出错') &#125;) &#125;&#125; 分离服务 service 123456789101112131415161718192021222324252627```jsimport api from &apos;./api&apos;import axios from &apos;axios&apos;const ajax = axios.create(&#123; timeout: 3000&#125;)const service = &#123; device: &#123; getList(params) &#123; return ajax.get(api.device.getList, params) &#125; &#125;, user: &#123; saveInfo(params) &#123; return ajax.post(api.user.saveInfo, params) &#125; &#125;&#125;export default &#123; install(V, options) &#123; V.prototype.$service = service &#125;&#125; 1234```jsimport service from &apos;./service&apos;Vue.use(service) 1234567891011```jsexport default &#123; methods: &#123; getList() &#123; this.$service.getList().then(res =&gt; &#123; // to do something &#125;) &#125; &#125;&#125; vue router vue 路由 参考链接 this.\\$route 代表当前页面的url封装对象,url不同对应不同的route对象 1234567891011121314&#123;name: \"mainFrame\", meta: &#123;…&#125;, path: \"/mainFrame\", hash: \"\", query: &#123;…&#125;, …&#125;// this.$route.matched 表示vue-router 实例 匹配的模式&#123; name: 'page2', path: 'page2', // 对应的浏览器url为 localhost:8080/mainFrame/page2 component: page2&#125;, // this.$route.query /path?name=xiaoxiix&amp;id=123&#123; name: 'xiaoxixi', id: '123'&#125; this.$router router 代表vue-router全局对象，全局唯一 123456789101112131415&#123;app: Vue, apps: Array(1), options: &#123;…&#125;, beforeHooks: Array(0), resolveHooks: Array(0), …&#125;// 浏览器会生成一条历史记录，后退键可用this.$router.push('home') // 浏览器地址变为 localhost/dynamicCom/123this.$router.push(&#123;name: 'dynamicCom', &#123; params: &#123; id: '123' &#125; &#125; &#125;)this.$router.push(&#123;name: 'dynamicCom', &#123;query: &#123;name: 'xiaoxixi'&#125;&#125;&#125;)// router.replace() 浏览器不会生成历史记录，用法和push一致this.$router.replace()// router.go(n)this.$router.go(-1) // 浏览器后退一步this.$router.go(2) // 前进两步 using 123456789101112```html&lt;template&gt; &lt;div&gt; &lt;router-view/&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;!-- 命名路由视图 --&gt; &lt;router-link to=&quot;/user&quot;&gt;user&lt;/router-link&gt; &lt;router-link :to=&quot;&#123; name: &apos;setting&apos; &#125;&quot;&gt;main&lt;/router-link&gt; &lt;router-link :to=&quot;&#123; name: &apos;page1&apos; &#125;&quot;&gt;link1&lt;/router-link&gt; &lt;router-link :to=&quot;&#123; name: &apos;page2&apos; &#125;&quot;&gt;link2&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 1234567```jsimport router from &apos;./router&apos;new Vue(&#123; el: &apos;#app&apos;, router,&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111```jsimport Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;// 引入组件import mainFrame from &apos;@/components/mainFrame&apos;import dynamicCom from &apos;@/components/dynamicCom&apos;const page1 = () =&gt; import(&apos;@/components/page1&apos;)const page2 = () =&gt; import(&apos;@/components/page2&apos;)Vue.use(Router)const router = new Router(&#123; // 控制滚动行为，如果有上次访问同一页面的位置，则返回相同的位置，否则跳转到 x: 300, y: 800 位置 scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 300, y: 800 &#125; &#125; &#125;, routes: [ &#123; path: &apos;/mainFrame&apos;, name: &apos;mainFrame&apos;, component: mainFrame, // 嵌套子路由 children: [ &#123; name: &apos;page1&apos;, path: &apos;/page1&apos;, // 对应的浏览器url为 localhost:8080/page1 component: page1, meta: &#123; needAuth: true, &#125; &#125;, &#123; name: &apos;page2&apos;, path: &apos;page2&apos;, // 对应的浏览器url为 localhost:8080/mainFrame/page2 component: page2 &#125;, &#123; name: &apos;page3&apos;, path: &apos;page3&apos;, redirect: &#123; name: &apos;page2&apos; &#125;, // 重定向路由，重定向至路由name: &apos;page2&apos; &#125;, &#123; path: &apos;/page2&apos;, alias: &apos;/page4&apos;, // 别名路由，访问localhost:8080/page4 和 访问 ../page2 一致 component: page2, &#125;, &#123; name: &apos;nameRouter&apos;, path: &apos;nameRouter&apos;, components: &#123; default: nameView, a: viewA &#125; &#125;, // 属性路由,组件可以接受路由中的参数作为props &#123; name: &apos;propsRouter&apos;, path: &apos;props/:name&apos;, // 访问../props/xiaoxixi 组件name属性为&apos;xiaoxixi&apos; component: propsRouter, props: true, &#125;, &#123; name: &apos;propsRouter&apos;, path: &apos;props/:name&apos;, // 访问../props/xiaoxixi 组件name属性为&apos;daxixi&apos; component: propsRouter, props: &#123;name: &apos;daxixi&apos;&#125;, &#125;, ] &#125;, /* 动态路由 在dynamicCom组建内可通过 this.$route.params.id 拿到浏览器地址栏 /dynamicRouter/12 的参数12 */ &#123; path: &apos;/dynamicRouter/:id&apos;, name: &apos;dynamicRouter&apos;, component: dynamicCom &#125;, &#123; path: &apos;*&apos;, // 除此之外所有路由均不匹配时会匹配此项 name: &apos;notFound&apos;, component: notFoundPage, &#125;, ]&#125;)// 全局路由钩子router.beforeEach((to, form, next) =&gt; &#123; // 进入默认主页 if（to.fullPath === &apos;/&apos;) &#123; next(&#123;name: &apos;home&apos;&#125;) &#125; else if (to.matched.some(item =&gt; item.needAuth)) &#123; next(&#123;name: &apos;needAuth&apos;&#125;) &#125; else &#123; next() // 通过路由 &#125; next(&#123;path: &apos;route1&apos;&#125;) next(new Error()) // 传递错误&#125;)router.onError(err =&gt; &#123; // 处理错误&#125;)export default router 动态路由 123456789101112131415161718192021222324&lt;script&gt; export default &#123; watch: &#123; &apos;$route&apos; (to, from) &#123; // 监听地址栏动态参数变化 console.log(to, from) &#125;, &#125;, // route hook in-component beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; &#125;) &#125;, beforeRouteUpdate (to, from, next) &#123; if (to.params.id == &apos;123&apos;) &#123; next() // call next() to change route &#125; &#125;, afterRouteLeave (to, from, next) &#123; next() &#125; &#125;&lt;/script&gt; vuex vue 状态管理 doc链接 state 全局单一状态树存储对象，遵循响应式原则 1234567891011const state = &#123; num: 5, user: &#123; name: 'xiaoxixi', age: 21, &#125;, list: [ &#123;id: '1', price: 5, name: 'banana', saled: false&#125;, &#123;id: '2', price: 10, name: 'watermelon', saled: true&#125;, ]&#125; 访问state 1this.$store.state.user 1&lt;span&gt;&#123;&#123;$store.state.user&#125;&#125;&lt;/span&gt; 快速访问state (mapState) 123456789import &#123; mapState &#125; from 'vuex'const vm = &#123; computed: &#123; ...mapState(&#123; count: state =&gt; state.count, countAlias: 'count', &#125;) &#125;&#125; getters 从state派生出一些属性，比如过滤，统计 12345678910111213const getters = &#123; listNum(state, getters) &#123; // 参数1为state对象,参数2为其他getters对象 return state.list.length &#125;, saledLength(state) &#123; return state.list.filter(item =&gt; item.saled) &#125;, findByPrice(state) &#123; // 返回函数，之后通过函数调用 return price =&gt; &#123; return state.list.find(item =&gt; item.price === price) &#125; &#125;&#125; 访问getters 12this.$store.getters.listNum // 属性访问this.$store.getters.findByPrice(5) // 方法访问 快速访问getters (mapGetters) 123computed: &#123; ...mapGetters(['listNum', 'saledLength', 'findByPrice'])&#125; mutations 更改state的唯一方式 每个mutations都有一个字符串的事件类型和一个callback(state, payload) 参数一为state, 参数2为提交的载荷 1234567const mutations = &#123; reduce (state, n) &#123; this.num -= n &#125;&#125;// in component usethis.$store.commit('reduce', 5) mutations 修改state的对象属性 必须遵守响应式规则, 必须是同步函数 1234addProps (state, prop) &#123; state.props = &#123; ...state.props, prop&#125; Vue.set(state.props, 'props', prop)&#125; 快速访问mutations(mapMutations) 123methods: &#123; ...mapMutations(['reduce'])&#125; actions 通过actions提交mutations，可以包含异步操作 123456789101112const store = &#123; actions: &#123; incrementAsync (context) &#123; window.setTimeout(() =&gt; &#123; context.commit('addProps') context.commit('lalal') &#125;, 1000) &#125; &#125;&#125;this.$store.dispatch('incrementAsync') 快速访问actions (mapActions) 12345export default &#123; methods: &#123; ...mapActions(['incrementAsync']) &#125;&#125; 异步操作 123456789101112131415actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125;// usethis.$store.dispatch('actionA').then(() =&gt; &#123; ...&#125;) plugins 123456789const myPlugin = store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; // 每次mutations之后调用 &#125;)&#125;const store = new Vuex.Store(&#123; plugins: [myPlugin]&#125;) vuex module 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647```jsimport Vue form &apos;vue&apos;import Vuex form &apos;vuex&apos;// 辅助函数import &#123;mapState, mapGetters&#125;import module1 from &apos;./modules/module1&apos;import module2 from &apos;./modules/module2&apos;const debug = process.env.NODE_ENV !== &apos;production&apos;Vue.use(Vuex)const state = &#123; todos: [ &#123;name: &apos;football&apos;, done: false&#125;, &#123;name: &apos;basketball&apos;, done: true&#125;, ]&#125;const getters = &#123; getDoneTodos(state) &#123; return state.todos.filter(item =&gt; item.done) &#125;, doneNums(state) &#123; return state.todos.filter(item =&gt; item.done).length &#125;, // 返回一个函数 getByPrice(state) &#123; return price =&gt; state.todos.filter(item =&gt; itme.price &gt; price).length &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;export default new Vuex.Store(&#123; state, getters, mutaions, actions, modules: &#123; module1, module2 &#125;, strict: debug, //设置运行模式 plugin: debug ? [createLogger()] : [], // 开发模式加入日志插件&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960```js// 服务层逻辑，封装ajax调用返回promise对象import service from &apos;../api/service/curl&apos;const state = &#123; productions: [ &#123; name: &apos;shootGun&apos;, price:3 &#125;, &#123; name: &apos;dog&apos;, price:10 &#125;, &#123; name: &apos;ball&apos;, price: 6&#125;, ], selectedProductions: [], user: &#125;// 定义state属性映射const getters = &#123; // 参数1：state对象， 参数2：自身getters，参数3：根state getAll: state =&gt; state.productions.filter(item =&gt; item.price &gt; 5), calculateAll(state, getters, rootState) &#123; return state.selectedProductions.reduce((total, item) =&gt; total + item.price * item.num, 0) &#125;&#125;// 定义commit修改, mutations必须是同步函数, const mutations = &#123; // 参数1：当前state对象, 参数2：commit后提交的载荷 addDiscountProduction(state, &#123; name, num, price&#125;) &#123; state.selectedProduction.push(&#123; name, num, price * 0.9 &#125;) &#125;, buyAll(state, &#123;buyAll&#125;) &#123; state.selectedProduction = [] state.isClear = buyAll &#125;, changeUser(state, payload) &#123; state.user = &#125;&#125;// 定义异步操作，内部触发mutationsconst actions = &#123; // 参数1：当前store对象 有state,commit,rootState等属性。 参数2：载荷对象 buyProductions(context, productions) &#123; service.buy(productions).then(res =&gt; &#123; context.commit(&apos;buyAll&apos;, res.body.success) &#125;) &#125;&#125;export default &#123; namespaced: true, // 是否启用命名空间，默认false,如果启用则数据不挂在到全局跟store上 state, getters, actions, mutations&#125; component use 12345678910111213141516171819202122import &#123; mapGetters, mapState, mapMutations, mapActions &#125; from 'vuex'new Vue(&#123; computed: &#123; ...mapGetters(&#123; getAllProducts: 'getAll' // 把getter的getAll作为名为getAllProducts的计算属性 &#125;), // 把state的productions作为同名计算属性 ...mapState(['productions', 'selectedProductions']), moduleState() &#123; return this.$store.state.moduleState.a &#125; &#125;, methods: &#123; ...mapMutations(['addDevice']), // 把store的addDevice作为同名方法 ...mapActions([]), // buyAll() &#123; this.$store.dispatch('buyProductions') &#125; &#125;&#125;)","categories":[],"tags":[]},{"title":"CSS","slug":"css","date":"2018-09-08T06:57:48.422Z","updated":"2018-10-08T10:27:39.569Z","comments":true,"path":"2018/09/08/css/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/css/","excerpt":"","text":"cssLearn css and make pages pretty Table of contents[TOC] Design principle 移动优先原则，及默认的css样式为移动样式，然后通过媒体查询 用 桌面样式覆盖 整体字体在 14px 到 20px 之间 保持适当行距（1.5倍） 段落采用缩进或隔行，不能两者同时用，首段不用隔行或缩进 Font-face 定义字体 123456789101112131415161718192021222324@font-face &#123; font-family: 'myfont'; /* 自定义名 */ src: url('myfont.woff') format('woff') /* 路径，格式 */&#125;@font-face &#123; font-family: 'Roboto'; src: url('Roboto-Light-webfont.woff') format('woff'); font-style: normal; font-weight: 300;&#125;@font-face &#123; font-family: 'Roboto'; src: url('Roboto-LightItalic-webfont.woff') format('woff'); font-style: italic; font-weight: 300;&#125;@font-face &#123; font-family: 'Roboto'; src: url('Roboto-Bold-webfont.woff') format('woff'); font-style: normal; font-weight: 700;&#125; 使用字体 123.line &#123; font-family: 'Robot';&#125; Responsive img 根据不同dpi显示不同图片srcset 123&lt;img src=\"images/standard.png\" srcset=\"images/standard.png 1x, images/standard-big.png 2x\" style=\"width: 100%\"/&gt; 根据不同像素宽度设置不同图片 123&lt;img src=\"images/photo-small.jpg\" srcset=\"images/photo-big.jpg 2000w, images/photo-small.jpg 1000w\" sizes=\"(min-width: 960px) 960px, 100vw\"/&gt; 媒体查询 1234567&lt;picture&gt; &lt;source media='(min-width: 401px)' srcset='images/photo-big.jpg'/&gt; &lt;source media='(max-width: 400px)' srcset='images/photo-tall.jpg'/&gt; &lt;img src='images/photo-small.jpg'/&gt;&lt;/picture&gt; Css Selector 后兄弟节点选择器(选取h1后紧邻的p元素) 123h1 + p &#123; color: green;&#125; 毗邻~(选取h1后相邻的所有p元素) 123h1 ~ p &#123; color: red;&#125; 属性选择器 1234/*选择类名已foundicon 开头的元素*/[class*=\"foundicon-\"] &#123; &#125; 起始/结束类型选择器 12345678/* 选择.container 的第一个p元素 */.container p:first-of-type &#123; &#125;/* 选择.container 的最后一个p元素 */.container p:last-of-type &#123; &#125; BFC (block formating context)123456789/* 创建bfc float: 值不为none; position: 值不为static或relative; overflow: 值不为visible; display: 值为 table-cell, table-caption, inline-block, flex, inline-flex*//* 最常用方法 */overflow: hidden; BFC的应用 解决margin重叠（为每个带有margin的块包裹一个新的bfc） 解决浮动元素无法撑开父元素的高度（给包父元素设置为bfc） 解决文字环绕浮动元素（给包含文字的元素设置bfc） Media Queries12345@media only screen and (min-width: 401px) and (max-width: 960px) &#123; #main &#123; ... &#125;&#125; FLOAT layout clear: left; 排除 当前元素之前 float: left;元素对此元素的影响， 但之前元素的float: left仍对自身有效； 如果一个父元素中有浮动元素，若让子元素撑开父元素的高度，方法一：在父元素末尾添加clear: both;的元素。方法二：在父元素增加 overflow: hidden;属性。 FLEX layout demo1 demo2 容器属性 设置容器为flex布局 容器设置为flex后，子元素自动成为容器成员， 子元素的float, clear, vertical-align 都将失效 12345.box &#123; display: flex; display: inline-flex; display: -webkit-flex; /* Safari */&#125; 子元素排列方向 当flex-direction 从 row 变为 column 时，justify-content 的意义变为 align-items 1flex-direction: row | row-reverse | column | column-reverse; 子元素换行规则 nowrap ： 不换行，所有item排列成一排，width ： 100% 被忽略 1flex-wrap: nowrap | wrap | wrap-reverse; 水平对齐规则 justify-content: flex-start | flex-end | center | space-between | space-around; 1justify-content: flex-start | flex-end | center | space-between | space-around; 垂直对齐规则 stretch: flex-item 被纵向拉伸至flex-contanier 一样的高度 1align-items: flex-start | flex-end | center | baseline | stretch; 多轴对其规则 1align-content: flex-start | flex-end | center | space-between | space-around | stretch; 子属性 单位宽度 flex 123flex: initial; /* 原始宽度 */flex: 1; /* 单位宽度（若其他item没设置，则被拉伸填满）*/flex: 2; /* 单位宽度的两倍 */ 排列顺序 order 1order: &lt;integer&gt;; 放大的倍数 如果存在剩余空间， 放大的倍数 1flex-grow: &lt;number&gt;; /* default 0 */ 缩小 1flex-shrink: &lt;number&gt;; /* default 1 */ 自身对齐 align-self 1align-self: auto | flex-start | flex-end | center | baseline | stretch; others 把元素撑到右侧 1margin-left: auto; /* 会把item撑到右侧 */ 主轴空间 此属性定义了在分配多余空间之前，项目占据的主轴空间（main size） 1flex-basis: &lt;length&gt; | auto; /* default auto */ Transition1234/* transition */.trans &#123; transition: all 1s ease-out;&#125; Css-3D demo-cube 123456789101112131415/* 父元素设置之后，其后代元素便会有3d效果 */.container &#123; trnasform-style: preserve-3d; &#125;.container &#123; perspective: 300px; // 景深 perspective-origin: 0px 0px; // 视角起始点&#125;.trans &#123; transform: translate3d(10px, 10px, 10px) | translateX(30px) | translateY(30px) | translateZ(30px); transform: rotateX(90deg) | rotateY(90deg) | rotateZ(90deg); transform: scale3d(1, 1, 1) | scaleX(1.2) | scaleY(1.2) | scaleZ(1.2);&#125; Css-filter 灰度 123.grayscale &#123; filter: grayscale(1) /* 0~1 代表灰度 */&#125; 褐色 123.sepia &#123; filter: sepia(.5)&#125; 饱和度 123.saturate &#123; filter: saturate(5)&#125; 色相旋转 123.hue-rotate &#123; filter: hue-rotate(90deg)&#125; 反色 123.invert &#123; filter: invert(1)&#125; 透明度 123.opacity &#123; filter: opacity(.5)&#125; 亮度 123.brightness &#123; filter: brightness(2)&#125; 对比度 123.contrast &#123; filter: contrast(.4)&#125; 模糊 123.blur &#123; filter: blur(10px)&#125; 阴影 123.drop-shadow &#123; filter: drop-shadow(5px 5px 10px #ccc)&#125; Less &amp; 指代自身 12345p &#123; &amp;:hover &#123; ... &#125;&#125; 定义/使用变量 12345@apple: #fff;span &#123; color: @apple;&#125; Tips 单行超出显示省略号 12345.line &#123; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125; 多行文本超出显示省略号 1234567.points &#123; display:-webkit-box; -webkit-line-cap:3; -webkit-box-orient: vertical; overflow:hidden; text-overflow:ellipsis;&#125; 单行文字均匀对齐 1text-align-last: justify; 不定宽元素居中 1234.box &#123; display: table; margin: 0 auto;&#125; 只允许在空格处换行 123.line &#123; word-wrap:break-word;&#125; css 实现长宽比例一致div容器 原理：父容器设置一个bfc（overflow：hidden），让子元素能撑开父元素，站位dummy div设置margen-top为100%，把父元素的高度撑到和其宽一样，.content div用来放真正的内容 1234&lt;div class=”container”&gt; &lt;div class=”dummy”&gt;&lt;/div&gt; &lt;div class=”content”&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.container &#123; position:relative; overflow: hidden; border: 1px solid red; &#125;.dummy &#123; margin-top: 100%; /* 指代父容器宽度的 100% 撑开父元素 */&#125;.content &#123; position: absolute; top:0; left:0; right:0; bottom:0;&#125; 计算属性 123.box &#123; width: calc(~\"100% - 40px\");&#125; 滚动条样式 123456789.scroll-bar &#123; 1. ::-weskit-scrollbar 滚动条整体部分 2. ::-webkit-scrollbar-button 滚动条两端的按钮 3. ::-webkit-scrollbar-track 外层轨道 4. ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去） 5. ::-webkit-scrollbar-thumb （滚动条里面可以拖动的那个） 6. ::-webkit-scrollbar-corner 边角 7. ::-webkit-resizer 定义右下角拖动块的样式&#125; 缩放元素 1transform: scale(0.6); :before , :after 伪类 1234.redStar:before &#123; content: '*'; color: red;&#125; 倍数行距 1line-height: 1.3; 背景图片大小自适应元素宽度高度 123img &#123; background-size: 100% 100%;&#125; 控制文字内容用户可选择 123.line &#123; user-select: none | text | all | element;&#125;","categories":[],"tags":[]},{"title":"web前端开发调试技巧大全","slug":"debug","date":"2018-09-08T06:57:48.422Z","updated":"2018-10-01T14:56:14.142Z","comments":true,"path":"2018/09/08/debug/","link":"","permalink":"http://zexiplus.github.io/2018/09/08/debug/","excerpt":"","text":"Debug 总结了常用web前端调试方法和nodejs调试方法 Table of contents[TOC] webfont debugconsole console.log 12// 占位符 %o(对象), %d(数字),%s(字符串), %f(浮点数)console.log(‘需要打印的是%o’,obj) console.group 打印组 1234console.group() console.log(1) console.log(2)console.groupEnd() console.trace() 打印调用栈 123456789101112function caller() &#123; exec()&#125;function exec() &#123; console.trace()&#125;caller()// exec @ VM123:5// caller @ VM123:2// (anonymous) @ VM123:8 console.time 打印执行时间 123console.time(timerName) fn（） console.timeEnd(timerName) console.dirxml 打印dom结构 1console.dirxml(document.querySelector('body')) console.dir 打印对象 1console.dir(obj) debugger在js代码内打上debugger 关键字 当代码运行至 debugger 处，浏览器打开控制台scope窗会显示当前scope的变量 Nodejs debug nodejs 程序调试工具， 方法， 技巧 node cli debug node 命令行窗口调试器 12345node inspect test.js# 进入debug模式， 会停在第一行可执行脚本处# 新版node debug 命令被弃用了， 用 inspect 代替node debug test.js 进入node debuger后输入下面命令(括号内为简写） cont(c) 执行剩余的所有代码 setBreakpoint(filename, line) 设置断点命令， 执行cont 会到此行暂定执行 ， 简称sb(filename, line), filename可省略，省略默认当前文件 clearBreakpoint(filename, line) 取消断点 简写cb() next(n) 逐步执行 list(n) 列出当前点后n行的代码 scripts 列出当前文件所有引用的模块（不包括内置模块） step(s) 进入函数内部 backtrace 查看当前函数在被调用函数的返回位置 out(o) 从函数中跳出至原执行流 watch(‘variable’) 监听变量， 变量每次修改都会显示出来, 变量值要加引号 watchers 查看所有被监听的变量值 unwatch(‘variable’) 取消监听变量 restart 从程序开始从新执行debug repl 进入repl环境 node debug with chrome 调试服务程序 启动 1node --inspect app.js 打开浏览器 输入 chrome://inspect， 点击target Source 面板 Add folder to Workspace 选择开发项目的目录 在文件中添加响应断点 查看变量 调试非服务程序 启动 在第一行就增加断点, 这样可以避免非服务脚本,运行太快而退出 1node --inspect-brk=9229 app.js 之后类似 调试运行时脚本 启动程序 1node app.js 按端口查看进程pid 1lsof -i :3000 启动调试程序 1node -e 'process._debugProcess()'","categories":[],"tags":[]},{"title":"Nodejs 总结","slug":"nodejs","date":"2018-09-02T12:51:47.045Z","updated":"2018-10-01T15:05:25.681Z","comments":true,"path":"2018/09/02/nodejs/","link":"","permalink":"http://zexiplus.github.io/2018/09/02/nodejs/","excerpt":"","text":"Nodejsnodejs 参考指南 Table of contents[TOC] Module require过的文件会加载到缓存，所以多次 require 同一个文件（模块）不会重复加载 ( a-&gt;b,b-&gt;a )循环引用并不会报错，导致的结果是 require 的结果是空对象 {}，原因是 b require 了 a，a 又去 require 了 b，此时 b 还没初始化好，所以只能拿到初始值 {} module.exports 初始值为一个空对象 {} exports 是指向的 module.exports 的引用 require() 返回的是 module.exports 而不是 exports require.cache 保存了当前模块引用的所有模块 Node REPL .break 退出noderepl .help 查看所有node repl命令 Develop Cli 常用node开发调试 cli命令 1234567891011121314# 查看npm 配置 (全局node_modules路径位置之类)npm config list # 设置npm配置npm install 全局安装路径npm config set prefix /usr/local/node_modules# 检查node代码node inspect myscript.js# 根据进程端口查看进程信息lsof -i :3000# 根据pid 杀死进程kill -9 pid Built-in moduleos 获取系统信息 http://nodejs.cn/api/os.html#os_os_platform os.platform() 显示系统平台， 等价于 process.platform darwin - mac系统， win32 - window系统， linux- linux系统 os.arch() 系统架构 例如 ‘x64’ os.cpus() 返回系统的cpus数组 os.userInfo() 返回用户信息 123456&#123; uid: -1, gid: -1, username: 'Administrator', homedir: 'C:\\\\Users\\\\Administrator', shell: null &#125; os.hostname() 返回计算机主机名 例如 ipanel-pc os.homedir() 返回当前用户home目录路径 例如 ‘C:\\Users\\Administrator’ os.freemem() 返回空闲系统内存字节数 例如 4228706304 os.totalmem() 返回系统的总内存数 os.networkInterfaces() 返回网络信息对象 ，如下 1234567&#123; '本地连接 3': [ &#123; address: 'fe80::94e1:8930:9f9c:b6c1', netmask: 'ffff:ffff:ffff:ffff::', family: 'IPv6', mac: '6c:4b:90:0d:74:d3', ...&#125; cluster 集群 http://nodejs.cn/api/cluster.html cluster.isMaster 一个node程序只有一个主进程, 此方法返回当前程序是否在主进程 cluster.fork() 只在主进程中可用, 复制出一个工作进程, 工作进程可以共享任意tcp连接 cluster.workers 返回所有进程的对象, 以进程id为键, 的哈希表 cluster.woker 当前工作对象的引用 cluster.on(‘message’, function (worker, message, handle) {}) 当主进程收到工作进程的任意消息时触发 process.on(‘message’, function () {}) 当工作进程收到主进程的消息时触发 worker.send(message, [handle]) 发送一个消息给工作进程或主进程，也可以附带发送一个handle process.send({msg: ‘hello’}) 从工作进程中发送消息给主进程 cluster.js demo 12345678910111213141516171819202122232425262728293031const cluster = require('cluster')const http = require('http')let cpuNum = require('os').cpus().lengthlet workers = []if (cluster.isMaster) &#123; for(let i = 0; i &lt; cpuNum; i ++) &#123; workers.push(cluster.fork()) // 向工作进程发送消息 workers[i].send('hello child cluster') &#125; cluster.on('exit', worker =&gt; &#123; console.log(`$&#123;worker.process.pid&#125; 工作进程已退出`) &#125;) // 监听工作进程的消息事件 cluster.on('message', function (worker, msg) &#123; console.log(`from worker message is$&#123;msg&#125;`) &#125;)&#125; else &#123; // 监听来自主进程的消息事件 process.on('message', msg =&gt; &#123; console.log(`receive $&#123;msg&#125;`) &#125;) http.createServer((req, res) =&gt; &#123; res.end('hello world') // 向主进程发送消息 process.send('the same to next') cluster.worker.send('i am a server') &#125;).listen(3000) // 共享http端口&#125; stream 流， 分为可读，可写， 可读写 都是EventEmitter的实例 http://nodejs.cn/api/stream.html 事件 data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 stream.Writable(obj) 创建可写流 , obj 必须要有_write方法 1234567const &#123; Writable &#125; = require('stream')const writable = new Writable(&#123; _write(chunk, encoding, callback) &#123; // do something callback() &#125; &#125;) buffer node二进制数据 buf.toString(encoding) 1buf.toString('utf8') process process 对象是全局对象， 不需要手动require引入 http://nodejs.cn/api/process.html process.env 系统环境变量 1234567891011# 运行程序时设置环境变量 # windows set NODE_ENV=test node test.js # uinxNODE_ENV=test node test.js# 跨平台npm i cross-env -g cross-env NODE_ENV=test node test.js# node 程序中设置process.env.NODE_ENV = 'test' process.exit(code) 指定当前进程立即退出 12345// 以 success 方式退出node进程process.exit(0)// 以 fail 方式退出node进程process.exit(1) process.argv 运行node程序的参数数组 12node one.js hello world # process.argv =&gt; ['/usr/bin/node', '/home/code/one.js', 'hello', 'world'] process.cwd() process.cwd() 代表 node 进程当前工作的目录, __dirname只返回当前文件的路径 12345678// /usr/lib/other.jsconsole.log(`process.cwd is $&#123;process.cwd()&#125;`) // /usr/libconsole.log(`__dirname is $&#123;__dirname&#125;`) // /usr/lib// /usr/main.jsrequire('./lib/other')// /usr// /usr/lib process.nextTick(cb) 一旦当前事件轮询队列的任务全部完成 , 所有cb就会依次调用 process.stdout 输出流， 是一个可写流， console.log 也属于process.stdout process.stdout.write() 12// 把用户输入输出到终端process.stdin.pipe(process.stdout) process.stdin 输入流， 可读流 12345678process.stdin.setEncoding('utf8')process.stdin.on('readable', () =&gt; &#123; let chunk = process.stdin.read() process.stdout.write(`receive data is $&#123;chunk&#125;`)&#125;)process.stdin.on('end', () =&gt; &#123; process.stdout.write('end')&#125;) process.on(‘exit’, cb) 进程退出事件 123process.on('exit', code =&gt; &#123; console.log(`退出码$&#123;code&#125;`)&#125;) process.kill(pid[,signal]) 结束进程 1process.kill(123) child_process12345678910111213141516const cp = require('child_process')// spawn 第一个参数命令，第二个参数 命令的参数let ls = cp.spawn('ls', ['-lh', '/usr'])ls.stdout.on('data', (data) =&gt; &#123; console.log(data)&#125;)ls.stdin.on('data', data =&gt; &#123; console.log(data)&#125;)ls.stderr.on('data', err =&gt; &#123; console.err(err)&#125;)ls.on('close', code =&gt; &#123; console.log(`退出码$&#123;code&#125;`)&#125;) path12345678910111213141516171819202122232425262728293031323334//内置路径处理模块var path = require('path') //return 'currPath/www'path.join(__dirname,'www/') //把路径解析为绝对路径的函数 返回 path.resolve('/usr','./local','bin') // Returns: '/foo/bar/baz/asdf'path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// Returns:// &#123; root: 'C:\\\\',// dir: 'C:\\\\path\\\\dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125;path.parse('C:\\\\path\\\\dir\\\\file.txt');┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │\" / home/user/dir / file .txt \"└──────┴──────────────┴──────┴─────┘// The path.resolve() method resolves a sequence of paths or path // segments into an absolute path.// Returns: '/foo/bar/baz'path.resolve('/foo/bar', './baz');// Returns: '/tmp/file'path.resolve('/foo/bar', '/tmp/file/');// if the current working directory is /home/myself/node,// this returns '/home/myself/node/wwwroot/static_files/gif/image.gif'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif'); file-system File system flags | Flag | detail || —- | —————————————————— || a | 打开文件进行追加。如果文件不存在，则创建该文件 || a+ | 打开文件读取并追加。如果文件不存在，则创建该文件 || r | 打开文件并读取。如果文件不存在，则发生异常 || r+ | 打开文件读取并写入。如果不存在，则发生异常 || w | 打开文件并写入。如果文件不存在则创建，存在则覆盖 || w+ | 打开文件并读取和写入。如果文件不存在则创建，存在则覆盖 | fs.readDir 打开文件夹 123456// 把一个文件夹下的文件拷贝到另一文件夹fs.readDir(path, (err, files) =&gt; &#123; files.forEach(item =&gt; &#123; fs.writeFileSync(__dirname + '/copy', fs.readFileSync(__dirname + '/origin')) &#125;)&#125;) fs.mkdir 新建目录 12// 若没有重名目录 则新建目录fs.existsSync(logFold) || fs.mkdirSync(logFold) fs.open Open file 12345const fs = require('fs')fs.open('test.txt', 'r+', (err, fd) =&gt; &#123; if (err) throw err console.log(fd)&#125;) fs.writeFile Write file 1234567891011121314// fs.writeFile(path, data, options, cb)fs.writeFile('text.txt', 'hello world', &#123;encoding: 'utf8', flag: 'w'&#125;, err =&gt; &#123; if (err) console.error(err)&#125;)// fs.write(fd, string, [position], [encoding], cb)fs.open('test.txt', 'a+', (err, fd) =&gt; &#123; fs.write(fd, 'hello world', err =&gt; &#123; if (err) return console.error(err) &#125;) fs.close(fd, err =&gt; &#123; if (err) console.error(err) &#125;)&#125;) fs.readFile Read file 1234567891011121314151617// fs.readFile(path, options, cb)fs.readFile('test.txt', &#123;encoding: null, flag: 'r'&#125;, (err, data) =&gt; &#123; if (err) console.error(err) console.log(data)&#125;)// fs.read(fd, buffer, offset, length, position, cb)fs.open('test.txt', 'r', (err, fd) =&gt; &#123; if (err) return console.error(err) let buffer = new Buffer(1024) fs.read(fd, buffer, 0, buffer.length, 0, (err, bytes) =&gt; &#123; if (err) return console.error(err) if (bytes &gt; 0) &#123; console.log(buffer.slice(0, bytes).toString()) &#125; &#125;)&#125;) fs.close close file 12345678// fs.close(fd, cb)fs.open('test.txt', 'r+', (err, fd) =&gt; &#123; if (err) throw err fs.close(fd, err =&gt; &#123; if (err) throw err console.log('close file successfully') &#125;)&#125;) fs.watch 监听文件/目录变化 12345678910// 监听filePath文件变化， 一旦改变，则运行回调函数const options = &#123; recursive: true, // 如果是目录, 是否递归监听子目录, 默认false encoding: 'utf8' // 监听文件名的字符编码&#125;fs.watch('filePath', options, (eventType, filename) =&gt; &#123; console.log(`current file state is $&#123;curr.sate&#125;`) cp.exec('mv index.js index-dep.js')&#125;) fs.createWriteStream 创建可写流 1234let writableStream = fs.createWriteStream(path.join(__dirname, '../readme.md'))let chunk = 'good good study day day up'// 向可写流中写入数据writableStream.write(chunk) http server.js 12345678910var http = require('http')//最基本服务器http.createServer((req,res) =&gt; &#123; if(req.url == '/hello') &#123; res.end('hello') &#125; if(req.url == '/world') &#123; res.end('world') &#125;&#125;).listen(6666) http method&amp;properties http.get(options, callback) 123456789101112131415161718http.get('http://nodejs.org/dist/index.json', (res) =&gt; &#123;const &#123; statusCode &#125; = res;const contentType = res.headers['content-type']; res.setEncoding('utf8');let rawData = '';res.on('data', (chunk) =&gt; &#123; rawData += chunk; &#125;);res.on('end', () =&gt; &#123; try &#123; const parsedData = JSON.parse(rawData); console.log(parsedData); &#125; catch (e) &#123; console.error(e.message); &#125;&#125;); &#125;).on('error', (e) =&gt; &#123;console.error(`错误: $&#123;e.message&#125;`); &#125;); http.request(options,[callback]) 1234567891011121314151617181920212223242526272829303132const postData = querystring.stringify(&#123; 'msg' : 'Hello World!' &#125;); const options = &#123; hostname: 'www.google.com', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(postData) &#125; &#125;; const req = http.request(options, (res) =&gt; &#123; res.setEncoding('utf8'); res.on('data', (chunk) =&gt; &#123; console.log(`响应主体: $&#123;chunk&#125;`); &#125;); res.on('end', () =&gt; &#123; console.log('响应中已无数据。'); &#125;); &#125;); req.on('error', (e) =&gt; &#123; console.error(`请求遇到问题: $&#123;e.message&#125;`); &#125;); // 写入数据到请求主体 req.write(postData); req.end(); response methods&amp;properties res.setEncoding(‘utf-8’) 设置编码格式 res.setHeader(‘Content-type’, ‘text/html’) 设置响应头 res.headers[‘content-type’] 获取content-type响应头 res.resume() 消耗res, 释放内存空间 res.writeHead(statusCode, [headers]) 设置响应头和响应码，会和setHeader合并，setHeader优先级高 1234res.writeHead(200, &#123; 'Content-Type': 'text/plain', 'Content-Length': Buffer.length(body)&#125;) request methods&amp;properties req.headers 12345678910&#123; 'host': 'localhost:3001', 'connection': 'keep-alive', 'cache-control': 'max-age=0', 'upgrade-insecure-requests': '1', 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) ...', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,zh-HK;q=0.7', 'cookie': 'name=float' // cookie会随请求头一起发送至服务器&#125; dns1234567891011121314151617181920212223242526const dns = require('dns')// dns.lookup 提供域名，解析出ip地址dns.lookup('hostname', (err, ipAddress, ipVersion) =&gt; &#123; &#125;)// dns.resolve4 与 dns.lookup作用相同，实现不同// dns.reverse 提供ip地址 反向解析出域名dns.resolve4('hostname', (err, ipAddress) =&gt; &#123; dns.reverse(ipAddress, (err, hostname) =&gt; &#123; console.log(hostname) &#125;)&#125;)// dns.Resolver 使用特定的值解析const server = new dns.Resolver([192.168.17.108])server.resolve4('hello.com', (err, ipAddress) =&gt; &#123; console.log(ipAddress) // 192.168.17.108&#125;)// 取消解析server.cancel() // 设置和返回当前dns解析的ip数组server.setServers(['123.23.22.22'])server.getServers() Async operator control1234567891011121314151617181920212223242526272829303132333435363738394041var fs = require('fs')var Promise = require('bluebird') //第三方promise模块，兼容global.Promise = Promise //全局promisefunction readFile(filename) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filename,(err, file) =&gt; &#123; if(err) &#123; reject(err) &#125; else resolve(file) &#125;) &#125;)&#125;readFile('./one.js').then(data =&gt; &#123; console.log(data)&#125;)//自己写的把普通函数转换为promise函数的函数Function.prototype.convertPromise = function() &#123; var fn = this return function() &#123; var args = [].slice.call(arguments, 0) return new Promise((resolve, reject) =&gt; &#123; args.push(function (err, file) &#123; if(err) &#123; reject(err) &#125; else &#123; resolve(file) &#125; &#125;) fn.apply(null, args) &#125;) &#125;&#125;var readFile2 = fs.readFile.convertPromise()readFile2('./one.js').then(data =&gt; &#123; console.log(data)&#125;) Package.json dependency 主版本号.次版本号.修正号 主版本号：当你做了不兼容的API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正 | 表达式 | 版本范围 | 说明 || ————————————- | ——————– | ———————————————————— || 1.2.1 | 1.2.1 | 匹配指定版本，这里是匹配1.2.1。 || ^1.0.0 | &gt;=1.0.0 且 &lt;2.0.0 | ^表示与指定的版本兼容，左边第一个非0字段不可变，后面的可变 || ^5.x | &gt;=5.0.0 且 &lt;6.0.0 | 同上 || ~0.1.1 | &gt;=0.1.1 且 &lt;0.2.0 | ~表示约等于版本，如果存在次版本号，则允许修订号为最高的，否则允许次版本为最高，如 ~1匹配&gt;=1.0.0 且 &lt;2.0.0 || * | 匹配 &gt;=0.0.0 | 通配符 || &gt;=3.0.0 | &gt;=3.0.0 | 其他符号还有&lt;,&lt;=,&gt;,&gt;=,=.字面意思。可使用空格表示AND，双竖线表示OR. || 1.30.2 - 2.30.2 | &gt;=1.30.2 且 &lt;=2.30.2 | || git://github.com/user/some.git#commit | Git URL形式的依赖 | 还支持URL、GitHub URL、本地 URL || latest | 当前发布的版本 | | 123456&#123; \"dependencies\": &#123; \"compression\": \"^1.2.3\", \"axios\": \"~1.2.3\" &#125;&#125;","categories":[],"tags":[]},{"title":"常用软件配置","slug":"Software-config","date":"2018-08-30T06:06:18.704Z","updated":"2018-09-29T16:37:30.647Z","comments":true,"path":"2018/08/30/Software-config/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Software-config/","excerpt":"","text":"software config记录并保存了常用软件的配置规则 wamp server(Apache) 配置有效的缓存策略 配置文件 httpd.conf 123456789101112131415161718# 第一种方法LoadModule expires_module modules/mod_expires.soExpiresActive On# html文档的过期时间为 从上次访问（A）开始 1000 秒钟ExpiresByType text/html A1000ExpiresByType image/gif A2592000# HTML文档的有效期是最后修改（M）时刻后的一星期ExpiresByType text/html M604800ExpiresByType text/css N1000ExpiresByType text/js \"now plus 2 days\"ExpiresByType image/jpeg \"access plus 2 months\"ExpiresByType image/bmp \"access plus 2 months\"ExpiresByType image/x-icon \"access plus 2 months\"ExpiresByType image/png \"access plus 2 months\"# 第二种方法LoadModule headers_module modules/mod_headers.soheader set cache-control \"max-age=1000\"","categories":[],"tags":[]},{"title":"网络状态协议解析","slug":"Network-protocol","date":"2018-08-30T06:06:18.703Z","updated":"2018-10-01T15:01:43.768Z","comments":true,"path":"2018/08/30/Network-protocol/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Network-protocol/","excerpt":"","text":"网络协议原理收录了一些网络协议, 网络状态的总结 目录[TOC] 浏览器输入url后发生了什么？1.DNS域名解析；2.建立TCP连接；3.发送HTTP请求；4.服务器处理请求；5.返回响应结果； 6.关闭TCP连接； 7.浏览器解析HTML；8.浏览器布局渲染； 步骤详解 建立tcp连接 ​ 客户端：“你好，在家不，有你快递。” ​ 服务端：“在的，送来就行。” ​ 客户端：“好嘞。” 发送http请求 关闭tcp连接 客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。” 服务端：“收到，我看看我这边有木有数据了。” 服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。” 客户端：“好嘞。” 浏览器解析html 浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。 浏览器通过解析HTML，生成DOM树(dom tree)，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。 要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题。 浏览器布局渲染 根据渲染树(render tree)布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。 replaint(重绘)：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不 变。​ reflow(重构)： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。 最后浏览器绘制各个节点，将页面展示给用户。 http头信息 请求头对象例子 12345678910&#123; host: \"localhost:3001\", referer: \"localhost:3001/request\", connection: \"keep-alive\", upgrade-insecure-requests: \"1\", user-agent: \"AppleWebKit/537.36 Chrome/67.0.3396.87 Safari/537.36\", accept: \"text/html,application/xhtml+xml,image/webp,image/apng,*/*;q=0.8\", accept-encoding: \"gzip, deflate, br\", accept-language: \"zh-CN,zh;q=0.9,en;q=0.8,zh-HK;q=0.7\",&#125; 请求头信息 | 字段 | 含义 || ————— | ———————————————————— || Accept | 浏览器能够处理的内容类型 || Accept-Charset | 浏览器能够显示的字符集 || Accept-Encoding | 浏览器能够处理的压缩编码 || Accept-Language | 浏览器当前设置的语言 || Host | 发出请求的页面所在域 || Referer | 发送请求页面的url || Cookie | 当前页面设置的任何cookie || Connection | 浏览器与服务器之间的连接类型,Connection : Keep-Alive 功能避免了建立或者重新建立连接, 超过5秒建立新的连接， 最大请求100次, connection: ‘keep-alive, timeout = 5,max = 100’ || User-Agent | 浏览器类型字符串 | 响应头信息 expires 和 cache-control : max-age = 1000 与缓存有关， expires 是一个过期日期， max-age是时长， 二者可以相互推算 | 响应头 | 解释 || ———————— | ———————————————————— || Allow | 服务器支持哪些请求方法（如GET、POST等） || Content-Encoding | 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。 || Content-Length | 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。 || Content-Type | 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。 || Date | 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 || Expires | 应该在什么时候认为文档已经过期，从而不再缓存它 || Last-Modified | 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 || Location | 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 || Refresh | 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。 || Server | 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 || Set-Cookie | 设置和页面关联的Cookie。 || WWW-Authenticate | 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 。 || Etag | 是资源的特定版本识别符, 可以让缓存更高效,如果没有改变, web服务器不需要发送完整的响应. 例如 ETag : “33a64df551425fcc55e4d42a148795d9f25f89d4” || Cache-Control : no-cache | 缓存设置时间 | http 状态 常用状态码 | status code | information || ———– | ———————————————- || 200 | 请求成功 || 201 | 已创建, 请求成功并且服务器创建了新资源 || 202 | 已接受, 服务器已接受请求, 但尚未处理 || 304 | 未修改 || 301 | 永久移动 || 302 | 临时移动 || 400 | 参数错误 || 401 | 请求未授权 || 403 | 拒绝访问 || 404 | 地址不存在 || 405 | 客户端请求中的方法被禁止（一般是请求方式错误） || 500 | 服务器报错 || 501 | 尚未实施, 服务器还不存在请求功能 || 502 | 请求超时，无效网关 || 503 | 服务器超载或者维护，无法响应 | 全部请求头 | status code | information || ———– | ——————————- || 100 | continue || 101 | switching protocols || 102 | processing || 200 | ok || 201 | created || 202 | accepted || 203 | non-authoritative information || 204 | no content || 205 | reset content || 206 | partial content || 207 | multi-status || 208 | already reported || 226 | im used || 300 | multiple choices || 302 | found || 303 | see other || 304 | not modified || 305 | use proxy || 307 | temporary redirect || 308 | permanent redirect || 400 | bad request || 401 | unauthorized || 402 | payment required || 403 | forbidden || 404 | not found || 405 | method not allowed || 406 | not acceptable || 407 | proxy authentication required || 408 | request timeout || 409 | conflict || 410 | gone || 411 | length required || 412 | precondition failed || 413 | payload too large || 414 | uri too long || 415 | unsupported media type || 416 | range not satisfiable || 417 | expectation failed || 418 | I’m a teapot || 422 | unprocessable entity || 423 | locked || 424 | failed dependency || 426 | upgrade required || 428 | precondition required || 429 | too many requests || 431 | request header fields too large || 500 | internal server error || 501 | not implemented || 502 | bad gateway || 503 | service unavailable || 504 | gateway timeout || 505 | http version not supported || 506 | variant also negotiates || 507 | insufficient storage || 508 | loop detected || 510 | not extended || 511 | network authentication required |","categories":[],"tags":[]},{"title":"Linux 使用参考","slug":"Linux","date":"2018-08-30T06:06:18.701Z","updated":"2018-10-01T15:00:39.972Z","comments":true,"path":"2018/08/30/Linux/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Linux/","excerpt":"","text":"linux 关于linux 系统 的基本概念和操作总结 目录[TOC] 文件结构 目录 描述 / 主层次 的根，也是整个文件系统层次结构的根目录 /bin 存放在单用户模式可用的必要命令二进制文件，所有用户都可用，如 cat、ls、cp等等 /boot 存放引导加载程序文件，例如kernels、initrd等 /dev 存放必要的设备文件，例如/dev/null /etc 存放主机特定的系统级配置文件。 /etc/opt 存储着新增包的配置文件 /opt/. /etc/sgml 存放配置文件，比如 catalogs，用于那些处理SGML(译者注：标准通用标记语言)的软件的配置文件 /etc/X11 X Window 系统11版本的的配置文件 /etc/xml 配置文件，比如catalogs，用于那些处理XML(译者注：可扩展标记语言)的软件的配置文件 /home 用户的主目录，包括保存的文件，个人配置，等等 /lib /bin/ 和 /sbin/中的二进制文件的必需的库文件 /lib&lt;架构位数&gt; 备用格式的必要的库文件。 这样的目录是可选的，但如果他们存在的话肯定是有需要用到它们的程序 /media 可移动的多媒体(如CD-ROMs)的挂载点。(出现于 FHS-2.3) /mnt 临时挂载的文件系统 /opt 可选的应用程序软件包 /proc 以文件形式提供进程以及内核信息的虚拟文件系统，在Linux中，对应进程文件系统（procfs ）的挂载点 /root 根用户的主目录 /sbin 必要的系统级二进制文件，比如， init, ip, mount /srv 系统提供的站点特定数据 /tmp 临时文件 (另见 /var/tmp). 通常在系统重启后删除 /usr 二级层级存储用户的只读数据； 包含(多)用户主要的公共文件以及应用程序 /usr/bin 非必要的命令二进制文件 (在单用户模式中不需要用到的)；用于所有用户 /usr/include 标准的包含文件 /usr/lib 库文件，用于/usr/bin/ 和 /usr/sbin/中的二进制文件 /usr/lib&lt;架构位数&gt; 备用格式库(可选的) /usr/local 三级层次 用于本地数据，具体到该主机上的。通常会有下一个子目录, 比如, bin/, lib/, share/. /usr/local/sbin 非必要系统的二进制文件，比如用于不同网络服务的守护进程 /usr/share 架构无关的 (共享) 数据. /usr/src 源代码，比如内核源文件以及与它相关的头文件 /usr/X11R6 X Window系统，版本号:11，发行版本：6 /var 各式各样的（Variable）文件，一些随着系统常规操作而持续改变的文件就放在这里，比如日志文件，脱机文件，还有临时的电子邮件文件 /var/cache 应用程序缓存数据. 这些数据是由耗时的I/O(输入/输出)的或者是运算本地生成的结果。这些应用程序是可以重新生成或者恢复数据的。当没有数据丢失的时候，可以删除缓存文件 /var/lib 状态信息。这些信息随着程序的运行而不停地改变，比如，数据库，软件包系统的元数据等等 /var/lock 锁文件。这些文件用于跟踪正在使用的资源 /var/log 日志文件。包含各种日志。 /var/mail 内含用户邮箱的相关文件 /var/opt 来自附加包的各种数据都会存储在 /var/opt/. /var/run 存放当前系统上次启动以来的相关信息，例如当前登入的用户以及当前运行的daemons(守护进程). /var/spool 该spool主要用于存放将要被处理的任务，比如打印队列以及邮件外发队列 /var/mail 过时的位置，用于放置用户邮箱文件 /var/tmp 存放重启后保留的临时文件 操作mac os下载软件1brew install tree tree 树形目录12# 列出当前文件夹下两层目录结构tree -L 2 #####tldr 命令手册 1234567891011tldr chmod# returnsChange the access permissions of a file or directory.- Give the [u]ser who owns a file the right to e[x]ecute it: chmod u+x file- Give the user rights to [r]ead and [w]rite to a file/directory: chmod u+rw file...... script 记录命令行回话1script autojump 一键跳转12 软件源配置文件123456# 文件名/etc/apt/sources.list# 文件内容 code 为系统版本代号 ubuntu 14 为 trusty， ubuntu 16 为 xenial ,ubuntu 17 为 artful ， ubuntu 18为 bionicdeb http://nginx.org/packages/debian/ codename nginxdeb-src http://nginx.org/packages/debian/ codename nginx find 查找文件12345# 在etc文件夹下查找名为 nginx.conf 的文件find /etc -name nginx.conf# 在根目录/下查找名为usr的文件夹find / -name usr -type d grep 文本搜索12345678910grep /regExp/ fileName [options]# 显示所有以d开头的文件中包含 test的行grep ‘test’ d*# 显示在aa，bb，cc文件中匹配test的行。$ grep ‘test’ aa bb cc# 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。$ grep ‘[a-z]\\&#123;5\\&#125;’ aa traceroute 网络测速 拓扑结构 tarceroute 可以列出分组经过的路由节点, 计算并返回每一跳的延时 1traceroute bing.com chown 改变文件/文件夹所有者123# 把software文件夹拥有者改为pi# 首个pi为用户 必选, 第二个为可选用户组chown -R pi:pi Software pwd 显示当前路径1pwd ln 创建软连接1ln -s /usr/node/bin/node /usr/local/bin/node man 显示命令细节指示1man ls, man sudo 新建并执行shell文件123touch demo.shchmod +x demo.sh./demo.sh #执行 echo 写入文件1echo \"aaaa\" &gt; foo.txt top 按cpu用量查看进程1234top -o cpu# 杀死进程 2200 为进程idsudo kill -9 2200 lsof 按端口占用查看进程1234# 查看3000端口对应的进程lsof -i :3000kill -9 pid ssh连接服务器123456789101112131415161718192021222324252627# 登录ssh username@ipAddress# 登出logout# 重启sudo rebootsudo init 6# 关机sudo power offsudo init 0# 编辑ssh配置文件vim /etc/ssh/sshd_config# 设置 sshd_config 文件的客户端链接时长,心跳# 增加下列字段# 1、客户端每隔多少秒向服务发送一个心跳数据# 2、客户端多少秒没有相应，服务器自动断掉连接ClientAliveInterval 30ClientAliveCountMax 86400# 重启sshd服务service sshd reload 标准流12345678# 向info.log文件写入 1234 , 1代表标准输出流echo 1234 1&gt;info.log# 输出错误流 2 代表标准错误流node error.js 2&gt;error.log# error.jsconsole.error('there is an error') scp从服务器上传/下载文件 ftp默认端口 22 1234567891011# 从服务器向本地下载文件scp username@ip:/remotePath/folterName/fileName /localPath/folderName# 从本地向服务器上传文件scp /localPath/folderName/fileName username@ip:/remotePath/folderName# 从服务器下载目录scp -r username@ip:/remotePath/folderName /localPath/# 将整个目录同步到服务器scp -r /localPath/folderName username@ip:/remotePath/folderName 注册开机启动程序 使用 upstart 或者 systemd , 取决于你的系统使用的哪种服务管理 systemd 命令行工具 systemctl 12345# 查看systemctl 版本systemctl --version# 增加配置文件touch /etc/systemd/system/nodeserver.service Create the service file nodeserver.service 123456789101112131415161718192021[Unit]Description=Node.js Example Server#Requires=After=mysql.service # Requires the mysql service to run first[Service]ExecStart=/usr/bin/node /opt/nodeserver/server.js# Required on some systems#WorkingDirectory=/opt/nodeserverRestart=always# Restart service after 10 seconds if node service crashesRestartSec=10# Output to syslogStandardOutput=syslogStandardError=syslogSyslogIdentifier=nodejs-example#User=&lt;alternate user&gt;#Group=&lt;alternate group&gt;Environment=NODE_ENV=production PORT=1337[Install]WantedBy=multi-user.target enable the service 1systemctl enable nodeserver.service start the service 1systemctl start nodeserver.service verify it’s running 1systemctl status nodeserver.service upstart 1 其他软件配置nginxnginx默认静态html目录 /usr/share/nginx/html 配置文件 / etc/nginx/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#运行用户user nobody;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志及PID文件#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;#工作模式及连接数上限events &#123; #epoll是多路复用IO(I/O Multiplexing)中的一种方式, #仅用于linux2.6以上内核,可以大大提高nginx的性能 use epoll; #单个后台worker process进程的最大并发链接数 worker_connections 1024; # 并发总数是 worker_processes 和 worker_connections 的乘积 # 即 max_clients = worker_processes * worker_connections # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4 为什么 # 为什么上面反向代理要除以4，应该说是一个经验值 # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000 # worker_connections 值的设置跟物理内存大小有关 # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数 # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右 # 我们来看看360M内存的VPS可以打开的文件句柄数是多少： # $ cat /proc/sys/fs/file-max # 输出 34336 # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内 # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置 # 使得并发总数小于操作系统可以打开的最大文件数目 # 其实质也就是根据主机的物理CPU和内存进行配置 # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。 # ulimit -SHn 65535&#125;http &#123; #设定mime类型,类型由mime.type文件定义 include mime.types; default_type application/octet-stream; #设定日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off， #以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; #开启gzip压缩 gzip on; gzip_disable \"MSIE [1-6].\"; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; #设定虚拟主机配置 server &#123; #侦听80端口 listen 80; #定义使用 www.nginx.cn访问 server_name www.nginx.cn; #定义服务器的默认网站根目录位置 root html; #设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; #默认请求 location / &#123; #定义首页索引文件的名称 index index.php index.html index.htm; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #过期30天，静态文件不怎么更新，过期可以设大一点， #如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ .php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; &#125;&#125; vim 强行退出不保存修改 ctrl + c =&gt; :q! 解压文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.tar 解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.tar.xz解压：tar -Jxvf FileName.tar.xz压缩：tar -Jcvf FileName.tar.xz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName———————————————.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知———————————————.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z———————————————解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -","categories":[],"tags":[]},{"title":"Express —— nodejs开发框架总结","slug":"Express","date":"2018-08-30T06:06:18.700Z","updated":"2018-10-01T14:58:29.262Z","comments":true,"path":"2018/08/30/Express/","link":"","permalink":"http://zexiplus.github.io/2018/08/30/Express/","excerpt":"","text":"Express 介绍了express 框架的搭建， 配置， 简单使用和扩展用法 目录[TOC] 快速使用 下载生成器 1npm i -g express-generator 12345678910111213141516171819202122232425262728var express = require('express')var path = require('path')var app = express()// 应用中间件app.use(express.static(path.join(__dirname, 'www/')))app.use((req, res, next) =&gt; &#123; &#125;)app.get('/',(req, res) =&gt; &#123; res.end('hello')&#125;)// 挂载多个中间件函数app.get('/', fn1, fn2, fn3) app.listen(3000)// 定义路由var users = express.Router()users.get('/', fn)users.get('/home', fn)// 自定义路径router.get('/:name', function (req, res) &#123; res.send('hello, ' + req.params.name)&#125;)app.use(users) API express express() 返回一个服务器对象实例 1const app = express() express.static(dirname) 设置express服务器静态目录 1app.use(express.static(`$&#123;__dirname&#125;/static`)) http.createServer(app) http 代理express服务器 1http.createServer(app).listen(3001) app app.locals 保存本地变量 1app.locals.title = 'my title' app.delete() 删除 路由, 中间件 123app.delete('/', function (req, res) =&gt; &#123; res.send('delete request to home page') &#125;) app.use(path, fn) 使用中间件 1234567891011121314151617181920212223// 全局使用app.use((req, res, next) =&gt; &#123; // 设置状态码和响应头 res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;) // 根据不同的url 设置不同的响应体 switch (req.url) &#123; case: '/': res.end('hello world'); break; case: 'doc': res.end('welcome to doc page') break; default: res.end('where are you') &#125; // 调用下一个中间件函数, 不调用next request对象就不再向后传递了 next(); &#125;)// 匹配 '/path'路由调用中间件app.use('/path', (req, res, next) =&gt; &#123;&#125;) app.all(‘*’, fn) 所有请求都经过此方法 123456app.all('*', (req, res, next) =&gt; &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;) next()&#125;) app.get(path, fn), app.post(), app.put(), app.delete … 响应不同请求方法 12345678910111213141516171819202122232425app.get('/home', (req, res) =&gt; &#123;&#125;)app.post('/login', (req, res) =&gt; &#123;&#125;)// put 请求用于上传资源app.put('/logout', (req, res) =&gt; &#123;&#125;)// get 动态匹配app.get('/path/:id', (req, res) =&gt; &#123; res.end(`请求参数是$&#123;req.params.id&#125;`)&#125;)// 参数后加问号表示可选参数app.get('/path/:name?', (req, res) =&gt; &#123; if (req.params.name) &#123; // do something &#125;&#125;)// 匹配多个参数 app.get('/path/:where/who/:name', (req, res) =&gt; &#123; res.end(`path is $&#123;req.params.where&#125;, name is $&#123;req.params.name&#125;`)&#125;) // 匹配正则表达式app.get(/^\\/path\\/(\\w+)(\\.\\.(\\w+))?/, (req, res) =&gt; &#123;&#125;) app.set(key, val) 设置express实例变量 123// 设置模版引擎和模版目录app.set('view engine', 'pug')app.set('views', __dirname + '/views') app.listen(port, [callback]) 监听端口 app.engine(ext, callback) 设置模版引擎 12// 模版引擎设置为pugapp.engine('pug', require('pug').__express) app.path() 返回express实例所对应的路径 12345678const app = express()const doc = express()const blog = express()app.use('/doc', doc)doc.use('/blog', blob)// returns /doc/blogconsole.log(blog.path()) request req.app 对服务器实例app的引用 req.ip 请求的IP地址 req.url 请求的路径 req.files 请求上传的文件 req.method 请求的方法 req.headers 请求头 1req.headers['x-no-compression'] req.params 请求的参数对象 1234app.get('/path/:params/route/:params2', (req, res) =&gt; &#123; &#125;)req.params // returns &#123;params: 123, params2: 345&#125; req.query 请求的查询参数 123let url = 'http://www.test.com/search?q=123&amp;s=456'req.query.q // returns 123req.query // &#123;q: 123, s: 456&#125; req.cookies 12// Cookie: name=tobireq.cookies.name // 'tobi' req.signedCookies 加密的cookie 值 123// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3req.signedCookies.user // tobi req.protocol 返回请求的协议 1req.protocol // 'http' , 'https', '' req.param(‘key’) 获取 get, post 请求参数 123456// get: ?name=tobireq.param('name') // 'tobi'// post: age=16req.param('age') // 16// /user/tobi for /user/:namereq.param('name') // tobi req.is(type) 判断请求类型 123req.is('application/json') // true or falsereq.is('application/*') // true or falsereq.is('text/*') req.get(headerName) 获取请求头信息 1req.get('Contentd-Type') // 'text/html' req.accepts(contentType) 根据请求头 accepts 字段判断 浏览器可以接受的文档类型 12req.accepts('html') // truereq.accepts(['html', 'json']) // true req.acceptsLanguage(lang), req.acceptsCharsets(charset), req.acceptsEncoding(encoding) 判段浏览器可以接受的语言, 字符集, 编码类型 response res.writeHead(statusCode, options) 设置http状态吗和响应头信息 1res.writeHead(200, &#123;'Content-Type': 'text/plain', 'Content-Length': 1234&#125;) res.setHeader(key, value) 设置响应头 1res.setHeader('cache-control': 'max-age=315360000, public, immutable') res.redirect([statusCode], url) 重定向 12res.redirect(301, 'http://www.bing.com')res.redirect('http://www.bing.com') res.sendFile(filePath) 发送文件 1res.sendFile('/path/to/play.mp4'); res.render(templateName, message) 用模版渲染页面 12// 在模版目录里面找到 index 前缀文件, res.render('index', &#123;message: 'hello world'&#125;) res.status(code) 返回状态码 1res.status(500).send('something error') res.send(body) 发送响应体 123res.send('&lt;p&gt;title&lt;/p&gt;')res.send(&#123;some: 'json'&#125;)res.send(new Buffer('hello world')) res.end(body) 发送响应并结束响应 1res.end('&lt;p&gt;this is end&lt;/p&gt;') res.download(path, [filename], [fn]) 下载文件 123456789res.download('/download/file1.pdf')res.download('/download/file2.pdf', 'book.pdf')res.download('/download/file3.pdf', err =&gt; &#123; if (err) &#123; &#125; else &#123; &#125;&#125;) res.cookie(name, value, [opt]) 设置cookie 12res.cookie('name', 'fabi', &#123;domain: '.temp.com', path: '/', secure: true&#125;)res.cookie('rememberme', '1', &#123; expires: new Date() + 1000, httpOnly: true &#125;) res.clearCookie(name, [opt]) 清除cookie 12res.clearCookie('name', &#123;path: '/'&#125;)res.clearCookie() res.format() 格式化输出返回, 配合req.accepts() to select handler for the request 1234567res.format(&#123;&#125;)res.format(&#123; 'text/plain': function () &#123; res.send('hello world') &#125;, 'text/html': function () &#123; res.send('&lt;p&gt;hello world&lt;/p&gt;') &#125;, 'application/json': function () &#123; res.send(&#123;message: 'hey') &#125;&#125;,&#125;) res.type() 控制返回类型 123res.type('html')res.type('png')res.type('application/json') res.json() 返回对象 123res.json(&#123;name: 'float'&#125;)res.json(null)res.status(500).json(&#123; error: 'message' &#125;) express router 简单router 123456789const router = express.Router()router.get('/about', (req, res) =&gt; &#123; res.send('welcome about')&#125;)app.use('/app', router)// url: www.demo.com/app/about router.route 挂载多个方法 123456789const router = express.Router()router.route('/api') .post((req, res) =&gt; &#123; &#125;) .get((req, res) =&gt; &#123; &#125;)&#125;) router.param 对参数进行解析 1234567router.param('name', (req, res, next, name) =&gt; &#123; req.name = name next()&#125;)router.get('/hello/:name', (req, res) =&gt; &#123; res.send(req.name)&#125;) express with https 搭建https服务器 123456789101112const fs = require('fs')const options = &#123; keys: fs.readFileSync('/usr/local/key.pem'), cert: fs.readFileSync('/usr/local/key-cert.pem'),&#125;const https = require('https');const express = require('express')const app = express()let server = https.createServer(options, app)server.listen(3000) Https 证书, 私钥创建 12345# 创建私钥openssl genrsa 1024 &gt; key.pem# 创建证书openssl req -x509 -new -key key.pem &gt; key-cert.pem express middlewarehttp://www.expressjs.com.cn/resources/middleware.html 内置中间件 express.static() 设置静态目录, 存放静态资源 1app.use(express.static(__dirname + '/static')) 第三方中间件 cookie-parser https://github.com/expressjs/cookie-parser 用于解析cookie到, cookie-parser不会对出站cookie做设置, 需要手动调用res.setHeader(‘Set-Cookie’: ‘…’) signedCookie : cookie 在出站时生成一段防篡改验证码 1npm i cookie-parser 1res.setHeader('Set-Cookie', `name=$&#123;xiaoxixi&#125;|$&#123;md5(123454)&#125;`) 123456789const cookieParser = require('cookie-parser')app.use(cookieParser())app.get('/', (req, res) =&gt; &#123; // Cookie: name=xiaoxixi, age=24 console.log(req.cookies) // &#123;name: 'xiaoxixi', age: '24'&#125; // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3 console.log(req.signedCookies) // tobi&#125;) body-parser https://github.com/expressjs/body-parser 处理post请求体 1npm i body-parser 1234567891011const bodyParser = require('body-parser')// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extend: false&#125;))// parse application/jsonapp.use(bodyParser.json())// 或直接使用express 内置函数app.use(express.urlencoded(&#123; extend: false &#125;))app.use(express.json()) cookie-session https://github.com/expressjs/cookie-session session 作为存储在服务器端的标识符, 常常存在于散列中, 通过客户端发送的sessionid来判断会话属于哪个用户 1npm i cookie-session 1234567891011121314151617// cookie-session 设置出站cookie // 例如 Set-Cookie: session=eyJ2aWV3cyI6NH0=; path=/; httponlyconst cookieSession = require('cookie-session')app.use(cookieSession(&#123; name: 'session', keys: ['key1', 'key2'], maxAge: 24 * 60 * 60 * 1000 // one day&#125;))app.get('/', function (req, res, next) &#123; // Update views req.session.views = (req.session.views || 0) + 1 // Write response res.end(req.session.views + ' views')&#125;) compression https://github.com/expressjs/compression 用来压缩响应 1npm i compression 12345678910111213const expression = require('compression')// 压缩所有的响应 需要在添加路由前调用app.use(expression())app.use(compression(&#123;filter: function (req, res) &#123; // 根据请求头 过滤压缩响应 if (req.headers['x-no-compression']) &#123; return false &#125; else &#123; return compression.filter(req, res) &#125;&#125;&#125;)) error-handler https://github.com/expressjs/errorhandler 只在开发环境使用的错误处理中间件, 用于把错误信息返回给客户端 1npm i errorhandler 1234567891011121314const errorhandler = require('errorhandler')const notifier = require('node-notifier')if (process.env.NODE_ENV === 'development') &#123; app.use(errorhandler(&#123; log: function (err, str, req) &#123; let title = 'Error in ' + req.method + ' ' + req.url notifier.notify(&#123; title: title, message: str &#125;) &#125; &#125;))&#125; express-session https://github.com/expressjs/session 创建session 1npm i express-session 123456789101112131415const session = require('session')app.use(session(&#123; cookie: &#123; secure: true , maxAge: 60 * 60 * 1000 * 24&#125;,// 设置过期时间为1天的session secret: 'myapp_sid', resave: false, saveUninitialized: true&#125;))app.use((req, res, next) =&gt; &#123; if (!req.session.views) &#123; req.session.views = &#123;&#125; &#125; req.session.views[req.pathname] = (req.session.views[req.pathname] || 0) + 1 next()&#125;) morgan https://github.com/expressjs/morgan http日志请求中间件 1npm i morgan 123456789101112131415const morgan = require('morgan')const path = require('path')const fs = require('fs')// 把日志存档到日志const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), &#123; flags: 'a'&#125;)app.use(morgan('combined', &#123; stream: accessLogStream, skip: function (req, res) &#123; return res.statusCode &lt; 400 &#125;&#125;)) passport https://github.com/jaredhanson/passport 登录验证 1npm i passport multer https://github.com/expressjs/multer 上传文件 1npm i multer 12345678910const multer = require('multer')const upload = multer(&#123; dest: '/uploads' &#125;)app.post('/profile', upload.single('avatar'), (req, res, next) =&gt; &#123; // req.file is avatar&#125;)app.post('/photos', upload.array('photos', 12), (req, res, next) =&gt; &#123; // req.files is photos &#125;) upload.html 12345&lt;form action=\"/pictures/upload\" method=\"POST\" enctype=\"multipart/form-data\"&gt; Select an image to upload: &lt;input type=\"file\" name=\"image\"&gt; &lt;input type=\"submit\" value=\"Upload Image\"&gt;&lt;/form&gt; serve-favicon https://www.npmjs.com/package/serve-favicon 处理浏览器请求站点小图标 1npm i serve-favicon 1234const favicon = require('serve-favicon')const path = require('path')app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))) cors https://github.com/expressjs/cors 处理跨域请求 1npm i cors 123456789const cors = require('cors')// 允许全部请求跨域app.use(cors())// 允许制定路由跨域app.get('/cors', cors(), (req, res) =&gt; &#123; res.status(201).end('hello world')&#125;) method-override https://github.com/expressjs/method-override 支持你在没有put delete的浏览器上使用这些方法 1npm install method-override 12const methodOverride = require('method-override')app.use(methodOverride('X-HTTP-Method-Override')) http-errors https://github.com/jshttp/http-errors 创建错误的http响应 1npm i http-errors 1234567const httpErrors = require('http-errors')app.use((req, res, next) =&gt; &#123; if (!req.user) &#123; return next(httpErrors(401, 'please login first')) &#125; next()&#125;) debug 启动调试 12345# on mac$ DEBUG=express:* node server.js# on windowsset DEBUG=express:* &amp; node server.js Dev &amp; Ops forever | supervisor 开发环境 node 进程刷新 pm2 生产环境node 程序 重启 12345678910111213141516171819202122232425npm i -g pm2# 启动node程序pm2 start app.js# 手动分配四个cluster数量启动node进程pm2 start app.js -i 4# 默认启动最大进程数pm2 start app.js -i max# 列出pm2的进程列表pm2 list# 根据id停止进程pm2 stop 0# 重启pm2 restart 0# 显示 进程 0 的详细信息pm2 show 0# 从列表删除pm2 delete 0 upstart 系统进程管理工具 12345678# downloadsudo apt install upstart# 修改配置文件 必须位于/etc/init/ 目录下sudo touch /etc/init/autonode.conf# 启动程序sudo service autonode systemd 系统进程管理工具2 12345systemctl --versiontouch /etc/systemd/system/autonode.servicevim /etc/systemd/system/autonode.service autonode.service 123456789101112131415161718192021[Unit]Description=Node.js Example Server#Requires=After=mysql.service # Requires the mysql service to run first[Service]ExecStart=/usr/bin/node /opt/nodeserver/server.js# Required on some systems#WorkingDirectory=/opt/nodeserverRestart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Output to syslogStandardOutput=syslogStandardError=syslogSyslogIdentifier=nodejs-example#User=&lt;alternate user&gt;#Group=&lt;alternate group&gt;Environment=NODE_ENV=production PORT=1337[Install]WantedBy=multi-user.target hellonode.conf 1234567891011author \"float\" # 指定作者description \"hellonode\" # 程序的名称或描述setuid \"nonrootuser\" # 用nonrootuser用户运行程序start on (local-filesystems and net-device-up IFACE=eth0) # 在文件系统和网络可用时启动程序stop on shutdown # 关机时停止respawn # 程序崩溃时停止(默认5秒10次)respawn limit 20 5 # 设置为5秒内重启20次, 如果崩溃的话console log # 将 stdin 和 sterr 输出到 /var/log/upstart/hellonode.logenv NODE_ENV=production # 设置环境变量exec pm2 start app.js -i 4 # 启动的脚本命令","categories":[],"tags":[]},{"title":"web前端常用库收录","slug":"Webfront-library","date":"2018-08-28T15:01:21.721Z","updated":"2018-09-29T16:40:02.134Z","comments":true,"path":"2018/08/28/Webfront-library/","link":"","permalink":"http://zexiplus.github.io/2018/08/28/Webfront-library/","excerpt":"","text":"webfront js library前端javascript 仓库收录 Table of content[TOC] Jquery $el.append(a) 在el元素内部末尾添加元素a, 原生dom操作为el.appendChild(a) $el.prepend(a) 在el元素内部开头添加元素a, 原生dom操作为el.insertBefore(a, el.firstChild) crypto.jshttps://github.com/sytelus/CryptoJS CryptoJS是一个纯javascript写的加密类库，目前支持MD5，SHA-1，SHA-256，AES，Rabbit，MARC4，HMAC，HMAC-MD5，HMAC-SHA1，HMAC-SHA256，PBKDF2","categories":[],"tags":[]},{"title":"web前端工程化工具 webpack 重点突破","slug":"Webpack","date":"2018-08-27T02:21:31.574Z","updated":"2018-09-29T16:40:39.822Z","comments":true,"path":"2018/08/27/Webpack/","link":"","permalink":"http://zexiplus.github.io/2018/08/27/Webpack/","excerpt":"","text":"webpack 学习总结目录","categories":[],"tags":[]},{"title":"web前端工程师技能树","slug":"SkillTree","date":"2018-08-21T02:16:26.507Z","updated":"2018-09-29T16:36:59.659Z","comments":true,"path":"2018/08/21/SkillTree/","link":"","permalink":"http://zexiplus.github.io/2018/08/21/SkillTree/","excerpt":"","text":"skill tree 前端技能树 主流web前端所需掌握的前端技能树 javascript 闭包 this指向 双向绑定原理与实现(数据劫持与代理) 如何调试node程序 如何优化js性能 css 如何扩展css功能 高清方案, vw支持方案 动画性能优化 算法 如何计算时间/空间复杂度 动态规划的理解与运用 框架/选型 react/vue 选型分析(jsx模版语法, 单双数据绑定, 成员交接成本, 扩展性等各项属性对比) react/vue 优化方式 构建 webpack 多页面架构可能遇到的问题 webpack 代码分隔方式 webpack 性能及提速方案 webpack 缓存存在的问题及解决方案 webpack 插件原理","categories":[],"tags":[]},{"title":"Javascript","slug":"javascript","date":"2018-08-13T09:06:58.226Z","updated":"2018-10-01T15:03:48.883Z","comments":true,"path":"2018/08/13/javascript/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/javascript/","excerpt":"","text":"Javascript javascript 常用知识点总结 Table of Contents[TOC] Skill 求值表达式 (0, vald) 1234let obj = &#123;a: 1, b: function() &#123;console.log(this.a)&#125;&#125;obj.b() // returns 1(0, obj.b)() // returns undefined(obj.b)() // returns 1 返回值函数 bind 123456// bad return function() &#123; return sum(5, 1)&#125;// goodreturn sum.bind(5, 1) arguments 与箭头函数 12345// arguments 不可以在箭头函数中使用，不存在(...rest) =&gt; &#123; console.log(arguments) // undefined console.log(rest) // 使用rest数组代替arguments&#125; Object.isExtensible() &amp; Object.preventExtensions() 1234let a = &#123;&#125;Object.isExtensible(a) // expected : trueObject.preventExtensions(a)Object.isExtensible(a) // expected: false Object.getOwnPropertyDescriptor(obj, prop) 123let obj = &#123;get a() &#123; return 1 &#125;&#125;Object.getOwnPropertyDescriptor(obj, 'a')// return &#123;get: ƒ, set: undefined, enumerable: true, configurable: true&#125; 蹦床函数 trampoline 蹦床函数（把递归函数转化为循环的函数，防止调用栈过多造成 maximum call exceed 错误） 123456const trampoline = (f) =&gt; &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f() &#125; return f&#125; string.LocaleCompare() 比较字符顺序, sort()默认使用字符的asicii码比较, 会导致不是按a-z顺序, 使用 localeCompare比较顺序 1234['único','árbol', 'cosas', 'fútbol'].sort(function (a, b) &#123; return a.localeCompare(b);&#125;);// [\"árbol\", \"cosas\", \"fútbol\", \"único\"] #Class javascript class Number toFixed 固定小数位数 16.12333.toFixed(2) // 6.12 parseInt, Number 转化字符串为数字 123let num = '123%'parseInt(num, 10) // 123Number(num) // NaN String match方法 把字符串中匹配模式的的字符串组成数组并返回 相当于 regexp的exec方法 12let arr = 'dog yellow green bat cat dat'.match(/.at/)// arr =&gt; ['bat', 'cat', 'dat'] 遍历字符串 1234for (let letter of 'abc') &#123; console.log(letter)&#125;// 'a' 'b' 'c' includes 方法 判断给定字符串是否包含字符 12String.prototype.includes(searchString[, position])// true or false substring 方法 截取字符串 12// 截除首字符str.substring(1) startsWith, endWith 判断字符串开头, 结尾 12'hello world'.startsWith('hel') // true'hello world'.endsWith('orld') // true Array Array.from 把类数组转化为数组 123456const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo);// 去重Array.from(new Set(array))[... new Set(array)] … 合并数组 123var a = [1,3,3]var b = [4]var c = [...a,...b] 变量交换 12let a = 1, b = 2;[a, b] = [b, a] find 找到并返回第一个true的值 12[1,2,3,4].find(item =&gt; item &gt; 2)// 3 Object {a} 解构赋值 12345let &#123;a, b, c&#125; = &#123;a: 1, b: 2, c: 3&#125;console.log(a) // 1let &#123;a: animal&#125; = &#123;a: 1, b: 2, c: 3&#125;console.log(animal) // 1 Object.assign 对象浅拷贝, 只修改了对象的原型链, 并没有真正复制属性值 1234let obj = &#123;a: 1, b: 2, c: 3&#125;let extendObj = Object.assign(obj, &#123;d: 4&#125;) // &#123;a: 1, b: 2, c: 3, d: 4&#125;delete obj.aextendObj // &#123;b: 2, c: 3, d: 4&#125; Function rest 剩余参数 123456789function add(...rest) &#123; let sum = 0; for (var val of rest) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 解构赋值&amp;默认参数 12345678910111213141516function demo(&#123;x = 666, y&#125; = &#123;&#125;) &#123; return console.log(console.log(x, y));&#125;// 传undefined 会触发默认效果， null则不会demo(&#123;&#125;) == demo() // 666, undefineddemo(&#123;x: 7, y: 8&#125;) // 7, 8demo(&#123;x: undefined, y: 8&#125;) // 666, 8demo(&#123;x: null, y: 8&#125;) // null, 8let ajax = function(url, option = &#123; crossDomain : false, transformJson : true&#125;) &#123; console.log(option.crossDomain,option.transformJson)&#125;let ajax2 = function(url, &#123; crossDomain = false, transformJson = true&#125;) &#123; console.log(crossDomain, transformJson)&#125; generator 生成器函数 123456789function* sayHello() &#123; yield 'hello1'; yield 'hello2'; return 'end'&#125;var helloGenerator = sayHello();helloGenerator.next() // returns &#123;value: 'hello1', done: false&#125;;helloGenerator.next() // returns &#123;value: 'hello2', done: false&#125;;helloGenerator.next() // returns &#123;value: 'end', done: true&#125;; Iterator 迭代器函数 123var person = &#123;name: 'xiaoxixi', age: 24&#125;;var iterator = new Iterator(person);iterator.next() // returns ['name', 'xiaoxixi']; JSON JSON.stringify(obj, filter, space) obj 为需要格式的对象， filter为函数或数组， space为空格缩进 123let obj = &#123;a: 1, b: 2, c: 3&#125;let str1 = JSON.stringify(obj, ['a', 'b'], 4)// str1 =&gt; &#123;a: 1, b: 2&#125; Date date.toLocaleDateString() 转化为当地时间字符串 12new Date().toLocaleDateString()// 9/16/2018 date.toDateString() 12new Date().toDateString()// \"Sun Sep 16 2018\" date.toLocaleTimeString() 12new Date().toLocaleTimeString()// 11:30:22 AM ES6 Decorator 123456789101112131415161718192021// 装饰器修饰类 @decoratorclass MyClass() &#123; &#125;function decorator(target) &#123; target.hasDecorator = true; target.prototype._number = 0;&#125;MyClass.hasDecorator // truenew MyClass()._number === 0 // true// 装饰器修饰类的属性class MyClass2() &#123; @readonly name() &#123; return 'xiaoxixi' &#125;&#125;function readonly(target, name, descriptor) &#123; descriptor.writable = false; return descriptor&#125; Promise123456// 手动将promise转化为失败态 reject()Promise.reject(\"Testing static reject\").then(function(reason) &#123; // 未被调用&#125;, function(reason) &#123; console.log(reason); // \"Testing static reject\"&#125;); new webApi requestAnimationFrame 12345678910/************ js动画 以60hz调用函数得函数 requestAnimationFrame **********/requestAnimationFrame(function (timeStack) &#123; // 接受一个函数作为参数，这个函数得参数为一个 date 对象，代表当前函数运行时的时间戳&#125;)somethingAnimation() &#123; el.style.width = `$&#123;parseInt(el.style.width, 10) + 1&#125;%`; // 每一帧的操作 if(something) &#123; // 根据判断条件调用下一帧动画 requestAnimationFrame(somethingAnimation) &#125;&#125; FileReader 123456789/************* 文件读取构造函数 构造函数 FileReader *************************/&lt;input type=\"file\" id=\"fileUp\"&gt;document.addEventListener(document.querySelector('#fileUp'), 'change', function(e) &#123; var reader = new FileReader(); reader.readAsDataURL(e.target.files[0]); reader.onload = function() &#123; someDom.innerHTML = `&lt;img src=\"$&#123;reader.result&#125;\" /&gt;` &#125;&#125;) RAM URL 12345678/********* 对象URL window.URL.createObjectURL() *******************/var objUrl = window.URL.createObjectURL(e.target.files[0]); //指向一块内存地址someDom.innerHTML = `&lt;img src=\"$&#123;objUrl&#125;\" /&gt;`/*********** xhr 上传文件 构造函数 FormData ******************/var data = new FormData();data.append('file',e.target.files[0]);xhr.send(data) Web worker 1234567891011121314151617/*********** Web Worker 多线程对象 ***********/var worker = new Worker('sort.js')var arr = [68,66,89,32,18]worder.onmessage = function(event) &#123; var data = event.data; console.log('sorted array is', data)&#125;worker.postMessage(arr)// sort.js 文件self.onmessage = function(event) &#123; var data = event.data; data.sort(function(a, b) &#123; return a - b &#125;) self.postMessage(data)&#125; Html5 notification API 1234567var myNotify = new Notification('标题', &#123; body: '这是正文内容'&#125;)myNotify.onclick = function () &#123; console.log('消息被点击')&#125; others comment specification 12345678// 函数（sublime快捷键 /** + 回车） /** * 数据格式化 * @param src &#123;Array&#125; 长度自由的一维数组，子元素为json对象 * @param data &#123;Object&#125; 参考数据 * @ignore created 2013-10-11 * @return result &#123;Array&#125; 返回格式化后与src类型相同的数组 */","categories":[],"tags":[]},{"title":"web前端程序员必备单词,短语,简称收录","slug":"Word","date":"2018-08-13T09:06:58.223Z","updated":"2018-09-29T16:41:12.184Z","comments":true,"path":"2018/08/13/Word/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/Word/","excerpt":"","text":"term abbr full explain SSO Single Sign O 单点登录 CAS Central Authentication Service 中心授权服务 DAO data access object 数据访问对象 ISP Internet Service Provider 互联网服务提供商 FCC Federal Communications Commission 美国联邦通信委员会 PR pull request 提交请求 LPWA low power wide area A/B test 网站更新了新UI，统计用户是否更喜欢新页面。定义之前的页面为A，新页面为B，一半用户会被重定向至B， 统计下通过A/B页面到达网站内页的用户占的百分比是多少。 UX User expreience 用户体验 GR graceful degradation 优雅降级, 先从最主流的浏览器实现,再回头兼容老版本浏览器,修复bug PE progressive enhancement 渐进增强, 先从最基本的功能做起, 保证高度的兼容性, 逐渐迭代复杂功能 FAQ Frequently asked question 常见问题 TCP Transmisssion control protocol 传输控制协议 负责在不可靠的传输信道上提供可靠的抽象层 IP internet Protocol 因特网协议 SSR server side render 服务端渲染 Prefix &amp; suffix pre 预先 de 反 re 重复 words intersect 相交 deprecated 弃用 Interaction 交互 detailed below 详细如下 conjunction 连词 trend 趋势 category 类别 stacked 堆叠 Indicates 指示 emulate 仿真 ​ wildcard 通配符 credentials 证书 innovations 创新 rapidly 急速 delivering 交付 cuttingedge 前沿 insight 眼光 gains 收益 snippet 片段 causal 因果 ​ consistency 一致性 guarantees 担保 sequential 顺序 secondary 次要 manipulations 操作 proper 适当的 omitted 省略 inferred 推断 pulse 脉冲 amend 修改 ​ proposal 提议，提案 interoperability 互通性 assess 评估 catalogue 目录 brewing 酿造，混合 custom operators 自定义操作符 nutshell 简而言之 extracts 摘录 subsequent 随后的 recognition 识别 Violations 违规 thermal 热 anomalies 异常 unparalleled 空前的 distributed 分布式 hood 罩子 leverage 杠杆 firmata 签约 repetition 重复 interprets 解释 ​ plural 复数的 gotcha 疑难杂症 visionary 空想家 forerunner 先行者 shrink 收缩 unattended 无人值守的 alternate 备用的 deploy 部署 sparse 稀疏 migrate 迁移 ​ ultimate 终极的,最终的 abstraction 抽象化 conformant 符合 aggregation 聚合 advanced 高级的 shield 保护 brake 制动 spinner 微调 poles 极 voltage 电压 ​ satisfies 满足 ultrasonic 超声的 Infrared 红外线 compress 压缩 hung up 挂了 optimize 优化 vibrant 充满活力的 capacity 容量 archive 档案 thread 线程 ​ synchronized 同步 aggregate 合集 bulk 大批 minifier 缩小器 mangle 损坏 discriminator 鉴别 distinct 不同 legacy point 遗留点 spherical 球形 deliberately 故意 ​ complex 复杂 contraption 玩意儿 domino 多米诺骨牌 inventor 发明者 insurance 保险 retirement 退休 grid 格子 exceeds 超过 concepts 概念 legend 说明 ​ logarithmic 对数的 regarding 关于 plotted 绘制 make sense 合理 overlapping 重叠 composing 构成 nested 嵌套 corresponds 对应 outlet 出口 precedence 优先权 ​ semicolon 分号 quoted 引 introduce 采用，介绍 practice 实践 predictable 可预测 incorrect 不正确的 side effects 副作用 hollow 空心 disallow 不允许 stripped 剥离 ​ syntax 语法 kebab 烤肉串 demand 需求 hassle 争论 comprehensive 全面 specification 规范 manually 手动 masterpiece 杰作 initially 原来 maintain 保持 ​ parentheses 括号 indentation 缩进 assignment 赋值 circulate 循环 unary 一元 Integrating 整合 summary 概要 composed of 由。。。组成 Intuitive 直观的 combine 结合 ​ intermediate 中间 essentially 实质上 arbitrary 随机，随意 dimensional 尺寸的，空间的 Predictor 预报器 Protocol 协议 outperform 表现出色 offloading 卸载 detection 发现 pinned 置顶 ​ consistent 一贯的 toolset 工具集 manipulate 使用，操纵 occasions 场合 notable 显著的 adheres 黏附 semantic 语义 commercially 商业 permissive 宽容 kernel 内核 ​ demonstration 示范 dummy 假的 verbos 动词 coroutine 携程 respectively 分别 illustrated 插图 catalogue 目录 segments 片段 tensors 张量 yield 产生 ​ prior 预先 described 描绘 expert 专家 governance 治理 Steering 掌舵 Technical 技术 Committee 委员会 guidelines 方针 conduct 引导 collaborators 合作者 ​ Initial 初始 consensus 共识 agenda 议程 moderator 主席 dissent 异议 inspector 检查员 manually 手动的 invoked 调用 arch 拱门，拱起 comprehensively 综合 ​ corresponding 相应的 manner 方式 experimental 试验 syscalls 系统调用 underneath 在…下 topic heading 主标题 patch 补丁，打补丁 matures 成熟 proven 证明 Primitive 原始 ​ Terminology 术语 distinguish 区分 cluster 簇 strip 剥夺 Zen 禅 dense 稠密 purity 纯度 ， 纯净 practical 实用的 ambiguity 歧义 Indeterminate 不定的 ​ attachment 附件 duplicate 重复的 mutate 变异 snip 剪断 dump 倾倒 spec 规范 quantity 数量 reproduction 复制 proposal 提议 inventory 库存 ​ delimit 划分界限 as per 按照 batch 批量 degree 学历 caveats 注意事项 enhancement 增强 mimics 模仿 nor 也不 Shebangs 小东西 Interpolation 插值 ​ sponsors 赞助商 orientation 方向 flexibility 灵活性 capabilities 功能 suspends 挂起 decouple 解耦 productivity 生产率 coexist 共存 compose 构写 scene 情景 ​ emphasize 注重 embrace 接受，拥抱 integration of 整合 dramatically 显著的 diverse 多种 fundamental 基础的， 基本原理 indicator 指示符 verbose 详细的 up-to-date最新的 retrieve 取回 ​ ellipse 椭圆 polyline 折线 polygon 多边形 draft 草案 flagged 标记 squash 压扁 rebase 复位，垫底 trampoline 蹦床 factorial 阶乘 detection 发现 ​ constrained 受限，制约 ops 运营 collaboration 合作 rationalizing 合理化 agile 敏捷 legacy applications 传统应用程序 evolve 发展，变化，进化 automate 自动化 investment 投资 ​ rarely 很少 duplex 复式 exclusively 仅仅 retrieved 检索 纠正 挽回 potentially 可能 threshold 阈值 threads 线程 concurrency 并发 contrast 对比 construct 构造 inefficient 低效 ​ scalable 可扩展的 governance 管理 collaborators 合作者 are made collaborators 成为合作者 individuals 个人 invitations 邀请函 significant 重大 identified 确定 particular 特定的 opt 选择 ​ crypto 加密 formula 配方，公式 elevate 提升 architecture 架构 eject 推出 suppress 抑制 represent 表示 synopsis 概要 Manual 手册 truncat 截去 ​ backslashes 反斜线 escape 转义 bounce 反弹, 跳跃 detect 检测 stuff 东西，东东 bunch 大量，簇 miscellaneous 杂 eject 推出 suppress 抑制 represent 表示 ​ synopsis 概要 circuits 电路 sketch 草图 affordable 实惠 schematic 概要 palette 调色板 terms 条款 aspect 方面 primed cache 启动缓存 compile 编译 ​ idiosyncratic 特质 captivating 迷人的 spot 斑点，发现 cords 线 plotter 绘图仪 shafts 轴 massive 海量的 deficits 赤字 bio 个人简历 mandarin 普通话 官话 ​ retweet 转载，转推 transparency 透明度 crooked 扭曲的 numerous 多 terrific 了不起的 stakeholders 利益相关者 pioneering 创举 ban 禁止 tax 税 witch 巫婆 ​ drone 无人机 Avenger 复仇者 flyover 天桥 silk 丝 subsidies 补贴 massive 大规模的 destructive 破坏性的 bycatch 误补 territorial 领土的 hereby 特此 ​ obtaining 获得 council 政务会 nuclear 核 bode 预兆 yup 是的 coated 涂 droplets 液滴 creatures 生物 concise 简洁的 conduct 开展 ​ domestic 国内的 surveillance 监控 contact 联系 gotcha 明白了 spare 剩余的，备用的，空闲的 yeehaw 惊叹词（兴奋的表达） hell 地狱 sufficient 足够 pros 优点 cons 缺点 ​ gauge 衡量 metrics 指标 exception 例外 redundant 冗余 regardless 而不管 accidentally 偶然的 stitch 缝合，拼接 cliffs 悬崖 mechanism 机制 constraints 限制 ​ interferes 干涉 mitigate 缓解 Exceptional 优秀的 idiosyncratic 特质 forgery 伪造 bachelor 学士 teaser 预告 celebrity 名人 contract 合同 periodic 定期 ​ quizzes 测验 labs 实验室 fairness 公平 couple 耦合 cast 投 variance 差异 molest 骚扰 oral 口的 sketches 素描 epic 史诗般的 ​ criteria 标准 supreme 至上的 uphold 维持 except for 除了 racism 种族主义 Estimated 预估 encapsulates 包括包裹 identical 相同，一致 delegate 代表 cascade 及联 performant 高性能的 aka 别名 stale 陈旧的 craft 打造，手艺 Typography 排印，排版 Horizontally 水平的 Vertical 垂直的 slack 偷懒 insomnia 失眠症 discard 抛弃 ​ eliminate 消除 counterpart 副本 demonstrate 演示 curly braces 大括号 dimensions 尺寸，维度 encounter 遇到 portrait 纵向，肖像 portrait mode 竖屏模式 landscape 风景 landscape mode 横屏模式 ​ mockup 模型，样例 realm 领域 Universal 通用 tweak 调整，拧 ultra 超 dedicated 专用的 diagram 图表 Alternatively 另外 boil it down 总结一下 contemplating 考虑 ​ manipulate 操作 versus 相对，与 screw something up 把事情搞砸了 orthogonal to 和…息息相关 overwhelmed 不堪重负，压倒 vast 广大 historical 历史的 lens 镜头 characters 字符 ink 墨水 ​ dip 浸 trendy 新潮 concrete 具体的 conceptual 概念上的 crap 废物 warranted 必要的 decade 十，年代 inevitably 必将 run into 遇到 mass 块 ​ critical 临界 hit critical mass 达到临界质量 wind up 以…结束 multiple 多 intrinsic 固有的 inherent 固有的 complicate 使…复杂 impact 碰撞 illustration 插图 crisply 清晰 ​ fuzzy 模糊 narrow 狭窄 suffix 后缀 scenarios 场景 incognito 匿名的 commerce 商业，商务的 e-commerce 电子商务 measure 测量 subjected 受到 former 前者 ​ get around 绕过 populate 填充 descendant 后代 leeway 余地 Inherit 继承的 pluck 选取 crucial 重要的 coordinate 配合，协作 satellite 卫星 communities 社区 ​ thrive 茁壮成长 mechanics 机制 disposal 处置 era 时代 reduction 减少 decent 正经的，像样的，合适的 audience 听众 premium 额外付费 budget 预算 trade-offs 权衡 ​ Scavenger 清道夫 condensed 精简 generic 通用的 serif 趁线 genuine 真实的 synthesized 综合的 roman 常规的 representative 代表 numerically 数字 monk 和尚 ​ gothic 哥特 cursive 草体，行书 gears 齿轮 amateur 业余 subconscious 潜意识 caption 标题 ligature 连字 nudge 轻推 reserve 保留 twofold 双重 ​ activate 激活 subtle 巧妙的 hyphens 连字符（-） uneven 不均匀的 inviting 诱人的 strips 带子 optimal 最佳的 inconsistent 不一致的 scratch 划破，挠 barely 仅仅 ​ burden 负担 apostrophes 逗号标点 vocabulary 词汇 alter 改变 underlying 底层 disposable 一次性的 tenant 客户，租户 swap 交换 emphasis 重点 extra 额外的，特别 ​ replicate 复制 flat 平坦，简洁 Workbench 工作台 Migration 迁移 Wizard 向导 effectively 实际上 gentler 简洁的 sophisticated 复杂的 thus far 至此 divergence 差异 comes in handy 派上用场 summarize 总结 incorporate 合并，包括 accommodate 适应容纳 conventions 公约 overarching 总体 recursive 递归，逐步 obsolete 过时的 etiquette 礼仪 granular 细粒度 pseudo 伪 armed with 用…武装 presentational 表征的 solely 独自的 equivalent 等同 maintainable 可维护的 alterations 改变 sake of 为了 complications 并发症 stringent 严格 gnarly 复杂，粗糙 frowned upon （皱眉头）不满意 glossed over 轻轻带过 versatile 多才多艺的 interplay 相互作用 installment 部分，分期 fault 故障 generalization 概要 vectors 矢量 scalar 标量 ​ matrices 矩阵，模型 heap 堆 shim 垫片 crack 破解 durable 耐用的 sustainable 可持续发展的 portable 轻便的 discard 放弃 hint 提示 chunk 块 saturate 饱和度 chaos 混沌 keygen 注册机 material 材料 median 中位数 vendor 供应商 vibration 震动 mute 静音,哑巴 simulation 模拟 monotony 单调，乏味 ​ address 解决 reproducible 可复现的 unobtrusive 不显眼的 partial 局部的 coercion 强制 ephemeral 短暂的 gradual 缓增 adoption 采用 relevant 相应 tray 托盘 denied 拒绝 crawle 爬行, 抓取 variadic 可选的 intact 原封不动的 Hierarchy 等级制度 Decompose 分解 interlude 插曲 Miscellaneous 各种各样的 forum 论坛","categories":[],"tags":[]},{"title":"React 学习总结","slug":"React","date":"2018-08-13T09:06:58.219Z","updated":"2018-09-29T16:22:51.596Z","comments":true,"path":"2018/08/13/React/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/React/","excerpt":"","text":"react 参考Table of content[TOC] react react 使用 api 脚手架 Create-react-app(官方) https://github.com/facebook/create-react-app 使用 12345# using npmnpm init react-app my-app# using yarnyarn create react-app my-app Assets Import img 1234import logo from './logo.png'function Photo() &#123; return &lt;img src=&#123;logo&#125; alt=\"logo\" /&gt;&#125; import css 1import './css/app.css' API ReactDOM.render 在指定dom元素上渲染react元素 123const element = &lt;img src=&#123;img.url&#125; /&gt;const dom = document.querySelector('.pic')ReactDOM.render(element, dom) JSX 普通表达式 1const element = &lt;div&gt;hello world&lt;/div&gt; 嵌入表达式 使用单层括号使用变量, 函数 { variable } 12345678const name = 'float'const userinfo = (person) =&gt; &#123; return `person's name is $&#123;person.name&#125; age is $&#123;person.age&#125;`&#125;const element = &lt;div&gt;hello, &#123;name&#125;&lt;/div&gt;const element2 = &lt;div&gt;hello, &#123;userinfo(&#123;name: 'float'&#125;)&#125;&lt;/div&gt;ReactDOM.render(element, document.querySelector('body')) Components and props Functional components 函数组件 1234567function Welcome (props) &#123; return &lt;div&gt;hello &#123;props.name&#125;&lt;/div&gt;&#125;const welcome = &lt;Welcome name=\"float\"&gt;&lt;/Welcome&gt; ReactDOM.render(welcome, document.querySelector('body')) class components 类组件 12345678class Tittle extends React.Component &#123; render() &#123; return &lt;h1&gt;this is a tittle &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;// 渲染类组件const tittle = &lt;Tittle name=\"float\" /&gt; composing components 嵌套组件 1234567891011function Parent(props) &#123; return &lt;div id=&#123;props.id&#125;&gt; &lt;Sub index=\"1\"&gt;&lt;/Sub&gt; &lt;Sub index=\"2\"&gt;&lt;/Sub&gt; &lt;/div&gt;;&#125;function Sub(props) &#123; return &lt;p&gt;&#123;props.index&#125;&lt;/p&gt;&#125; Read-only props 组件的属性是只读的 12345// do not use like thisfunction Title(props) &#123; props.name += 'tail' return &lt;h1&gt;name is &#123;&#125;&lt;/h1&gt;&#125; Life circle 组件生命周期钩子函数 State init state 使用constructor 初始化state 1234567891011class Num extends React.Component &#123; constructor(props) &#123; super(props) // state只可以在constructor中可以直接赋值 this.state = &#123;num: 1&#125; &#125; render() &#123; return &lt;div&gt;num is &#123;this.state.num&#125;&lt;/div&gt; &#125;&#125; hooks 钩子函数改变state 1234567891011class Clock extends React.Component &#123; refreshClock() &#123; this.setState(&#123;time: new Date()&#125;) &#125; componentDidMount() &#123; this.clockId = setInterval(() =&gt; this.refreshClock(), 1000) &#125; componentWillUnmount() &#123; this.clearInterval(this.clockId) &#125;&#125; setState 改变state 12345678910// 对象作为参数this.setState(&#123; name: 'float', age: 24&#125;)// 函数作为参数, 用于引用state, propsthis.setState((state, props) =&gt; (&#123; num: props.num + 1&#125;) share state 当两个组件需要共享state时, 提升state 12345678910111213141516171819202122232425262728293031323334353637383940class ParentState extends React.Component &#123; constructor(props) &#123; super(props) this.saveNum = this.saveNum.bind(this) this.state = &#123; num: 0 &#125; &#125; saveNum(e) &#123; this.setState(&#123; num: e.target.value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;SubState num=&#123;this.state.num&#125; tag='small' onHandleChange=&#123;this.saveNum&#125; /&gt; &lt;SubState num=&#123;this.state.num&#125; tag='big' onHandleChange=&#123;this.saveNum&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class SubState extends React.Component &#123; constructor(props) &#123; super(props) &#125; render() &#123; let num = this.props.num if (this.props.tag === 'big') &#123; num = Number(num) + 5 &#125; let changeHandler = this.props.onHandleChange return ( &lt;div&gt; &lt;input value=&#123;num&#125; onChange=&#123;changeHandler&#125; /&gt; &lt;/div&gt; ); &#125;&#125; Event event binding 事件绑定 1&lt;button onClick=&#123;postData&#125;&gt;&lt;/button&gt; preventDefault 阻止事件默认行为 1234567891011function Submit(props) &#123; function postData(e) &#123; e.preventDefault() // do some thing &#125; return ( &lt;div&gt; &lt;a href=\"#\" onClick=&#123;postData&#125;&gt;&lt;/a&gt; &lt;/div&gt; )&#125; params 事件传参 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; Conditional render state conditional using if 123456789101112131415161718192021222324252627282930313233343536373839404142class LoginControl extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; isLogin: false &#125; &#125; login() &#123; this.setState(&#123; isLogin: true , username: 'float'&#125;) &#125; logout() &#123; this.setState(&#123; isLogin: false &#125;) &#125; render() &#123; const isLoginFlag = this.state.isLogin let template if (isLoginFlag) &#123; template = ( &lt;div&gt; &lt;p&gt;welcome &#123;this.state.username&#125;&lt;/p&gt; &lt;button onClick=&#123;this.logout&#125;&gt;&lt;/button&gt; &lt;/div&gt; ); &#125; else &#123; template = ( &lt;div&gt; &lt;p&gt;please login&lt;/p&gt; &lt;button onClick=&#123;this.logout&#125;&gt;&lt;/button&gt; &lt;/div&gt; ); &#125; return ( &lt;div&gt; &lt;p&gt;this is login component&lt;/p&gt; &#123;template&#125; &lt;/div&gt; ) &#125;&#125; List render list 列表的渲染, 必须有全局唯一 key 属性 123456789function List(props) &#123; return ( &lt;ul&gt; &#123; props.numbers.map( item =&gt; &lt;li key=&#123;item.value.toString()&#125;&gt;&#123;item.value&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; )&#125; Form 表单的渲染与事件绑定 12345678910111213141516171819class Form extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: '' &#125; this.handleValueChange = this.handleValueChange.bind(this) &#125; handleValueChange(e) &#123; this.setState(&#123;name: e.target.value&#125;) &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt;type your name&lt;/label&gt; &lt;input value=&#123;this.state.name&#125; onChange=&#123;this.handleValueChange&#125; /&gt; &lt;span&gt;&#123;this.state.name&#125;&lt;/span&gt; &lt;/form&gt; ); &#125;&#125; Children props.children 非命名子属性, 使用props.children 属性组合其他组件的内容 12345678910111213141516171819202122232425262728293031323334class Mavic extends React.Component &#123; constructor(props) &#123; super(props) &#125; fly() &#123; console.log('I can fly') &#125; render() &#123; return ( &lt;div className=&#123;'colorful' + this.props.color&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125; &#125;class MavicPro extends React.Component &#123; constructor(props) &#123; super(props) &#125; fly() &#123; console.log(' I can fly 60km/h') &#125; render() &#123; &lt;div&gt; &lt;Mavic&gt; &lt;span&gt;hi I am mavic pro&lt;/span&gt; &lt;button&gt;click to buy me&lt;/button&gt; &lt;/Mavic&gt; &lt;/div&gt; &#125;&#125; props.left … 命名子属性 12345678910111213141516171819202122232425function TableContent(props) &#123; return ( &lt;div&gt; &lt;div className=\"left\"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=\"right\"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function RandL() &#123; let left = &lt;div&gt;hello left&lt;/div&gt; let right = &lt;div&gt;hello right&lt;/div&gt; return ( &lt;div&gt; &lt;TableContent left=&#123;left&#125; right=&#123;right&#125; /&gt; &lt;/div&gt; );&#125; react router初始化 install 1npm install react-router-dom using router 1234567891011121314// app.jsimport &#123; Route, Link, BrowserRouter as Router &#125; from 'react-router-dom'const routing = ( &lt;Router&gt; &lt;div&gt; &lt;Route exact path=\"/\" component=&#123;App&#125; /&gt; &lt;Route path=\"/users\" component=&#123;User&#125; /&gt; &lt;Route path=\"/contract\" component=&#123;Contract&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;)ReactDOM.render(routing, document.querySelector('#root')) exact 属性: 精确匹配, 若不加此属性, /users 和 /contract会匹配到 / Tag link 1234567891011121314const routing = ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/users\"&gt;users&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/contract\"&gt;contract&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/\" component=&#123;App&#125; /&gt; &lt;Route path=\"/users\" component=&#123;Users&#125; /&gt; &lt;Route path=\"/contract\" component=&#123;Contract&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;) Switch Switch 标签用于匹配notfound page 1234567&lt;Router&gt; &lt;Link to=\"/\"&gt;home&lt;/Link&gt; &lt;Switch&gt; &lt;Route path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt; BrowserRouter &amp;&amp; HashRouter 两种路由, 浏览器路由和静态哈希路由(浏览器地址栏带有#) 123456789import &#123; BrowserRouter, HashRouter &#125; from 'react-router-dom'function Router() &#123; return ( &lt;BrowserRouter&gt; &lt;link&gt;&lt;/link&gt; &lt;Router /&gt; &lt;/BrowserRouter&gt; )&#125;","categories":[],"tags":[]},{"title":"React Native 学习总结","slug":"React-Native","date":"2018-08-13T09:06:58.219Z","updated":"2018-09-29T16:22:35.534Z","comments":true,"path":"2018/08/13/React-Native/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/React-Native/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Markdown 语法总结","slug":"Markdown","date":"2018-08-13T09:06:58.217Z","updated":"2018-10-01T15:05:09.443Z","comments":true,"path":"2018/08/13/Markdown/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/Markdown/","excerpt":"","text":"markdown 总结一些markdown的常用语法 语法 废弃线 – 双波浪线包裹 – 这里是废弃的内容~~ toc 生成markdown 的目录 – [toc] + 回车 文件引用 index.js README.md 文件写法Repository name 仓库名 一级标题 Overview 概览 二级标题 Table of contents 目录 三级标题 Quick start 快速开始 二级标题 install 下载 四级标题 start 开始 四级标题 debug 调试 四级标题 Feathres 特色 二级标题 Known issues 已知问题 二级标题 Troubleshoting 故障排除 二级标题 Advanced Use 高级用法 二级标题 Configuration 配置 二级标题 Options 选项 三级标题 Usage example 使用例子 三级标题 license 许可证 二级标题","categories":[],"tags":[]},{"title":"Electron 使用javascript开发通用桌面程序框架","slug":"Electron","date":"2018-08-13T09:06:58.216Z","updated":"2018-10-01T14:57:02.550Z","comments":true,"path":"2018/08/13/Electron/","link":"","permalink":"http://zexiplus.github.io/2018/08/13/Electron/","excerpt":"","text":"Electron使用javascript, html, css 构建跨平台桌面应用 https://electronjs.org/ 1npm i electron@latest 目录[TOC] 封装/打包 &amp; 脚手架模版 electron-vue https://github.com/SimulatedGREG/electron-vue vue 在 electron环境下的脚手架 12345678910# 初始化项目结构vue init simulatedgreg/electron-vue my-projectcd my-projectyarn # 开发模式yarn run dev# 编译生成二进制文件yarn run build electron-forge 可打包成二进制文件 https://github.com/electron-userland/electron-forge 123456789101112npm install -g @electron-forge/cli@betaelectron-forge init my-new-appcd my-new-app# 开发模式下打开应用npm start# 生成二进制文件npm run package# 生成二进制文件的压缩包npm run make 使用说明, 两种方法 使用electron-forge init projectname 来初始化项目, 然后在此项目内开发 基于已有的项目, 把package.json文件内的 script , config, dependencies 和 devDependdencies 复制进来 electron-packager https://github.com/electron-userland/electron-packager 1electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] electron-builder https://github.com/electron-userland/electron-builder 12# download yarn add electron-builder --dev APIapp 主线程可用 https://electronjs.org/docs/api/app 监听应用程序的生命周期, 控制窗口操作 12345678910111213const &#123; app &#125; = require('electron')app.on('window-all-closed', () =&gt; &#123; app.quit()&#125;)// 使程序获得焦点app.focus() // 退出程序app.quit()// 隐藏程序app.hide() BrowserWindow https://electronjs.org/docs/api/browser-window 创建或销毁窗口 12345678910111213141516171819202122232425262728293031323334const &#123; BowserWindow &#125; = require('electron').remotelet win = new BowserWindow(&#123; width: 400, height: 400, minWidth: 400, minHeight: 400, resizable: true, frame: false, // 无边框 show: true, // 显示或隐藏&#125;)win.loadURL(path.join(`file://$&#123;__dirname&#125;/app/index.html`))// 监听页面 window.close() 事件win.on('close', () =&gt; &#123; app = null&#125;)// 监听页面的crash事件并给出提示框win.on('crash', () =&gt; &#123; const option = &#123; type: 'info', message: 'This process has crashed.', &#125; electron.dialog.showMessageDialog(option, fn)&#125;)win.on('move', function () &#123; app.getSize() // 获得尺寸 app.getPosition() // 获得位置&#125;)win.on('resize', fn)win.show() app/index.html 12&lt;a href=\"javascript:window.close()\"&gt;点击关闭窗口&lt;/a&gt;&lt;a href=\"javascript:process.crash()\"&gt;点击触发crash&lt;/a&gt; dialog 对话框 https://electronjs.org/docs/api/dialog 打开文件夹 12345678const &#123; dialog &#125; = require('electron').remotedialog.showOpenDialog(&#123; properties: ['openDirectory', 'openFile', 'multiSelections'],//允许选择目录,文件,多选 defaultPath: '', // 默认打开路径&#125;, function (filePaths) &#123; // filePaths 为路径数组&#125;) 保存文件操作 12345dialog.showSaveDialog(&#123; defaultPath: '',&#125;, function (filename) &#123; &#125;) 系统通知对话框 123456dialog.showMessageDialog(&#123; type: 'info', title: 'Renderer Process Crashed', message: 'This process has crashed.', buttons: ['Reload', 'Close']&#125;) IpcRenderer 从渲染进程到主进程的异步通讯 https://electronjs.org/docs/api/ipc-renderer 12345// 绑定信道事件ipcRenderer.on(channel, function (event, arg) &#123;&#125;)// 向主进程发送事件ipcRenderer.send(channel, args) ipcMain 从主进程到渲染进程通讯 https://electronjs.org/docs/api/ipc-main 1ipcMain.on(channel, function (event, arg) &#123;&#125;) remote 渲染进程可用 https://electronjs.org/docs/api/remote 在渲染进程中使用主进程模块, 方法 123456const &#123; BrowserWindow &#125; = require('electron').remotelet win = new BrowserWindow(&#123; width: 700, height: 700,&#125;)win.loadURL('http://www.github.com') globalShortcut 快捷键监听 https://electronjs.org/docs/api/accelerator 123456const &#123; app, globalShortcut &#125; = require('electron')app.on('ready', () =&gt; &#123; globalShortcut.register('CommandOrControl+Y', () =&gt; &#123; // do something &#125;)&#125;) clipboard 主线程, 渲染进程可用 https://electronjs.org/docs/api/clipboard 剪贴板 12345678910111213141516171819const &#123; clipboard &#125; = require('electron')// 复制纯文本clipboard.writeText('some string')// 读取剪贴板中的内容let clipText = clipboard.readText()// 带有格式的文本clipboard.writeHTML('&lt;p&gt;this is a p&lt;/p&gt;')// 读取带有格式的剪贴板内容let clipHtml = clipboard.readHTML()// 复制图片到剪贴板clipboard.writeImage(image)// 读取剪贴板的图片let img = clipboard.readImage() shell 主进程, 渲染进程可用 https://electronjs.org/docs/api/shell 系统级别调用命令 12345678910111213141516const &#123; shell &#125; = require('electron')// 使用默认浏览器打开网址shell.openExternal('https://www.github.com') // 在finder中显示文件 返回Boolean值, 成功为true, 失败为falseshell.showItemInFolder(fullPath)// 以默认应用打开文件 返回Boolean值, 成功为true, 失败为falseshell.openItem(fullPath) // 删除文件 返回Boolean值, 成功为true, 失败为falseshell.moveItemToTrash(fullPath)// 放出系统提示音shell.beep() systemPreferences 主进程可用 https://electronjs.org/docs/api/system-preferences 获取 系统偏好设置 1234const sys = require('electron').systemPreferences// 是否是黑暗模式 mac os有效sys.isDarkMode() tray 主进程可用 https://electronjs.org/docs/api/tray 系统托盘 123456789101112131415161718192021const &#123; app, Menu, Tray &#125; = require('electron')let tray = nullapp.on('ready', () =&gt; &#123; tray = new Tray('/path/to/myicon') const contextMenu.buildFromTemplate([ &#123;label: 'Item1', type: 'radio'&#125;, &#123;label: 'Item2', type: 'radio', checked: true&#125; ]) // 设置鼠标提示 tray.setToolTip('hello my guest') // 设置菜单内容 tray.setContextMenu(contextMenu) // 销毁托盘 tray.destory() // 设置图标 tray.setImage(image) tray.on('click', (event, bounds, position) =&gt; &#123; // event 事件对象, bounds 系统托盘图标的边界, position 事件的位置信息 &#125;) &#125;) screen 主进程, 渲染进程可用, 在 app 模块ready事件之后可用 https://electronjs.org/docs/api/screen 检测屏幕, 光标位置信息 123456789101112131415161718const electron = require('electron')const &#123; app, BrowserWindow &#125; = electronapp.on('ready', () =&gt; &#123; const &#123; screen &#125; = electron // 获得显示器长宽 const &#123; width, height &#125; = screen.getPrimaryDisplay().workAreaSize // 获得所有显示器列表数组 const displays = screen.getAllDisplays() // 获取鼠标绝对位置 const cursor = screen.getCursorScreenPoint() // 返回菜单的高度 const menu = screen.getMenuBarHeight()&#125;) session 主进程可用 https://electronjs.org/docs/api/session 管理浏览器会话, cookie, 缓存 123456789const &#123; BrowserWindow &#125; = require('electron')let win = new BrowserWindow(&#123; width: 800, height: 600&#125;)win.loadURL('http://www.github.com')const session = win.webContents.sessionconsole.log(session.getUserAgent()) Menu 主进程可用 https://electronjs.org/docs/api/menu 创建原生应用菜单 123456789101112131415const &#123; app, Menu &#125; = require('electron')const template = [ &#123; label: 'Edit', submenu: [ &#123;role: 'undo'&#125;, &#123;role: 'redo'&#125;, &#123;role: 'delete'&#125;, ] &#125;]const menu = Menu.buildFromTemplate(template)Menu.setApplicationMenu(menu) Notification 主进程可用 https://electronjs.org/docs/api/notification 系统通知栏 12345678910111213import Notification from 'electron'Notification.isSuported() // 返回系统是否支持通知const opt = &#123; title: '通知', body: '这是一条通知', icon: '/assets/img/nogify.png', sound: '/assets/sound/notify.mp3',&#125;const notify = new Notification(opt)// 显示这条通知notify.show() webContents 主进程可用 https://electronjs.org/docs/api/web-contents 渲染和控制web页面 123456789101112131415161718const &#123; BrowserWindow &#125; = require('electron')let win = new BrowserWindow(&#123; width: 800, height: 600&#125;)let contents = win.webContents// 获取app所有的web 页内容, 是一个数组contents.getAllWebContents()// 获取当前焦点的web 内容页contents.getFocusedWebContents()// 主进程向渲染进程发消息contents.send(channel, function (args) &#123; // do someting &#125;) webFrame 渲染进程可用 https://electronjs.org/docs/api/web-frame 自定义渲染页面 12345678910111213const &#123; webFrame &#125; = require('electron')// 页面放大2倍webFrame.setZoomFactor(2)// 获取当前页面的缩放倍数webFrame.getZoomFactor()// 插入text到焦点元素webFrame.insertText(text)// 释放不在使用的内存webFrame.clearCache() webView 渲染进程可用 https://electronjs.org/docs/api/webview-tag 类似于iframe 在进程中显示独立的网页 123456&lt;webview id=\"view\" src=\"https://www.github.com\" plugins // 可以访问插件 preload=\"./test.js\" // 指定事先加载脚本 &gt;&lt;/webview&gt; powerMonitor 主进程可用 https://electronjs.org/docs/api/power-monitor 监控系统级事件 123456789const electron = require('electron')const &#123; app &#125; = electron// 必须在程序启动后监听系统电源事件app.on('ready', () =&gt; &#123; electron.powerMonitor.on('suspend', () =&gt; &#123; console.log('the system is going to sleep') &#125;)&#125;) powerSaveBlocker 主进程可用 https://electronjs.org/docs/api/power-save-blocker 组织系统进入休眠状态 1234567const &#123; powerSaveBlocker &#125; = require('electron')// 阻止系统休眠const id = powerSaveBlocker.start('prevent-display-sleep')// 取消powerSaveBlocker.stop(id) cookies 主线程可用 https://electronjs.org/docs/api/cookies 查询和修改一个会话的cookies 123456789101112131415161718const &#123; session &#125; = require('electron')// 设置cookieconst cookie = &#123; url: 'http:// www.github.com', name: 'dummy_name', value: 'dummy_value',&#125;session.defaultSession.cookies.set(cookie, err =&gt; &#123; if (err) &#123; console.log(err) &#125; &#125;)// 读取cookiesession.defaultSession.cookies.get(&#123;url: 'http://www.github.com'&#125;, (err, cookies) =&gt; &#123; console.log(err, cookies)&#125;) DesktopCapturer 渲染进程可用 https://electronjs.org/docs/api/desktop-capturer 录屏, 截屏 net 主进程可用 https://electronjs.org/docs/api/net 使用Chromium的原生网络库发出HTTP / HTTPS请求 12345const &#123; net &#125; = require('electron')const request = net.request('https://www.github.com')request.on('response', res =&gt; &#123; console.log(res)&#125;) client-request 主线程可用 https://electronjs.org/docs/api/client-request 发起http/https请求 1234567891011121314const &#123; ClientRequest &#125; = require('http')const request = new ClientRequest(&#123; method: 'GET', protocol: 'https:', hostname: 'github.com', port: 443, path: '/'&#125;)request.on('login', (authInfo) =&gt; &#123;&#125;)request.on('response', res =&gt; &#123; console.log(res)&#125;)","categories":[],"tags":[]},{"title":"Requirejs 学习收录","slug":"Requirejs","date":"2018-08-09T09:52:33.831Z","updated":"2018-09-29T16:36:05.881Z","comments":true,"path":"2018/08/09/Requirejs/","link":"","permalink":"http://zexiplus.github.io/2018/08/09/Requirejs/","excerpt":"","text":"requirejs RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载 基本使用 加载使用 data-main 属性不可忽虑, 指定主代码所属的脚本文件 123&lt;head&gt; &lt;script src=\"js/require.js\" data-main=\"js/entry.js\"&gt;&lt;/script&gt;&lt;/head&gt; 配置项 config paths 用于指定模块的位置, 属性值可以是字符串/数组, 若是数组, 从第一个地址加载, 加载失败则用之后的路径加载 12345678910// paths 指定模块的链接地址require.config(&#123; paths: &#123; 'vue': './lib/vue.min', 'vueRouter': [ 'www.cdnjs.com/js/vueRouter.js', './lib/vue-router.min' ] &#125;&#125;) baseUrl 用于指定本地模块的基准目录, 该属性通常由require.js加载时的data-main属性指定 1234require.config(&#123; paths: ..., baseUrl: 'js/entry.js'&#125;) shim 有些库不是amd规范库, 需要该属性帮助加载非amd兼容的库 12345678910require.config(&#123; paths: &#123; 'underscore': 'lib/underscore', &#125;, shim: &#123; 'underscore': [ exports: '_' ] &#125;&#125;) 定义模块 define entry.js 1234567891011121314151617181920212223242526272829// 定义命名模块define('myModule', function () &#123; return &#123;&#125;&#125;)// 定义无依赖模块, define 接受的函数只能是对象或者函数define(&#123; method1: function () &#123;&#125;, method2: function () &#123;&#125;&#125;)define(function () &#123; var module = [] return module&#125;)// 定义有依赖的模块define(['js/module1', 'js/module2'], function (module1, module2) &#123; // 使用module1, module2 module1.method1();&#125;)// 定义多个模块, 避免数组太长,参数太长书写不便define(function (require) &#123; var module1 = require('js/module1'); var module2 = require('js/module2'); var moduel3 = require('js/module3');&#125;) 调用模块 require 1234require(['js/module1', 'js/module2'], function (module1, module2) &#123; module1.methods(); module2.methods();&#125;) 例子 vue &amp; vueRouter &amp; element with requirejs Index.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link href=\"css/elementUi.css\" /&gt; &lt;script data-main=\"entry.js\" src=\"lib/require.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;el-button&gt;test&lt;/el-button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; entry.js 123456789101112131415161718192021222324require.config(&#123; paths: &#123; 'vue': 'lib/vue.min', 'vueRouter': 'lib/vue-router.min', 'ELEMENT': 'lib/elementUI.js', &#125;, baseUrl: 'lib'&#125;)define('entry', function (require, exports, module) &#123; var ELEMENT = require('ELEMENT'); var Vue = require('vue'); var router = require('script/router') Vue.use(ELEMENT); new Vue(&#123; el: '#app', router: router; data: function () &#123; return &#123; text: 'hello world' &#125; &#125; &#125;)&#125;) router.js 123456789101112131415define('router', function (require, exports, module) &#123; var Vue = require('vue'); var VueRouter = require('vueRouter'); var component1 = require('component1'); Vue.use(VueRouter) return new VueRouter(&#123; routes: [ &#123; path: '/', component: component1, &#125; ] &#125;)&#125;)","categories":[],"tags":[]},{"title":"DOM & BOM 总结","slug":"DOM&BOM","date":"2018-08-02T06:28:06.389Z","updated":"2018-10-01T14:56:27.309Z","comments":true,"path":"2018/08/02/DOM&BOM/","link":"","permalink":"http://zexiplus.github.io/2018/08/02/DOM&BOM/","excerpt":"","text":"DOM &amp; BOMdom对象和bom对象总结 table of contents[TOC] DOMdocument object model HTMLCollection &amp;&amp; nodeListsimiliarty: 都是类数组，都有length属性 都有getter， list.item(0) 或 list[0] 都是动态的， 其内元素变化会反映到其自身 difference: nodeList 保存的是node( 包含含空节点，文本节点, 注释等)，HTMLCollection 保存的是 element（element继承node，不含其他元素， 只有element元素nodetype 为 1） HTMLCollection有个nameItem() 方法，可以返回集合中name属性和id属性值的元素。 Node attribute attribute Intro demo someNode.nodeType 节点类型（1 - 12） 1 为 元素element，3 为文本，11 位文档片段documentFregment someNode.nodeName 节点标签名 ‘p’, ‘div’ , someNode.tagName someNode.nodeValue 节点值 someNode.childNodes 节点的子节点类数组，保存着一个nodeList someNode.childNodes[0]someNode.childNodes.item(1)Array.prototype.slice.call(childNodes, 0) someNode.children 返回子节点中还是元素的集合(nodetype为1),是HTMLCollection的实例 someNode.children[0] someNode.hasChildNodes() 子节点是否含有childNodes someNode.childNodes.length === 0 someNode.parentNode 节点的父节点，所有子节点拥有同一父节点 someNode.previousSibling 节点的兄弟节点（相邻的上一个节点） someNode.nextSibling 节点的兄弟节点（相邻的下一个节点） someNode.firstChild 节点的第一个子节点, 可能是文本，注释， 空节点等 someNode.lastChild 节点的最后一个子节点 someNode.firstElementChild 节点的第一个元素节点 someNode.lastElementChild 节点的最后一个元素节点 someNode.previousElementSibling 节点的兄弟节点（相邻的上一个元素节点） someNode.nextElementSibling 节点的兄弟节点（相邻的下一个元素节点） someNode.childElementCount 返回子元素（nodeType = 1）节点个数 someNode.dataset 返回当前元素的自定义属性集 &lt;div data-myrule=&quot;123&quot;&gt;&lt;/div&gt; div.dataset.myrule // return ‘123’ Node method method Intro Demo someNode.appendChild(A) 在someNode的nodeList末尾添加一个A someNode.insertBefore(A, B) 在参照节点（B）前添加一个A 节点, 若第二个参数是 null , 则执行与 appendChild 相同操作 someNode.replaceChild(new,old) 用new节点替换 old节点，old为someNode的子节点 someNode.replaceChild(node, someNode.firstChild) someNode.removeChild(A) 移除someNode下的某个子节点A A.removeChild(A.firstChild) someNode.cloneNode(boolean) 复制节点 ，boolean 为 true 执行深复制， boolean 为 false 执行浅复制(只复制当前元素，不复制子元素)。执行复制之后的节点没有父节点，成了孤儿，必须通过以上集中操作才能显示。 const deepNode = someNode.cloneNode(true) deepNode.length // 3 const shallowNode = someNode.cloneNode(false) shallowNode.length // 0 someNode.machesSelector(cssSelector) 接收一个css选择符作为参数，返回 el.machesSelector(‘body.label’) // =&gt; true or false document Attr &amp; method Intro Demo document.documentElement 取得对元素的引用 document.documentElement === document.childNodes[0] === document.firstChild document.title 获取/设置文档标题 document.title // 获取titile document.title = ‘epic doc’ // 设置title document.URL 获取页面完整的url（不可设置） https://cn.demo.com/search?q=1234 document.domain 获取/设置页面的域名，只能设置其站点的子域名 document.domain // https://cn.demo.com document.domain = ‘demo.com’ // success document.domain = ‘baidu.com’ // failed document.referrer 获取跳转到当前页面的那个页面的url document.getElementById() document.getElementsByTagName() 返回一个HTMLCollection,有个方法nameItem() const list = document.getElementsByTagName(‘p’); list.nameItem(‘myName’) // 返回这个htmlCollection 中name为myName的元素 document.getElementsByName() 返回一个HTMLCollection document.anchors 返回一个HTMLCollection，包含所有带name属性的元素 document.forms 返回所有元素 document.images 返回所有元素 document.links 返回所有带href属性的元素 document.open() docuement.close() document.createElement(tagName) 创建元素 document.createElement(‘div’) document.createTextNode(string) 创建文本节点 document.createTextNode(‘hello world’) doc.createDocumentFragment() 创建轻量级文档，继承document的所有属性。 const fregment = document.createDocumentFragment(); for( let i = 0; i &lt; 3; i++) { let li = document.createElement(‘li’); fregment.appendChild(li)} document.querySelector() 返回第一个匹配的节点 document.querySelectorAll() 返回所有匹配的节点， 是一个nodeList快照，不会动态刷新 doc.getElementsByClassName(classStr) 参数传入类名字符串，多个类名用空格隔开 document.getElementByClassName (‘sidebar content green’) element Nodetype 为 1 (important) nodevalue为 null attr &amp;&amp; method Intro demo el.nodeName 返回元素标签名(大写) el.nodeName === el.tagName === ‘DIV’ el.tagName 返回元素标签名(大写) el.id 返回元素的id el.className 返回元素的类名字符串，多个类名用空格隔开 el.classList 返回一个具有length属性的DOMTokenList的实例,具有item(), add(), contains(), remove(), toggle() 方法 el.classList.add(val) //添加 el.classList.contains(val) // 判断el.classList.remove(val) // 删除el.classList.toggle(val) // 切换 el.title 返回元素的标题 el.style 返回 一个 以object 表示的css描述, 属性转换为驼峰命名法,例如: background-color =&gt; style.backgroundColor = ‘red’ el.style // =&gt; {color: ‘#fff’} el.getAttribute(‘style’) // =&gt; ‘color: …’ el.getAttribute(attrName) 返回属性字符串表示 el.setAttribute(attrName, attrValue) 设置属性 el.removeAttribute(attrname) 移除属性 el.contains(A) 判断节点A是否是el的子节点,返回true,false el.scrollIntoView(true/false) 使元素出现在视窗内 el.scrollByLines(lineCount) 使元素滚动指定的行数,lineCount 可以是正负值 non-standard el.scrollByPages(pageCount) 使元素滚动指定的页数,pageCount 可以是正负值 non-standard dynamic script &amp;&amp; style12345678910111213141516171819202122232425// dynamic scriptfunction dynamicScript(url) &#123; let script = document.createElement('script') script.type = 'text/javascript' script.src = url document.body.appendChild(script)&#125;function dynamicScriptWithText(text) &#123; let script = document.createElement('script') script.type = 'text/javascript' let textNode = document.createTextNode(text) script.appendChild(textNode) document.body.appendChild(script)&#125;// dynamic style function dynamicStyle(url) &#123; let link = document.createElement('link') link.type = 'text/css' link.rel = 'stylesheet' link.href = url document.head.appendChild(link)&#125; html translation 显示 说明 实体名称 实体编号 半方大的空白 &amp; ensp; &#8194; 全方大的空白 &amp; emsp; &#8195; 不断行的空白格 &amp; nbsp; &#160; &lt; 小于 &amp; lt ; &#60; &gt; 大于 &amp; gt ; &#62; &amp; &amp;符号 &amp; amp ; &#38; “ 双引号 &amp; quot; &#34; © 版权 &amp; copy; &#169; ® 已注册商标 &amp; reg; &#174; ™ 商标（美国） ™ &#8482; × 乘号 &amp; times; &#215; ÷ 除号 &amp; divide; &#247; 1234567&lt;input id=\"user[name]\" /&gt;// 转义特殊css字符用双反斜杠 '\\\\'&lt;script&gt; document.querySelector('user[name]') // null document.querySelector('user\\\\[name\\\\]') // &lt;input id=\"user[name]\" /&gt;&lt;/script&gt; dom size window.innerHeight 浏览器视窗内高度（当前页面 ，不包括外层iframe） window.innerWidth 浏览器内宽度 div.offsetHeight 元素在垂直方向占用的空间大小（单位-像素） div.offsetWidth 元素在水平方向占用空间大小（单位-像素） div.offsetLeft 元素的左外边框至包含元素的左内边框之间的像素距离 div.scrollLeft 既可以确定元素当前滚动状态，又可以设置元素的滚动位置 BOMbowser object model location浏览器导航对象 ####location attribute Location.href 读取/设置当前window的url 1window.location === window.document.location location.search 读取/设置当前url的搜索字符串 Location.hash 读取/设置当前url的hash location method location.reload() 刷新当前页面 Location.assign(href) 设置当前页面url, 浏览器可产生历史记录, 后退按钮可点击回到上一页 Location.replace(href) 设置当前页面url, 浏览器不产生历史记录","categories":[],"tags":[]},{"title":"Database nodejs常用数据库总结","slug":"Database","date":"2018-08-02T06:28:06.385Z","updated":"2018-10-01T15:02:58.174Z","comments":true,"path":"2018/08/02/Database/","link":"","permalink":"http://zexiplus.github.io/2018/08/02/Database/","excerpt":"","text":"Database 常用数据库操作 Table of Contents[TOC] NO-SQLmongoDB doc mongo command start mongodb 1sudo service mongod start stop mongodb 1sudo service mongod stop restart mongodb 1sudo service mongod restart use mongodb 1234567891011121314# 指定目录启动mongo服务器mongod --dbpath d:\\data\\db # 启用web界面的mongo服务器 界面端口 28017sudo mongod --rest# only connect to the local default mongo servicemongo# or 指定host和端口访问mongo --host 192.168.0.4:27017# 指定用户名密码和数据库访问mongo -u \"myUserAdmin\" -p \"abc123\" --authenticationDatabase \"admin\" mongo config123456789101112# 文件路径/etc/mongodb.conf# 地址和端口配置net: port: 27017 # 默认值，只能通过局域网访问 若通过外网访问，需要设置为 服务器内网ip（192.168.0.4） bindIp: 127.0.0.1 #开启验证登录security: authorization: enabled mongo cli 账号密码管理 https://blog.csdn.net/fofabu2/article/details/78983741 mongodb的用户名和密码是基于特定数据库的，而不是基于整个系统的。所有数据库db都需要设置密码 12345678# 列出当前mongodb服务中的所有数据库show dbs# 选择数据库(若没有admin数据库，则创建admin数据库)use admin# 删除当前数据库db.dropDatabase() 12345678// 新建账户并赋予权限db.createUser(&#123;user: 'xiaoxixi', pwd: 'admin123', roles: [&#123; role: 'userAdminAnyDatabase', db: 'admin',&#125;]&#125;)// 验证创建用户是否成功 0 失败， 1 成功db.auth('xiaoxixi', 'admin123') role取值 readAndWrite 读写 userAdminAnyDatabase 用户管理身份任意数据库 mongoose https://github.com/Automattic/mongoose mongoose 连接mongodb 1234var mongoose = require('mongoose')var db = mongoose.connect('mongodb://username:password@192.168.1.101:port/db_name')db.connection.on('open',fn)db.disconnect() //关闭所有连接 mongoose 模型定义及实例化 123456789101112131415161718var userSchema = new mongoose.Schema(&#123; userName: &#123; type: String, required: true &#125;, password: &#123; type: String, require: true &#125;&#125;)//通多schema定义model，数据库中会自动创建一个名为userInfos的集合var User = mongoose.model('user',userSchema) //直接定义modelvar Dog = mongoose.model('dog',&#123;name: String&#125;) var xiaoxixi = new User(&#123;username:'xiaoxixi',password: '123'&#125;) //实例化var lovelydog = new Dog(&#123;name: 'lovely'&#125;) mongoose 模型扩展 123456789101112131415161718192021//statics 类上扩展userSchema.statics.find_by_username = function(username,cb) &#123; return this.findOne(&#123; //this指向User username:username &#125;,cb)&#125;//调用User.find_by_username('xiaoxixi',function(err,docs) &#123; &#125;)//methods 对象上扩展userSchema.methods.is_exist = function(cb) &#123; var query = &#123; username: this.uername, password: this.password &#125; return this.model('user').findOne(query,cb) // this指向User的实例&#125;//调用var xiaoxixi = new User(&#123;username:'xiaoxixi',password: '12345'&#125;).is_exist(cb) mongoose promise 12//所有方法均可采用promise规范User.find(&#123;&#125;,cb) === User.find(&#123;&#125;).then(cb) mongoose CRUD 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//增加并存储单条数据var userone = new User(&#123;username:'123',password:'456'&#125;).save(function(err,user) &#123;&#125;)//搜索多条文档User.find(&#123;&#125;, function(err,users) &#123;&#125;) //users为文档数组 &#123;&#125;为查询条件//搜索单条文档User.findOne(&#123;&#125;, function(err,user) &#123;&#125;) //user为单条文档//查询并更新User.findOneAndUpdate(conditions, update,cb)//查询并删除User.findOneAndRemove(conditions, cb)//按id查询User.findById(xiaoxixi._id, function(err,user) &#123;&#125;) //移除文档userone.remove((err,user) =&gt; &#123;&#125;) //user参数指代userone//按条件删除单条文档User.deleteOne(&#123;username:'123'&#125;, err =&gt; &#123;&#125;)//批量删除User.deleteMany(&#123;username:/xiaoxixi/,age: &#123;$gte: 18&#125;&#125;,err =&gt; &#123;&#125;)//批量操作User.bulkWrite([ insertOne: &#123; username:'xiaoxixi', password: '123' &#125;, updateOne: &#123; filter: &#123;name: '123'&#125;, update: &#123;password: '666'&#125; &#125;, deleteOne: &#123; filter: &#123;name: '7878'&#125; &#125;]).then(err =&gt; &#123;&#125;)//查询符合条件的数量User.count(&#123;name: 'xiaoxixi'&#125;, (err,count) =&gt; &#123;&#125;)//新建单/多条数据User.create([&#123;name: 'xiaoxixi'&#125;,&#123;name: 'daxixi'&#125;], (err,users) =&gt; &#123; var xiaoxixi = users[0] var daxixi = users[1]&#125;)//异步操作语法whereUser.find(&#123;age: &#123;$gte: 18,$lte: 50&#125;&#125;,cb)User.where('age').gte(18).lte(50).exec(cb)User.where('age').gte(18).where('name',/^b/) SQLmySQL","categories":[],"tags":[]},{"title":"Event 事件对象总结","slug":"Event","date":"2018-08-01T07:10:42.312Z","updated":"2018-10-01T14:57:47.377Z","comments":true,"path":"2018/08/01/Event/","link":"","permalink":"http://zexiplus.github.io/2018/08/01/Event/","excerpt":"","text":"Event浏览器事件总结","categories":[],"tags":[]},{"title":"web项目测试总结","slug":"Test","date":"2018-07-30T07:13:44.523Z","updated":"2018-09-29T16:38:19.019Z","comments":true,"path":"2018/07/30/Test/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Test/","excerpt":"","text":"testunit teste2e test###nightWatch 配置文件 nightwatch.conf.js（nightwatch.json）示例配置详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950require('babel-register')var config = require('../../config')// http://nightwatchjs.org/gettingstarted#settings-filemodule.exports = &#123; src_folders: ['test/e2e/specs'], // 测试的文件夹（相对于根目录） output_folder: 'test/e2e/reports', // 输出log的文件夹（相对于根目录） custom_assertions_path: ['test/e2e/custom-assertions'], //自定义断言文件夹（相对于根目录） selenium: &#123; //自定义selenium-server 配置 start_process: true, // selenium-server(测试服务)程序路径 e.g: bin/selenium-server-standalone-2.43.0.jar server_path: require('selenium-server').path, host: '127.0.0.1', port: 4444, cli_args: &#123; 'webdriver.chrome.driver': require('chromedriver').path // 'webdriver.ie.driver', 'webdriver.firefox.profile' &#125; &#125;, test_settings: &#123; // 设置全局参数，默认变量 default: &#123; launch_url : \"http://localhost\", // 可在测试文件browser.lanuchUrl 拿到 selenium_port: 4444, selenium_host: 'localhost', silent: true, globals: &#123; //全局变量 browser.globals.devServerURL devServerURL: 'http://localhost:' + (process.env.PORT || config.dev.port) &#125; &#125;, chrome: &#123; // 针对chrome的配置 desiredCapabilities: &#123; browserName: 'chrome', javascriptEnabled: true, acceptSslCerts: true &#125; &#125;, firefox: &#123; // 针对firefox的配置 desiredCapabilities: &#123; browserName: 'firefox', javascriptEnabled: true, acceptSslCerts: true &#125; &#125; &#125;&#125; 测试文件 test.js 示例12345678910111213141516module.exports = &#123; 'default e2e tests': function (browser) &#123; // automatically uses dev Server port from /config.index.js // default: http://localhost:8080 // see nightwatch.conf.js const devServer = browser.globals.devServerURL browser .url(devServer) .waitForElementVisible('#app', 5000) .assert.elementPresent('.hello') .assert.containsText('h1', 'Welcome to Your Vue.js App') .assert.elementCount('img', 1) .end() &#125;&#125; ####API api参考 Usual 1234567891011// 元素选择器 element()element(selector) // browser.element('#main') // 判断 expectbrowser.expect.element('#password').to.be.an('input')// 等待元素可见 browser.waitForElementVisible('body', 5000)// 设置input的值browser.setValue('#username', value) Expect 12// 链式调用助动词 （没有实际意义）to,be,been,is,that,which,and,has,have,with,at,does,of Assert 12.assert // 测试失败结束测试.verify // 测试失败跳过，进行下一条测试","categories":[],"tags":[]},{"title":"网站设计取色排版原则","slug":"Web-design","date":"2018-07-30T07:13:44.514Z","updated":"2018-09-29T16:39:36.504Z","comments":true,"path":"2018/07/30/Web-design/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Web-design/","excerpt":"","text":"web design收录了 网站设计原则, 配色方案, 素材地址 配色网站: https://color.adobe.com/zh/explore/?filter=most-used&amp;time=all 分析配色网站: site pattle 网站布局,排版 https://www.thebestdesigns.com/ 图片素材 https://dribbble.com/ web design principle 响应式布局,移动优先原则，及默认的css样式为移动样式，然后通过媒体查询 用 桌面样式覆盖 移动采用上下布局, 桌面端采用 左右布局 整体字体在 14px 到 20px 之间 保持适当行距（1.5倍） 段落采用缩进或隔行，不能两者同时用，首段不用隔行或缩进 web design meterialcolor 浅色主题 边框颜色: #EAEDF0 字体颜色: #5D6063 背景颜色: #FBFCFC","categories":[],"tags":[]},{"title":"Web 性能分析","slug":"Performance","date":"2018-07-30T07:13:44.513Z","updated":"2018-10-02T02:51:03.308Z","comments":true,"path":"2018/07/30/Performance/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Performance/","excerpt":"","text":"Web performanceQuestion 常见问题 什么是阻塞？在页面中我们通常会引用外部文件，而浏览器在解析HTML页面是从上到下依次解析、渲染，如果中引用了一个a.js文件，而这个文件很大或者有问题，需要2秒加载，那么浏览器会停止渲染页面（此时是白屏显示），2秒后加载完成才会继续渲染，这个就是阻塞。 为什么会阻塞？因为浏览器不知道a.js中执行了哪些脚本，会对页面造成什么影响，所以浏览器会等js文件下载并执行完成后才继续渲染，如果这个时间过长，会白屏。 CSS文件也一样，因为CSS文件会对DOM的样式，布局，色彩，效果产生影响，所以浏览器会等CSS文件下载并执行完成后继续。 css 阻塞css 的加载不会阻塞dom的解析(DOM tree), 但会阻塞dom 树的渲染(render tree). 会阻塞之后js代码的执行. 为了避免dom树重新渲染回溯影响性能浪费, 所以css代码的加载会阻塞dom树渲染. 加载事件 load 事件和 DOMContentLoaded 事件 load事件: 页面中的所有静态资源加载完成时触发包括样式表, 图像, 脚本 DOMContentLoaded事件: 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载. 注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发 解决阻塞 延迟加载 defer 把script标签放到 body 的最后一行, 或者在script标签加入 defer属性 1234567891011&lt;head&gt; &lt;script src=\"js/defer.js\" defer&gt;&lt;/script&gt; &lt;script src=\"js/defer2.js\" defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;!-- other --&gt;&lt;html&gt; &lt;body&gt; &lt;/body&gt; &lt;script src=\"js/defer.js\"&gt;&lt;/script&gt;&lt;/html&gt; 异步加载 async 告知浏览器可以边下载边渲染而不用等到js下载再执行后才渲染, 使用了 async 属性的脚本不能保证执行的先后顺序, 异步脚本一定会在页面load事件前执行(所有资源都下载完), 但可能会在DOMContentLoaded 事件前或后执行 1234&lt;head&gt; &lt;script src=\"js/async.js\" async&gt;&lt;/script&gt; &lt;script src=\"js/async2.js\" async&gt;&lt;/script&gt;&lt;/head&gt; 这两种的不同点: defer 会 立即下载,但到 浏览器解析至html标签时才顺序执行.而放在body后的script代码会在遇到这个标签时才下载,下载完成后执行. 动态加载 createElement(‘script’) 当有需要时,再加载脚本 1234567function createScript(src) &#123; var script = document.createElement('script') script.type = 'text/javascript' script.src = src document.head.appendChild(script)&#125;document.querySelector('button').onclick = createScript load 事件之后加载 Onload 事件为页面中所有的图片, 视频,js文件,css文件 等资源都加载完才触发 123window.onload = function () &#123; createScript('js/onload.js')&#125; DOMContentLoaded 事件之后加载 DOMContentLoaded 事件为 形成完整的DOM树后就会触发, 不会理会图像, javascript文件, css文件等其他资源时候下载完毕 123window.addEventListener('DOMContentLoaded', function () &#123; createScript('js/onDOM.js')&#125;) page optmize proposal网页性能优化的34条建议 Minimize HTTP Requests 最小化http请求数 Use a Content Delivery Network 使用内容分发网络 Add an Expires or a Cache-Control Header 给相应头增加过期字段 Gzip Components 压缩组件 Put Stylesheets at the Top 在head内使用样式表 Put Scripts at the Bottom 在body的最后一行引入脚本(或增加defer属性) Avoid CSS Expressions 避免css表达式(只有ie支持css表达式例如top:expression(eval(document.documentElement.scrollTop + document.documentElement.clientHeight - 60)));) Make JavaScript and CSS External 确保脚本和样式表是外联文件 Reduce DNS Lookups 减少dns查询次数 Minify JavaScript and CSS 最小化js和css Avoid Redirects 避免重定向 Remove Duplicate Scripts 删除重复的脚本 Configure ETags 相应头配置ETags字段, 从而判断版本信息 Make Ajax Cacheable 使ajax请求响应可缓存 Flush the Buffer Early 如果请求事件过长, 先发送部分数据 Use GET for AJAX Requests 尽可能在ajax请求使用get方法 Post-load Components 使用延迟加载(对于非必须的优化脚本例如动画,拖动等可以使用延迟加载技术确保主要功能是快速响应的) Preload Components 使用预加载(下一页的图片等资源) Reduce the Number of DOM Elements 减少dom元素数, 减少嵌套标签,减少空标签 Split Components Across Domains 拆分组件至不同域来使用同时下载 Minimize the Number of iframes 使用最少数的iframes No 404s http相应是昂贵的, 消除不必要的404响应 Reduce Cookie Size 减少cookie大小 Use Cookie-free Domains for Components 对于静态资源的请求不使用cookie携带 Minimize DOM Access 减少dom树的直接操作(缓存已放翁过的元素, 减少页面重构次数) Develop Smart Event Handlers 使用高性能的事件处理函数(事件代理, DOMContentLoaded) Choose over @import (IE浏览器使用@import引入的css会在页面最下方引入css一样效果) Optimize Images 优化图片格式,大小 Optimize CSS Sprites 优化精灵图 Don’t Scale Images in HTML 图片的尺寸与显示尺寸对应 Make favicon.ico Small and Cacheable 使网页标题图表小且可缓存 Keep Components under 25K 使文件小于25k(iphone不会缓存25k以上文件大小) Pack Components into a Multipart Document 将文件打包到多个文档 Avoid Empty Image src 避免图片带有空src属性(减少不必要的请求)","categories":[],"tags":[]},{"title":"Koa 新一代web服务开发框架","slug":"Koa","date":"2018-07-30T07:13:44.512Z","updated":"2018-10-01T15:04:00.907Z","comments":true,"path":"2018/07/30/Koa/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Koa/","excerpt":"","text":"koa 官方doc link 笔记 link Table of contents[TOC] 1. koa app Index.js 123456789101112131415161718192021const Koa = require('koa')const app = new Koa()// compute response timeapp.use(async (ctx, next) =&gt; &#123; const startTime = new Date() await next() const endTime = new Date() const time = endTime - startTime ctx.set('X-Response-Time', `$&#123;time&#125;ms`)&#125;)app.use(async (ctx) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3000)console.log('the server is listenning at 3000 port') app’s attributes using explian app.listen app.listen(3000) 监听端口 app.env app.env == ‘development’ app环境变量 app.use app.use(function (ctx, next) {}) 使用中间件 app.keys app.keys = [‘name’, ‘xiaoxixi’] 设置cookie app.context.db app.context.db = new Db() 全局context 设置 app.slient app.slient = true 关闭警告模式(error事件不会出发) app.on app.on(‘error \\ ‘) 监听事件 app.proxy app.proxy = true 设置代理 app.callback() http.createServer(app.callback()) 返回可以被http/connect使用的回调函数 2. middlewaredefine middleware middleware/log.js 1234567891011function log ( ctx ) &#123; console.log(`request method is $&#123;ctx.method&#125;`) console.log(`request header is $&#123;JSON.stringify(ctx.header)&#125;`)&#125;module.exports = function () &#123; return async function ( ctx, next ) &#123; log(ctx) await next() &#125;&#125; use middleware index.js 1234const log = require('./middleware/log.js')const app = new Koa()app.use(log()) 3.router123456789101112131415161718192021222324252627282930313233343536373839// 手动实现路由app.use((ctx, next) =&gt; &#123; let body switch (ctx.request.url) &#123; case '/': body = 'hello one' break case '/home': body = 'hello home' break &#125; ctx.body = body&#125;)// koa-router 中间件const Router = require('koa-router')// 定义2个子路由const config = new Router()const home = new Router()home.get('/one', ctx =&gt; &#123; ctx.body = 'home one' &#125;)config.get('/user', ctx =&gt; &#123; ctx.body = 'user'&#125;).get('/setting', ctx =&gt; &#123; ctx.body = setting&#125;)// 创建父路由，装载子路由const router = new Router()router.use('/home', home.routes(), home.allowedMethods())router.use('/config', config.routes(), config.allowedMethods())// app对象使用父路由app.use(router.routes()).use(router.allowedMethods()) 4.ctx context(ctx) 包含http-response 和 http-request 对象 ctx’s attributes Explian ctx.request koa 请求对象 ctx.response koa 响应对象 ctx.req node http 请求 ctx.res node http 响应 ctx.state ctx.state.user = db.find({name: ‘xiaoxixi’}) 推荐的命名空间 ctx.app 对 app 引用 ctx.cookies.set ctx.cookies.set(‘name’, ‘xiaoxix’, { signed: true }) 设置响应体cookie ctx.cookies.get ctx.cookies.get(‘name’) 获取cookie ctx.throw ctx.throw(400, ‘not found’) 手动抛出错误 5. ctx.request ctx.request attribute alias Explian demo ctx.request.header ctx.header, ctx.request.headers, ctx.headers 请求头 ctx.request.method ctx.method 请求方法 ctx.method = ‘post’ ctx.request.origin ctx.origin 请求源地址(协议和地址) =&gt; http://bing.com ctx.request.length 请求长度 Content-Length ctx.request.url ctx.url 请求url(不包括host) /path?a=123&amp;b=456 ctx.requset.path ctx.path 请求路径 /path ctx.request.href ctx.href 请求href(protocol, host and url) (http://example.com/foo/bar?q=1) ctx.request.queryString ctx.queryString 查询字符串 a=123&amp;b=456 ctx.request.search ctx.search 完整的查询字符串 ?a=123&amp;b=456 ctx.request.host ctx.host 请求的主机 ctx.request.type 请求类型 image/png ctx.request.charset 请求的字体类别 ‘utf-8’ ctx.request.query ctx.query 请求的查询对象 ctx.request.query = {color: ‘blue’, age: 12} ctx.request.fresh ctx.fresh true 没有改变， false改变了 请求体没有改变 If (ctx.fresh) {ctx.status = 304} ctx.request.stale ctx.stale ctx.fresh的反义词 ctx.request.secure ctx.secure 检查协议是否为https ctx.protocol === ‘https’ ctx.request.ip ctx.ip 请求主机的ip ctx.request.ips ctx.ips 请求主机的ip数组 ctx.request.is(types) ctx.is(typs) 判断请求的类型 // With Content-Type: text/html; charset=utf-8 ctx.is(‘html’); // =&gt; ‘html’ ctx.is(‘text/html’); // =&gt; ‘text/html’ ctx.is(‘text/*’, ‘text/html’); // =&gt; ‘text/html’ ctx.is(‘text/json’) // =&gt; false ctx.request.accepts(types) ctx.accepts(types) 判断请求的类型是否为可接受的 // Accept: text/html ctx.accepts(‘html’); // =&gt; “html” ctx.request.acceptsEncoding() ctx.acceptsEncoding() 判断可接受的编码类型 // Accept-Encoding: gzip ctx.acceptsEncodings(‘gzip’, ‘deflate’, ‘identity’); // =&gt; “gzip” ctx.acceptsEncodings([‘gzip’, ‘deflate’, ‘identity’]); // =&gt; “gzip” ctx.request.acceptsCharset() ctx.acceptsCharset() 判断可接受的字符类型 // Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5 ctx.acceptsCharsets(); // =&gt; [“utf-8”, “utf-7”, “iso-8859-1”] ctx.request.accerptsLanguages() ctx.acceptsLanguages() 判断可接受的语言类型 // Accept-Language: en;q=0.8, es, pt ctx.acceptsLanguages(‘es’, ‘en’); // =&gt; “es” ctx.acceptsLanguages([‘en’, ‘es’]); // =&gt; “es” ctx.request.socket 返回request的socket连接对象 ctx.request.get(filed) 获得请求头字段 request.get(‘Content-Type‘) 6.ctx.response ctx.response.attributes alias Explian Demo ctx.response.header ctx.response.headers 响应头对象 ctx.response.socket 响应socket ctx.response.status ctx.status 获得/设置响应的状态码 ctx.status=200 ctx.status // =&gt; 304 ctx.response.message ctx.message 获得/设置响应的状态码信息 ctx.message = ‘ok’ ctx.message // =&gt; ‘not found’ ctx.response.length ctx.length 获得/设置响应的长度 ctx.length = 199 ctx.length // =&gt; 300 ctx.response.body ctx.body 获得/设置响应体 ctx.body = ‘hello world’ ctx.body // =&gt; ‘123’ ctx.response.get(field) 获得相应头字段 ctx.response.get(‘Content-Type’) ctx.response.append(field,val) 添加响应头字段 ctx.response.append(‘Link’, ‘localhost’) ctx.response.set(object) ctx.set(object) 设置响应头信息 ctx.set({‘Etag’: ‘1234’, ‘Last-Modified’: date }) ctx.response.remove(field) ctx.remove(field) 删除响应头字段 ctx.remove(‘Content-Type’) ctx.response.type 获取/设置响应体类型 ctx.response.type // =&gt; text/html ctx.response.type = ‘image/png’ ctx.response.is(types) 判断响应体的类型 if(ctx.response.is(‘html’)) return ctx.response.redirect(url) ctx.redirect(url) 响应跳转 ctx.redirect(‘back’); ctx.redirect(‘back’, ‘/index.html’); ctx.redirect(‘/login’); ctx.redirect(‘http://google.com&#39;); ctx.response.attachment(filename) ctx.attachment(filename) 触发浏览器下载 ctx.response.headerSent ctx.headerSent 检查是否已经发送响应头 if (ctx.headerSent) { // do} ctx.response.lastModified ctx.lastModified 返回/设置Last-Modified响应头的日期对象 ctx.lastModified = new Date(); ctx.response.etag ctx.etag ctx.etag = crypto.createHash(‘md5’).update(ctx.body).digest(‘hex’); ctx.response.vary(field) ctx.response.flushHeaders() 刷新响应头，并开始响应体","categories":[],"tags":[]},{"title":"web图形方案总结","slug":"Graphic","date":"2018-07-30T07:13:44.511Z","updated":"2018-10-01T14:59:28.289Z","comments":true,"path":"2018/07/30/Graphic/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/Graphic/","excerpt":"","text":"Graphicweb前端常用图形处理 目录[TOC] SVG 简介：基于xml的矢量图形描述文件 展现方式 浏览器直接打开 html中标签引用 html中svg标签引入 css的background引入 123456789101112131415161718&lt;!-- simple.svg --&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\"&gt; &lt;circle cx=\"100\" cy=\"100\" r=\"90\" fill=\"#777\" /&gt; &lt;circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"#000\" /&gt; &lt;path d=\"M 50 100 A 50 50 0 0 0 150 160\" stroke=\"white\" stroke-with=\"3\" fill=\"none\" /&gt;&lt;/svg&gt;&lt;!-- img --&gt;&lt;img src=\"simple.svg\" width=\"100\" height=\"100\" /&gt;&lt;style&gt; .svg &#123; width: 200px; height: 200px; background: #07f url(simple.svg) repeat; fill: yellow; // 使用fill修改颜色而不是color &#125;&lt;/style&gt; 基本元素12345678910111213&lt;rect /&gt; &lt;circle /&gt; &lt;ellipse /&gt;&lt;line /&gt;// 折线&lt;polyline /&gt;// 多边形&lt;polygon /&gt;// 任意路径&lt;path /&gt; 基本属性fill, stroke, stroke-width, transform 基本图形样例 rect 1&lt;rect x=\"50\" y=\"50\" width=\"200\" height=\"200\" rx=\"10\" ry=\"30\" /&gt; circle 1&lt;circle cx=\"50\" cy=\"50\" r=\"100\" /&gt; ellipse 1&lt;ellipse cx=\"50\" cy=\"50\" rx=\"20\" ry=\"40\" /&gt; line 1&lt;line x1=\"0\" y1=\"50\" x2=\"87\" y2=\"500\" /&gt; polyline 1&lt;polyline points=\"30 20 100 500 30 89\" /&gt; polygon 1&lt;polygon points=\"20 20 30 58 59 59\" /&gt; canvas绘制路径12345678var ctx = canvas.getContext(‘2d’) // 获取canvas2d上下文canvas.getContext(‘webgl’) //获取3d对象ctx.beginPath() //开始绘制路径 //ctx.closePath() //连接起点终点ctx.moveTo(x,y) //设直线段的起点ctx.lineTo(x,y) //设置线段的终点ctx.lineWidth = 1.0 //设直线段宽度ctx.strokeStyle = ‘red’ //设直线段颜色ctx.stroke() //绘制线段 绘制矩形1234ctx.fillStyle = ‘yellow’ //填充色ctx.fillRect(x,y,w,h) //绘制实心矩形ctx.strokeRect(x,y,w,h) //绘制空心矩形ctx.clearRect(x,y,w,h) //清除矩形 绘制文本1234ctx.font = ‘20px bold Arial’ //设置字体，大小ctx.textAlign = ‘left’ //设置字体居中方式ctx.fileText(text,x,y) //绘制实心字体ctx.strokeText(text,x,y) //绘制空心字体 绘制圆形和扇形12//绘制扇形，anticlockwise 顺时针false，逆时针true，绘制扇形前需要调用beginPath方法ctx.arc(x,y,r,startAngle,endAngle,anticlockwise) 图像处理123456//绘制图像ctx.drawImage(img,x,y[,width,height]) ctx.getImageData(x,y,width,height) //获取图像信息imageData对象有一个data属性，它的值是一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255ctx.putImageData(imgData,x,y) 设置渐变色1234567//x1,y1起点坐标 x2，y2 终点坐标var gradient = ctx.createLinearGradient(x1, y1, x2, y2) gradient.addColorStop(0,color)gradient.addColorStop(1,color) //创见圆形渐变createRadialGradient(x1,y1,r1,x2,y2,r2) Icon图标引入方案svg使用icons8生成整张svg图像 ，按生成页提示名称引入svg 优点：可以任意改变颜色，缩放不会模糊,经编译后无bug 12345678910111213141516171819202122232425&lt;!-- use 标签引入svg路径 --&gt;&lt;i class=\"icon-2\"&gt; &lt;svg&gt; &lt;use xlink:href=\".../path/to/Default.min.svg#icon-2\"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/i&gt;&lt;style&gt; /* 改变大小和颜色 */ .icon-2 &#123; color: red； font-size: 24px； &#125;&lt;/style&gt;&lt;!-- 单独使用构造svg --&gt;&lt;svg width=\"32px\" height=\"32px\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;path d=\"M24,10c0-1.657-1.343-3-3-3c-0.68,0-1.301,0.235- 1.804,0.617C18.467,6.641,17.312,6,16,6 s-2.467,0.641-3.196,1.617C12.301,7.235,11.68,7,11,7c-1.657,0-3,1.343-3,3H6v12h3v3.134C8.701,25.307,8.5,25.63,8.5,26 c0,0.552,0.447,1,1,1c0.841,0,1.5-0.682,1.5-1.552V22h1v3.134c-0.299,0.173-0.5,0.496-0.5,0.866c0,0.552,0.447,1,1,1 c0.841,0,1.5-0.682,1.5-1.552V22h4v3.134c-0.299,0.173-0.5,0.496-0.5,0.866c0,0.552,0.447,1,1,1c0.841,0,1.5-0.682,1.5-1.552V22h1 v3.134c-0.299,0.173-0.5,0.496-0.5,0.866c0,0.552,0.447,1,1,1c0.841,0,1.5-0.682,1.5-1.552V22h3V10H24z M24,20H8v-8h16V20z M15,16 c0-0.552,0.448-1,1-1s1,0.448,1,1c0,0.552-0.448,1-1,1S15,16.552,15,16z M19,16c0-0.552,0.448-1,1-1s1,0.448,1,1 c0,0.552-0.448,1-1,1S19,16.552,19,16z M11,16c0-0.552,0.448-1,1-1s1,0.448,1,1c0,0.552-0.448,1-1,1S11,16.552,11,16z\" fill=\"currentColor\"&gt; &lt;/path&gt;&lt;/svg&gt; sprit图highCharts 图表绘制工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116highCharts.chart(el,options);var options = &#123; chart: &#123; type: 'spline', backgroundColor: '#031824', &#125;, title: &#123; text: '付费用户情况', style: &#123; color: '#fff' &#125;, &#125;, subtitle: &#123; text: '', &#125;, xAxis: &#123; type: 'datetime', //类别 linear, logarithmic, datetime or categories dateTimeLabelFormats: &#123; // don't display the dummy year month: '%e. %b', year: '%b', &#125;, title: &#123; text: '', style: &#123; color: '#fff' &#125;, &#125;, &#125;, yAxis: &#123; title: &#123; text: '', &#125;, min: 0, gridLineWidth: 1, // 格子线宽度 tickInterval: 0.5, //y轴单位间隔 dataLabels: &#123; enabled: true, //显示每一点的数据 &#125;, &#125;, tooltip: &#123; headerFormat: '&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br&gt;', pointFormat: '&#123;point.x:%e. %b&#125;: &#123;point.y:.2f&#125; m', &#125;, plotOptions: &#123; spline: &#123; marker: &#123; enabled: true, &#125;, &#125;, &#125;, series: [&#123; name: '付费用户', color: '#333', //数据线条颜色 allowPointSelect: true, //可选择此点 lineWidth: 5, //线条宽度 data: [ [Date.UTC(1970, 9, 21), 0], [Date.UTC(1970, 10, 4), 0.28], [Date.UTC(1970, 10, 9), 0.25], [Date.UTC(1970, 10, 27), 0.2], [Date.UTC(1970, 11, 2), 0.28], [Date.UTC(1970, 11, 26), 0.28], [Date.UTC(1970, 11, 29), 0.47], [Date.UTC(1971, 0, 11), 0.79], [Date.UTC(1971, 0, 26), 0.72], [Date.UTC(1971, 1, 3), 1.02], [Date.UTC(1971, 1, 11), 1.12], [Date.UTC(1971, 1, 25), 1.2], [Date.UTC(1971, 2, 11), 1.18], [Date.UTC(1971, 3, 11), 1.19], [Date.UTC(1971, 4, 1), 1.85], [Date.UTC(1971, 4, 5), 2.22], [Date.UTC(1971, 4, 19), 1.15], [Date.UTC(1971, 5, 3), 0], ], &#125;, &#123; name: '免费用户', data: [ [Date.UTC(1970, 9, 29), 0], [Date.UTC(1970, 10, 9), 0.4], [Date.UTC(1970, 11, 1), 0.25], [Date.UTC(1971, 0, 1), 1.66], [Date.UTC(1971, 0, 10), 1.8], [Date.UTC(1971, 1, 19), 1.76], [Date.UTC(1971, 2, 25), 2.62], [Date.UTC(1971, 3, 19), 2.41], [Date.UTC(1971, 3, 30), 2.05], [Date.UTC(1971, 4, 14), 1.7], [Date.UTC(1971, 4, 24), 1.1], [Date.UTC(1971, 5, 10), 0], ], &#125;, &#123; name: '总用户', data: [ [Date.UTC(1970, 10, 25), 0], [Date.UTC(1970, 11, 6), 0.25], [Date.UTC(1970, 11, 20), 1.41], [Date.UTC(1970, 11, 25), 1.64], [Date.UTC(1971, 0, 4), 1.6], [Date.UTC(1971, 0, 17), 2.55], [Date.UTC(1971, 0, 24), 2.62], [Date.UTC(1971, 1, 4), 2.5], [Date.UTC(1971, 1, 14), 2.42], [Date.UTC(1971, 2, 6), 2.74], [Date.UTC(1971, 2, 14), 2.62], [Date.UTC(1971, 2, 24), 2.6], [Date.UTC(1971, 3, 2), 2.81], [Date.UTC(1971, 3, 12), 2.63], [Date.UTC(1971, 3, 28), 2.77], [Date.UTC(1971, 4, 5), 2.68], [Date.UTC(1971, 4, 10), 2.56], [Date.UTC(1971, 4, 15), 2.39], [Date.UTC(1971, 4, 20), 2.3], [Date.UTC(1971, 5, 5), 2], [Date.UTC(1971, 5, 10), 1.85], [Date.UTC(1971, 5, 15), 1.49], [Date.UTC(1971, 5, 23), 1.08], ], &#125;],&#125;;","categories":[],"tags":[]},{"title":"Html","slug":"html","date":"2018-07-30T07:13:44.511Z","updated":"2018-09-29T16:14:03.172Z","comments":true,"path":"2018/07/30/html/","link":"","permalink":"http://zexiplus.github.io/2018/07/30/html/","excerpt":"","text":"html html总结 目录[TOC] html 组件 html imports 状态, 草案 垫片方案 引用google 的 webcomponents.js 1&lt;link rel=\"imports\" href=\"myFile.html\" /&gt; html标签 figure 12345&lt;figure&gt; &lt;figcaption&gt;These words are the caption of the picture. This is called a ligature.&lt;/figcaption&gt; &lt;img src='ligature.svg'/&gt;&lt;/figure&gt; look like this a 标签跳转 123456789&lt;!-- 相同页面跳转 --&gt;&lt;a href=\"#my-place\"&gt;&lt;/a&gt;...&lt;div id=\"my-place\"&gt; &lt;/div&gt;&lt;!-- 不同页面跳转 --&gt;&lt;a href=\"space.html#my-place\"&gt;&lt;/a&gt; a标签下载 1&lt;a download=\"file_name\" href=\"file_path\"&gt;download&lt;/a&gt; a标签target 1234&lt;a src=\"test.html\" target=\"custom-iframe\"&gt;点击设定iframe链接&lt;/a&gt;&lt;iframe id=\"custom-iframe\"&gt; &lt;/iframe&gt; 移动端开发标签 meta viewport minimal-ui 最小化ui及使浏览器导航栏默认不显示 screen-orientation portrait 强制竖屏显示 format-detection telephone=no 手机号码不被显示为拨号连接 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, minimal-ui\"/&gt; &lt;meta name=\"screen-orientation\" content=\"portrait\"/&gt; &lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; Html 模版pug(jade) html 模板引擎，可以配合express koa做服务端渲染 pug在线文档 属性 123456a(href=&apos;www.bing.com&apos;,class=&apos;myClass&apos;) hello//- （）括号内普通属性属性之间空格或逗号, 空格后标签文字- var flag = truespan(class=flag ? &apos;light&apos; : &apos;dark&apos;)//- 变量表达式 - 之后","categories":[],"tags":[]},{"title":"chrome 浏览器接口参考","slug":"Bowser","date":"2018-06-19T02:30:44.534Z","updated":"2018-10-01T15:02:34.987Z","comments":true,"path":"2018/06/19/Bowser/","link":"","permalink":"http://zexiplus.github.io/2018/06/19/Bowser/","excerpt":"","text":"chrome.runtime chrome浏览器接口 Table of contents[TOC] chrome.runtime summary 链接 Methods &amp; properties connect, id, getURL, getMainifest, onMessage, sendMessage, onConnect 123456789101112// propertieschrome.runtime.id // the id of the extension/app// methods// connectchrome.runtime.connect(string id, object connectInfo)// sendMessagechrome.runtime.sendMessage(string id, any message, object options, function reponseCallback)// onMessagechrome.runtime.onMessage.addListener(function callback) 插件和页面消息传递 链接 content.js 1234567891011121314// 从页面js发送消息到chrome插件chrome.runtime.sendMessage(&#123;greeting: \"您好\"&#125;, function(response) &#123; console.log(response.farewell);&#125;);// 页面监听浏览器插件发送的消息chrome.runtime.onMessage.addListener( function(request, sender, sendResponse) &#123; console.log(sender.tab ? \"来自内容脚本：\" + sender.tab.url : \"来自扩展程序\"); if (request.greeting == \"您好\") sendResponse(&#123;farewell: \"再见\"&#125;); &#125;); plugin.js 123456// 在扩展程序中与页面通讯chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function(tabs) &#123; chrome.tabs.sendMessage(tabs[0].id, &#123;greeting: \"您好\"&#125;, function(response) &#123; console.log(response.farewell); &#125;);&#125;);","categories":[],"tags":[]},{"title":"ElementUI 踩坑记录","slug":"ElementUI","date":"2018-06-14T01:15:27.740Z","updated":"2018-10-01T14:57:26.562Z","comments":true,"path":"2018/06/14/ElementUI/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/ElementUI/","excerpt":"","text":"elementUiel-table自定义表头jsx实现 1234567891011121314151617181920212223242526&lt;template&gt; &lt;el-table&gt; &lt;el-table-column :render-header=&quot;renderHeader&quot;&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; renderHeader() &#123; return (&lt;div class=&quot;readlist-table-header&quot;&gt; &lt;a class=&#123;[&quot;readtab&quot;,&#123;&quot;active&quot;:!this.readStatus&#125;]&#125; href=&quot;javascript:void(0)&quot; onClick=&#123;this.toUnread&#125;&gt; 未读（&lt;span&gt;&#123;this.tData.unreadNum&#125;&lt;/span&gt;） &lt;/a&gt; &lt;a class=&#123;[&quot;readtab&quot;,&#123;&quot;active&quot;:this.readStatus&#125;]&#125; href=&quot;javascript:void(0)&quot; onClick=&#123;this.toUnread&#125;&gt; 已读（&lt;span&gt;&#123;this.tData.readedNum&#125;&lt;/span&gt;） &lt;/a&gt; &lt;/div&gt;); &#125;, toUnread() &#123; console.log(...) &#125; &#125; &#125;&lt;/script&gt;","categories":[],"tags":[]},{"title":"人工智能框架tensorflow学习总结","slug":"Tensorflow","date":"2018-06-14T01:12:28.962Z","updated":"2018-09-29T16:37:56.152Z","comments":true,"path":"2018/06/14/Tensorflow/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Tensorflow/","excerpt":"","text":"config &amp;&amp; use ####激活virtualenv 12345678910# 建立全新的virtualenv $ virtualenv --system-site-packages ~/tensorflow$ cd ~/tensorflow$ source bin/activate # 如果使用 bash$ source bin/activate.csh # 如果使用 csh(tensorflow)$ # 终端提示符应该发生变化# 使用完tensorflow后退出(tensorflow)$ deactivate","categories":[],"tags":[]},{"title":"Vue 学习总结","slug":"Vue","date":"2018-06-14T01:12:28.962Z","updated":"2018-09-29T16:38:57.141Z","comments":true,"path":"2018/06/14/Vue/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Vue/","excerpt":"","text":"vuevue 使用指南 [TOC] vue remind 使用html字符串 12345678910111213&lt;script&gt; new Vue(&#123; el: '#app', data() &#123; return &#123; htmlTemplate: '&lt;p&gt;这里是一段html&lt;/p&gt;' &#125; &#125; &#125;)&lt;/script&gt;&lt;div v-html=\"htmlTemplate\"&gt; &lt;/div&gt; vue cli 12vue list // 列出所有可用脚手架vue init webpack demo // 创建以webpack为脚手架名为demo的项目 main.js 123456789101112131415161718/* ----------- main.js ------------------ */import App from './App'new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;)// 与上面写法等效 (使用render函数)new Vue(&#123; el: '#app', router, store, render: h =&gt; h(App)&#125;) Vue config 1234# 在vue中使用less于编译器npm i less less-loader -S# webpack.base.config.jsmodules.exports.module.rules: [&#123;test: /\\.less$/, loader: 'style-loader!css-loader!less-loader'&#125;] vue plugins Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; vue directives 注册指令 123456789101112131415161718//全局注册Vue.directive('directiveName',&#123; bind: function (el, binding) &#123; //binding.value 指绑定的值 &#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;);//组件内注册export default &#123; directives: &#123; directiveName: &#123; bind() &#123;&#125; .....//一系列钩子函数 &#125; &#125;&#125; vue style 12345678&lt;!-- 样式引入--&gt;&lt;style lang=\"less\" scoped&gt; @import './demo.less'&lt;/style&gt;&lt;div :class=\"&#123;classOne: true, classTwo: true&#125;\" :style=\"&#123;color: 'red', fontSize: '12px', 'background-color': 'red'&#125;\"&gt;&lt;/div&gt; 12345678910111213141516171819/* --------------header 高度为100,动态设置main容器高度 --------- */let timer;export default &#123; data() &#123; return &#123; mainHeight: 0 &#125; &#125;, created() &#123; window.addEventListener('resize', () =&gt; &#123; if (timer) &#123; cleartTimeout(timer) &#125; else &#123; timer = setTimeout(() =&gt; &#123; this.mainHeight = window.innerHeight - 100; &#125;) &#125; &#125;) &#125;,&#125; vue load on demand 123456/* ---------------异步引入模块 ------------ */// 写法一const component = () =&gt; import('componentName') // 写法二const component = resolve =&gt; require(['componentName'],resolve) vue render（createElement function h） 1234567891011&lt;custom-component&gt; &lt;p slot=\"header\"&gt; 这里是头部内容 &lt;/p&gt; &lt;p&gt; 这里是默认slot内容 &lt;/p&gt; &lt;p slot=\"footer\"&gt; 这里是底部内容 &lt;/p&gt;&lt;/custom-component&gt; 12345678910111213// render 函数Vue.component('customComponent', &#123; render(h) &#123; let hearder = this.$slot.header; let main = this.$slot.default; let footer = this.$slot.footer; return h('div', [ h('header', header), h('main', main), h('footer', footer), ]) &#125;&#125;) vue render（with jsx） {value} 单花括号变量名 1234567891011121314151617181920new Vue(&#123; el: '#demo', props: ['name','imgSrc'], methods: &#123; handleImgClick() &#123; console.log('awesome picture') &#125; &#125;, render(h) &#123; return ( &lt;div level=&#123;1&#125; name=&#123;this.name&#125; class=&#123;&#123; foo: true, bar: false &#125;&#125; style=&#123;&#123; color: 'red', fontSize: '14px' &#125;&#125;&gt; &lt;img src=&#123;this.imgSrc&#125; onClick=&#123;this.handleImgClick&#125;/&gt; &lt;/div&gt; ) &#125;&#125;) Vue options 1234567// watch 深度观察, *注: 观察数组时不需要deep，但是arr[1] = 1,赋值操作不会触发观察,方法操作才会触发例如arr.splice(0, 1, 1)watch: &#123; c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;&#125; service 分离请求(太多ajax太丑陋，封装成单个js暴露出去，每个方法均返回promise实例) 123456789101112131415161718192021// index.jsimport Vue from 'vue'import VueResource from 'vue-resource'Vue.use(VueResource)// 小 service模块import login from './login' import cart from '.cart'export default &#123; login, cart,&#125;// cart.jsimport Vue from 'vue'export default &#123; getProductsById(id) &#123; return Vue.http.get('url', &#123;params: &#123;id&#125;&#125;) &#125;&#125; vue others 123456789101112131415161718192021222324252627// Vue.extend(component) 创建并返回一个子类，可用于构造新组件用于测试import app from './app'const App = Vue.extend(app)new App().$mount('#id') // 创建并挂载组件const vm = new App().$mount() // 创建组件并挂载（也可以不挂载）expect(vm.$el.querySelector('h1').textContent).toEqual('title') // 判断组件内部选择器h1内容// 路由跳转this.$router.push(&#123;name: 'pathName'&#125;)/* --------------------返回当前route路径 ------------------ */computed() &#123; return this.$route.path&#125;/* ----------单独引用element 组件使用方法------- */import &#123; MessageBox &#125; from 'element-ui'//单独调用MessageBox.alert(msg, title, &#123;type:'error'&#125;);//挂载后调用this.$alert(msg, title, &#123;type:'error'&#125;);/*---------------动态组建 (可用于一个页面有多个弹窗)----------------------*/v-bind:is=”componentName”&lt;component :is=”currentView”&gt;&lt;/component&gt;","categories":[],"tags":[]},{"title":"树莓派 调试开发配置指南","slug":"Raspberry","date":"2018-06-14T01:12:28.961Z","updated":"2018-09-29T16:19:01.281Z","comments":true,"path":"2018/06/14/Raspberry/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Raspberry/","excerpt":"","text":"系统设置App软件源 文件位置 /etc/apt/sources.list Ip地址 //ip 192.168.17.149 wlan 192.168.41.89 Mjpg-streamer 使用 1./mjpg_streamer -i \"./input_uvc.so -d /dev/video0 -n -y -f 25 -r 640x480\" -o \"./output_http.so -n -w /usr/local/www\" 访问：http://localhost:8080/?action=stream 改变文件权限 1chmod 751 file 三个数字从左到右（用户，用户组，其它成员） 4：读取，2：写入，1：执行【7 = 所有权限】 把可执行文件设为全局命令 1ln -s name /usr/local/bin/name boot设置 1sudo raspi-config wringPi 1 引脚可以设置为servo模式new five.Pin({pin:1,mode:4}) wifi 设置 12345//搜索附近wifiiwlist scan //编辑文件设置密码sudo vim /etc/wpa_supplicant/wpa_supplicant.conf windows 环境变量设置set //显示全部环境变量set Path=… //设置环境变量path linux 显示环境变量env 查看端口占用情况netstat mac os ssh 连接树莓派1$ ssh pi@192.168.17.149 我的树莓派设置vnc 密码 12341234 wiringPi引脚定义，图例如下 fritizing 使用说明资源库","categories":[],"tags":[]},{"title":"Regexp 正则表达式实用总结","slug":"Regexp","date":"2018-06-14T01:12:28.961Z","updated":"2018-09-29T16:23:17.479Z","comments":true,"path":"2018/06/14/Regexp/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Regexp/","excerpt":"","text":"正则表达式学习笔记1234567891011121314151617181920212223242526272829303132333435363738394041- 作为元字符只能用在[] 例如[a-z] 除此之外不需要转义 /-\\d/ ，匹配-5 # 也是普通字符，不需转义^ 取非匹配 [^a-z] 用在[]表示除a-z以外的所有字符\\[ 要匹配特殊字符[ 必须转义，例如匹配myArr[8] --- 模式为 myArr\\[[0-9]\\]单个匹配空白符 \\r 回车 \\n 换行 \\t 制表符任一空白符 \\s === [\\r\\t\\n\\f\\v]任意数字 \\d === [0-9] 非数字 \\D === [^0-9]任意字母数字下划线 \\w === [0-9a-zA-z_] 非数字字母下划线 \\W === [^0-9a-zA-z_]+ 匹配至少一个字符(贪婪形多多益善) +？匹配至少一个字符（懒惰型满足就返回) * 匹配0次或多次（贪婪形多多益善）*? 匹配0次或多次（懒惰型满足就返回）？ 匹配0个或1个&#123;3&#125; 匹配3次才算一次匹配&#123;2，4&#125; 匹配最少2次，最多4次&#123;3，&#125; 匹配至少重复3次/ 正斜杠不用转义\\b boundary 单词边界，单词的开始或结尾\\B 非边界^ 字符串开头位置$ 字符串结尾位置","categories":[],"tags":[]},{"title":"Python 学习总结","slug":"Python","date":"2018-06-14T01:12:28.960Z","updated":"2018-09-29T16:18:23.446Z","comments":true,"path":"2018/06/14/Python/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Python/","excerpt":"","text":"usage12# 手动下载库函数pip install pandas Tip 是索引-1返回列表最后一个元素，-2 返回倒数第二个… [1,2,3][-1] # return 3 ** 表示乘方 , 3 ** 2 # return 9 命令行键入 quit() + 回车 退出命令行 列表末尾增加元素 list.append()。 插入 list.insert(index, el)。 删除元素del list[0]。删除并弹出最后一个list.pop()。 删除并弹出任一项list.pop(index) 。 根据值删除元素list.remove(value)并使用，如果有重复只删除第一个。 语句末尾无分号，注释用 # 去除字符串右边空格（空行/换行符等） str.rstrip(), 去除左边空格 str.strip() ​ 排序 list.sort(reverse=True) #按字母反向排序 , 临时排序 list2 = list.sorted(). 长度 len(list) for 循环 for 语句以：结尾， 下一行有缩进 1234dogs = [‘harmi’, ‘lucy’, ‘catty’]for dog in dogs: pring('welcome' + dog) ​ 生成数字列表 list(range(1,5)), # returns [1,2,3,4],指定步长 list(range(5,10,2)),# returns [5,7,9] 列表统计计算 list = [1,2,3] min(list) # returns 1,max(list) #returns 3,sum(list) #returns 6 列表解析 a = [value \\ 2** for value in range(1,5)] #returns [1,4,9,16] 列表切片 list = [1,2,3,4,5] list[1:3] # returns [2,3], list[:3] # returns [1:2,3], list[1:] # returns [2,3,4,5] 复制列表 list2 = list[:] 定义元祖（不可改变其中元素的列表） dimensions = (1,2,3,4,5) 条件判断 与 and , 或 or , 存在于 in , 例如： 1 in (1,2,3) # returns True，不包含 not in 等于 == ,大于等于 &gt;= ,取非 not if语句 if condition_test: if []: 不会执行，空数组的布尔值等于false 字典定义 alien = {‘color’: ‘red’, num: 5}, 访问值 alien[‘color’] # returns ‘red’ , 删除键值 del alien[‘red’] 23.字典遍历12345678910111213141516171819# 遍历键值for key,value in alien.items(): print(key+':'+value) # 遍历键for key in alien.keys(): print(key) # 遍历值for val in alien.values(): print(val) # 顺序遍历键for key in sorted(alien.keys()): print(key)# 遍历不重复的集合for key in set(alien.values()): print(key) input()用户输入 message = input(‘give some tips’) ， 输入的文字被视为字符串，格式化为数字 message=int(message) 函数 12345678910111213141516171819# 定义函数def fn(): \"\"\"此处为文档字符串，描述函数功能，以三个引号起始\"\"\" print('hello word') # 默认值函数def fn(a=1, b=2): print(a,b) # 传递任意数量的参数, *会创建一个args 的空元组，然后依次入参def fn(*args): print(args)fn(1,2,3,4) # returns (1,2,3,4)# 传递任意数量的关键字形参 ，** 会创建一个空字典，并将收到的键值对装进这个空字典def fn(**dir): for key,val in dir: print(key,val)fn(a = 1, b = 2 ) # returns &#123;'a': 1, 'b': 2&#125; 模块 1234567891011121314151617# 整体导入import module_name # 调用模块的函数module_name.fn()# 导入特定的函数from module_name import fnfn()# as 给导入的函数起别名from module_name import function_name as fn# as 给导入的模块取别名import module_name as mn# 导入模块中的所有函数 , 引入之后元模块中所有的变量都可以直接使用from module_name import * 类 12345678910111213141516171819202122232425262728# 创建类class Dog(): \"\"\"模拟小狗\"\"\" def __init__(self, name, age): \"\"\"初始化函数,每次实例化时会自动调用\"\"\" self.name = name, self.age = age def jump(self): \"\"\"模拟小狗跳\"\"\" print('dog' + self.name + 'is jumping')# 实例化haski = Dog('haski', 2)# 继承类class Parent(): \"\"\"我是父类\"\"\" def __init__(self, name, age): self.name = name self.age = age def some_fn(self): print('i am ' + self.name):class Sub(Parent): def __init__(self, name, age): self.name = name self.age = age 读写文件 123456789101112131415161718192021222324252627282930# 打开文件读取with open('some.txt') as file: contents = file.read() print(contents)# 逐行读取with open('some.txt') as file: for line in file: print(line) # 读取文件赋值给列表with open(some.txt) as file: lines = file.readLines()for line in lines: print(line.strip())# 打开文件模式 , 第二个参数 mode 为 a追加, w写入, r读取(默认), r+读写 open('some.txt', 'w')# 使用json存储数据 json.dump(data, json_obj)import jsonnumbers = [1,2,3,4,5]with open('temp.json', 'w') as json_obj: json.dump(numbers, json_obj) # 读取json文件import jsonwith open('temp.json', 'r') as json_obj: number = json.load(json_obj)print(number) ​","categories":[],"tags":[]},{"title":"开发常见问题疑难解答","slug":"Puzzle","date":"2018-06-14T01:12:28.960Z","updated":"2018-09-29T16:17:54.057Z","comments":true,"path":"2018/06/14/Puzzle/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Puzzle/","excerpt":"","text":"why /\\d{6}/.test(‘440303008000’) //true 要只匹配6个数字 /^\\d{6}$/.test(‘1234566565’) //false Unexpected side effect in “sortArr” computed property 1234//vue 计算属性 ， this es-lint报错sortArr() &#123; return this.rankData.sort((prev, next) =&gt; next.value - prev.value);&#125; 原因 side effect 修改了原数据（data或prop） 正确做法 123sortArr() &#123; return this.rankData.slice(0).sort((prev, next) =&gt; next.value - prev.value);&#125; process变量在vue的静态环境和开发环境是否存在 12// 开发环境，无论是&lt;script&gt;标签还是mounted均存在// 静态环境（node http-server服务器和apache服务器均可） 无论是&lt;script&gt;标签还是mounted均存在 npm install 时 报错, 解决：删除package-lock.json继续下载 1Unexpected token &lt; in JSON at position 25997","categories":[],"tags":[]},{"title":"","slug":"Mini-programe","date":"2018-06-14T01:12:28.959Z","updated":"2018-07-30T07:27:37.977Z","comments":true,"path":"2018/06/14/Mini-programe/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Mini-programe/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"常用面试问题记录与分析","slug":"Interview","date":"2018-06-14T01:12:28.958Z","updated":"2018-10-01T15:00:06.357Z","comments":true,"path":"2018/06/14/Interview/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Interview/","excerpt":"","text":"interview 收录了经典前端面试题和解答 目录[TOC] 优质网站 https://blog.csdn.net/kongjiea/article/details/46341575 https://segmentfault.com/a/1190000000465431 http://www.cnblogs.com/syfwhu/p/4434132.html 术语xss 和 csrf区别 csrf (Cross-site request forgery) 跨站请求伪造， 攻击者盗用了你的身份，以你的名义发送恶意请求 。 条件 1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。 xss （Cross-site scripting） 分类 1.持久型（永久上传某段代码，之后的所有用户都会被攻击） 2.非持久型（让某个用户点击恶意代码片段连接，只对这个用户攻击）恶意代码注入，将恶意代码片段通过任何途径上传到服务器端，当下次用户进行访问时就会执行恶意代码 防御 1.过滤用户输入，谨慎存取2.对用户输入进行转码 http 和 https 的区别 http默认端口80，https默认端口443 https采用ssl加密，http无加密 https的web服务器启用ssl需要获得一个服务器证书，并将该证书与要使用ssl的服务器绑定 懒加载（load on demand)懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块 123456789101112131415161718// 1.webpack 使用promise和async函数实现 懒加载// 2.vue 使用 import 函数Vue.component('AsyncCmp', () =&gt; import('./AsyncCmp'))// 3.react 与 vue 类似const LoadableComponent = Loadable(&#123; loader: () =&gt; import('./Dashboard'), loading: Loading,&#125;)export default class LoadableDashboard extends React.Component &#123; render() &#123; return &lt;LoadableComponent /&gt;; &#125;&#125;// 图片懒加载 &lt;img&gt; 标签不要设置src属性，放在自定义属性中，根据window.scrollTop判断图片是否出现在用户视野中，如果出现 将自定义属性中的 url 放入src属性中 浏览器在输入url敲回车后发生了什么 步骤 1.DNS域名解析；2.建立TCP连接；3.发送HTTP请求；4.服务器处理请求；5.返回响应结果；6.关闭TCP连接；7.浏览器解析HTML；8.浏览器布局渲染； 步骤详解 建立tcp连接 ​ 发送http请求​ 关闭tcp连接 浏览器解析html 浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。 浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。 要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题。 浏览器布局渲染 根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。 replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。 最后浏览器绘制各个节点，将页面展示给用户。 高级问题分析双向数据绑定的原理，并用简单的代码实现1234567891011121314151617181920212223242526272829303132333435363738394041function Vue(options) &#123; this.$init(options);&#125;Vue.prototype.$init = function(options = &#123;&#125;) &#123; let data = this._data = options.data || &#123;&#125; let self = this let dep = new Dep() // 属性代理 vm.a === vm.data.a Object.keys(data).forEach((key, index) =&gt; &#123; Object.defineProperty(self, key, &#123; configurable: true, enumerable: true, get()&#123; return data[key] dep.depend() &#125;, set(val) &#123; data[key] = val dep.notice() &#125; &#125;) &#125;)&#125;function Dep() &#123; // &#125;Dep.prototype.notice = function() &#123; // 触发页面更新&#125;Dep.prototype.depend = function() &#123; // 关联当前所有数据和watcher的关系&#125;let vm = new Vue(&#123;data: &#123;a: 1, b: 2&#125;&#125;)console.log(vm.a === vm._data.a) // 实例访问数据vm.a = 3console.log(vm._data.a) 手动封装一个promise库，能实现基本的promise api。js实现快速排序（前端常见算法举例说明）实现深度拷贝1234567891011121314151617function clone(obj) &#123; if (obj instanceof Array) &#123; let ret = [] obj.forEach((item, index) =&gt; &#123; ret[index] = clone(item) &#125;) return ret &#125; else if (obj intanceof Object) &#123; let ret = &#123;&#125; Object.keys(ret).forEach((item, index) =&gt; &#123; ret[item] = clone(obj[item]) &#125;) return ret &#125; else &#123; return obj &#125;&#125;","categories":[],"tags":[]},{"title":"Git 操作大全","slug":"Git","date":"2018-06-14T01:12:28.915Z","updated":"2018-10-01T15:03:33.368Z","comments":true,"path":"2018/06/14/Git/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/Git/","excerpt":"","text":"Git git 配置, 命令 Table of contents[TOC] ##git config 新建ssh key 1ssh-keygen -t rsa -C 'zexiplus@outlook.com' 新增远程仓库 1git remote add origin git@github.com:zexiplus/oo.git 显示秘钥 1cat /c/Users/username/.ssh/id_rsa.pub 配置用户名密码 12git config --global user.name 'username'git config --global user.email 'username@tt.com' git command git 常用命令, [中括号内]代表可省略 显示所有仓库列表 1git branch -a 显示所有仓库列表 1git branch -r 显示本地仓库列表 1git branch 新建本地仓库分支 123git branch A# orgit checkout -b A 从远程拉取分支到本地分支(新建) 1git checkout -b R origin/A 为当前仓库设置对应的远程仓库 1git branch --set-upstream-to=origin/master master 切换分支 1git checkout A 切换回上次分支 1git checkout - 删除分支 1git branch -d A 把A分支合并到当前分支并作记录 1git merge -no-off A 修改上一条commit记录 1git commit --amend 图形化查看记录 1git log --graph 回滚到记录 1git reset --hard #hash 查看回滚记录 1git reflog 查看工作区和暂存区差别 1git diff 查看工作区和最新提交的差别 1git diff HEAD 推送至远程仓库 1git push -u [origin master] 从远程仓库拉取到本地仓库并合并到当前分支 123git pull [origin master]# or 强制拉取git pull --allow-unrelated-histories 从远程仓库拉取到本地仓库不自动合并 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 git pull [origin master] # 从远程仓库拉取到本地仓库不自动合并git fetch [origin master] # 比较本地仓库master和拉取到的远程仓库master区别git diff master origin/master # 合并已拉取到的远程仓库git merge origin/master # 备份当前的工作区的内容，从最近的一次提交中读取相关内容(被强行commit可跳过)git stash # 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容git stash pop # 更改仓库地址信息,之后添加git config -e [user] name = shizx email = shizx@balabala.com# 存储提交人信息, 之后不用输入账户密码[credential] helper = store # 把所有文件修改，删除，增加添加到暂存区git add . # 把某个文件从暂存区移除（工作区该文件还存在，会影响之后的本地仓库提交）git rm --cached filePath # 把某个文件中从暂存区移除(本地还存在)git rm -r --cached node_modules# 把所有文件修改，删除，增加添加到暂存区git add . # 把某个文件从暂存区的修改移除git reset filePath # 只恢复某个文件至某个历史版本git checkout $&#123;commit&#125; filePath git 四个阶段的撤销 概念 工作区: 文件在硬盘上的操作记录, git add 之前的状态 暂存区: 文件的暂存操作记录, git add 之后 git commit 之前 本地版本库: 已经提交的文件记录, git commit 之后, git push 之前, 会有对应的hash版本号 远程版本库: 已经推送到远程仓库的文件记录 , git push 之后 查看/撤销工作区文件变更 (只修改了没有git add ) 123456# 查看差别git diffgit checkout . # orgit reset –-hard 查看/撤销暂存区和本地仓库差异（已经git add 没有 git commit） 12345678910# 查看差别git diff –-cached# 还原暂存区(git add 反向操作)git reset# 还原工作区和暂存区git checkout .# orgit reset --hard 查看/撤销本地仓库和远程仓库差异（已提交未推送, git commit后还没有git push） 12345# 查看差异git diff master origin/master# 撤销修改至远程版本库git reset --hard origin/master 已经推送到远程仓库撤回(git push) 123# 恢复至上次提交 并推送重新覆盖git reset --hard HEAD^git push -f","categories":[],"tags":[]},{"title":"","slug":"README","date":"2018-06-14T01:12:28.914Z","updated":"2018-07-30T09:19:23.036Z","comments":true,"path":"2018/06/14/README/","link":"","permalink":"http://zexiplus.github.io/2018/06/14/README/","excerpt":"","text":"collection此文档仅分类并记录了一些常用知识点和工作踩坑总结, 供个人使用以提高产码效率，如需转载，请注明出处。 contentweb -web-design 「提供一些web整体布局方案,配色,素材选型,web设计原则」 -javascript 「javascript语法, 新特性总结」 -css 「css总结」 -html 「html总结」 -http 「网络协议解析」 -vue -vue-plugins -dom 「dom操作api汇总」 -nodejs -node-package 「实用node仓库记录」 -koa -mini-programe 「微信小程序总结」 -performance 「web性能优化注意事项」 -database 「sql/nosql数据库总结」 -elementUI -experience 「踩坑记录, 工作总结」 -test 「web工程自动化测试总结」 -graphic 「web绘图总结」 -debug 「web开发调试指南」 -git 「git 常用命令总结」 -regexp -bowser 「web浏览器接口总结」 -jquery others -tensorflow 「谷歌深度学习库」 -shortCuts 「pc快捷键」 -linux 「linux系统配置,操作总结」 -raspberry 「树莓派开发总结」 -puzzle 「工作中的技术上的bug,疑问记录」 -python 「python学习笔记」 -word 「阅读英文文档记录下来的一些单词」 -interview 「面试题解析汇总」","categories":[],"tags":[]}]}